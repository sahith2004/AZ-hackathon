grid reconstruction g2. magic triples (hard version) a. luotianyi and the show f. editorial for two e. playoff fixing d. toy machine a. musical puzzle c. dreaming of freedom h. don't blame me b. jojo's incredible adventures b1. range sorting (easy version) f. timber b. luotianyi and the table e. combinatorics problem a. new palindrome f. zombies b. fish graph e. removing graph f. random walk d. flipper b. lunatic never content f. ira and flamenco f. oh no1 (-2-3-4) e. half-sum f. fading into fog e. the lakes b2. luotianyi and the floating islands (hard version) b. array merging d. gold rush d. super-permutation b. permutation swap f. willy-nilly, crack, into release! b. maximum sum b2. range sorting (hard version) b. the butcher e. bosco and particle c. similar polynomials b. comparison string a. love story c. palindrome partition a. politics b. karina and array a. almost increasing subsequence e. walk the runway a. tubetube feed c. hyperregular bracket strings b. blank space b. restore the weather g. hits different c. luotianyi and xor-tree d. running miles c. the fox and the complete tree traversal f. forever winter c. tear it apart b. sort the subarray a. copil copac draws trees c. bun lover a. grasshopper on a line d. bracket coloring d. unique palindromes g1. magic triples (easy version) a. constructive problem e. round dance a. ian visits mary e. luotianyi and cartridge c. best binary string a. matching e. making anti-palindromes d. misha and apples d. mex tree b1. luotianyi and the floating islands (easy version) a. yura's new name d. xor counting d1. red-blue operations (easy version) f. copium permutation c. strongly composite e. rearrange brackets a. counting orders b. the boss can count pairs a. twin permutations c. contrast value b. sort with step c. vlad building beautiful array f. entangled substrings a. trust nobody a. divisible array f. gardening friends a. a-characteristic d. two centroids g. ksyusha and chinchilla d. luotianyi and the function e. bully sort c. mr. perfectly fine f. the third grace d2. red-blue operations (hard version) e. roads in e city e. bus routes d. black cells b. indivisible a. luotianyi and the palindrome string c. tear it apart b. sort with step g2. magic triples (hard version) d. running miles g1. magic triples (easy version) d. bracket coloring c. best binary string e. bully sort c. bun lover a. divisible array d. two centroids b. karina and array a. luotianyi and the show f. entangled substrings a. matching c. contrast value a. trust nobody d. unique palindromes f. oh no1 (-2-3-4) d2. red-blue operations (hard version) d. luotianyi and the function g. ksyusha and chinchilla c. luotianyi and xor-tree b. the boss can count pairs a. twin permutations a. love story a. luotianyi and the palindrome string a. grasshopper on a line e. bosco and particle b1. range sorting (easy version) e. luotianyi and cartridge f. zombies f. random walk a. almost increasing subsequence c. vlad building beautiful array a. a-characteristic a. copil copac draws trees e. playoff fixing e. round dance b. sort the subarray d. toy machine f. timber f. editorial for two f. ira and flamenco b. comparison string b. lunatic never content h. don't blame me b. maximum sum a. politics b1. luotianyi and the floating islands (easy version) b. grid reconstruction b. permutation swap e. rearrange brackets c. strongly composite e. bus routes c. similar polynomials b2. range sorting (hard version) d. black cells d. mex tree c. dreaming of freedom c. mr. perfectly fine e. removing graph a. ian visits mary e. making anti-palindromes f. forever winter f. gardening friends f. willy-nilly, crack, into release! d. xor counting a. yura's new name d. super-permutation a. new palindrome b. array merging d1. red-blue operations (easy version) a. musical puzzle f. copium permutation b. fish graph b. the butcher b. jojo's incredible adventures b2. luotianyi and the floating islands (hard version) c. the fox and the complete tree traversal a. counting orders c. hyperregular bracket strings e. walk the runway a. constructive problem e. roads in e city b. restore the weather a. tubetube feed d. flipper e. half-sum f. the third grace d. misha and apples b. indivisible f. fading into fog b. blank space c. palindrome partition e. combinatorics problem b. luotianyi and the table g. hits different e. the lakes d. gold rush

grid reconstruction time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output consider a 2×n grid, where n is an even integer. you may place the integers 1,2,…,2n on the grid, using each integer exactly once. a path is a sequence of cells achieved by starting at (1,1) , then repeatedly walking either downwards or to the right, and stopping when (2,n) is reached. the path should not extend beyond the grid. the cost of a path is the alternating sum of the numbers written on the cells in a path. that is, let the numbers written on the cells be a 1 , a 2 ,…, a k (in the order that it is visited), the cost of the path is a 1 − a 2 + a 3 − a 4 +…= ∑ k i=1 a i ⋅(−1 ) i+1 . construct a way to place the integers 1,2,…,2n on the grid, such that the minimum cost over all paths from (1,1) to (2,n) is maximized. if there are multiple such grids that result in the maximum value, output any of them. input the first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. the description of test cases follows. the first and the only line of each test case contains a single integer n ( 2≤n≤ 10 5 , n is even) — the number of the columns in the grid. it is guaranteed that the sum of n over all test cases does not exceed 10 5 . output for each test case, output 2 lines, each containing n integers — the desired grid. if there are multiple solutions, output any of them. example input copy 3 2 4 6 output copy 3 2 1 4 8 2 6 4 1 5 3 7 11 5 9 1 7 3 6 10 2 8 4 12 note in the first test case, there are only two paths from cell (1,1) to cell (2,2) . their costs are 3−1+4=6 and 3−2+4=5 . then the minimum cost is 5 , which is the maximum possible value. in the second test case, there are four paths from cell (1,1) to cell (2,4) . their costs are 8−1+5−3+7=16 , 8−2+5−3+7=15 , 8−2+6−3+7=16 , and 8−2+6−4+7=15 . then the minimum value is 15 , which is the maximum possible value.
jojo's incredible adventures time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output did you think there was going to be a jojo legend here? but no, that was me, dio! given a binary string s of length n , consisting of characters 0 and 1. let's build a square table of size n×n , consisting of 0 and 1 characters as follows. in the first row of the table write the original string s . in the second row of the table write cyclic shift of the string s by one to the right. in the third row of the table, write the cyclic shift of line s by two to the right. and so on. thus, the row with number k will contain a cyclic shift of string s by k to the right. the rows are numbered from 0 to n−1 top-to-bottom. in the resulting table we need to find the rectangle consisting only of ones that has the largest area. we call a rectangle the set of all cells (i,j) in the table, such that x1≤i≤x2 and y1≤j≤y2 for some integers 0≤x1≤x2<n and 0≤y1≤y2<n . recall that the cyclic shift of string s by k to the right is the string sn−k+1…sns1s2…sn−k . for example, the cyclic shift of the string "01011" by 0 to the right is the string itself "01011", its cyclic shift by 3 to the right is the string "01101". input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤2⋅104 ) — the number of test cases. the description of test cases follows. the first and the only line of each test case contains a single binary string s ( 1≤|s|≤2⋅105 ), consisting of characters 0 and 1. it is guaranteed that the sum of string lengths |s| over all test cases does not exceed 2⋅105 . output for each test case, output a single integer — the maximum area of a rectangle consisting only of ones. if there is no such rectangle, output 0 . example input copy 5 0 1 101 011110 101010 output copy 0 1 2 6 1 note in the first test case, there is a table 1×1 consisting of a single character 0, so there are no rectangles consisting of ones, and the answer is 0 . in the second test case, there is a table 1×1 , consisting of a single character 1, so the answer is 1 . in the third test case, there is a table: 1 0 1 1 1 0 0 1 1 in the fourth test case, there is a table: 0 1 1 1 1 0 0 0 1 1 1 1 1 0 0 1 1 1 1 1 0 0 1 1 1 1 1 0 0 1 1 1 1 1 0 0 in the fifth test case, there is a table: 1 0 1 0 1 0 0 1 0 1 0 1 1 0 1 0 1 0 0 1 0 1 0 1 1 0 1 0 1 0 0 1 0 1 0 1 rectangles with maximum area are shown in bold.
luotianyi and the palindrome string time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output luotianyi gives you a palindrome † string s , and she wants you to find out the length of the longest non-empty subsequence ‡ of s which is not a palindrome string. if there is no such subsequence, output −1 instead. † a palindrome is a string that reads the same backward as forward. for example, strings "z", "aaa", "aba", "abccba" are palindromes, but strings "codeforces", "reality", "ab" are not. ‡ a string a is a subsequence of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from b . for example, strings "a", "aaa", "bab" are subsequences of string "abaab", but strings "codeforces", "bbb", "h" are not. input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. the description of test cases follows. the first and the only line of each test case contains a single string s ( 1≤|s|≤50 ) consisting of lowercase english letters — the string that luotianyi gives you. it's guaranteed that s is a palindrome string. output for each test case, output a single integer — the length of the longest non-empty subsequence which is not a palindrome string. if there is no such subsequence, output −1 . example input copy 4 abacaba aaa codeforcesecrofedoc lol output copy 6 -1 18 2 note in the first test case, "abcaba" is a subsequence of "abacaba" as we can delete the third letter of "abacaba" to get "abcaba", and "abcaba" is not a palindrome string. we can prove that "abcaba" is an example of the longest subsequences of "abacaba" that isn't palindrome, so that the answer is 6 . in the second test case, we can only get "a" and "aa", but they are all palindrome strings, so the answer is −1 .
tear it apart time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are given a string s , consisting of lowercase latin letters. in one operation, you can select several (one or more) positions in it such that no two selected positions are adjacent to each other. then you remove the letters on the selected positions from the string. the resulting parts are concatenated without changing their order. what is the smallest number of operations required to make all the letters in s the same? input the first line contains a single integer t ( 1≤t≤104 ) — the number of testcases. the only line of each testcase contains a string s , consisting of lowercase latin letters. its length is from 1 to 2⋅105 . the total length of the strings over all testcases doesn't exceed 2⋅105 . output for each testcase, print a single integer — the smallest number of operations required to make all the letters in the given string s the same. example input copy 5 abacaba codeforces oooooooo abcdef mewheniseearulhiiarul output copy 1 3 0 2 4 note in the first testcase, you can select positions 2,4 and 6 and remove the corresponding letters 'b', 'c' and 'b'. in the third testcase, the letters in the string are already the same, so you don't have to make any operations. in the fourth testcase, one of the possible solutions in 2 operations is the following. you can select positions 1,4,6 first. the string becomes "bce". then select positions 1 and 3 . the string becomes "c". all letters in it are the same, since it's just one letter.
sort with step time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output let's define a permutation of length n as an array p of length n , which contains every number from 1 to n exactly once. you are given a permutation p1,p2,…,pn and a number k . you need to sort this permutation in the ascending order. in order to do it, you can repeat the following operation any number of times (possibly, zero): pick two elements of the permutation pi and pj such that |i−j|=k , and swap them. unfortunately, some permutations can't be sorted with some fixed numbers k . for example, it's impossible to sort [2,4,3,1] with k=2 . that's why, before starting the sorting, you can make at most one preliminary exchange: choose any pair pi and pj and swap them. your task is to: check whether is it possible to sort the permutation without any preliminary exchanges, if it's not, check, whether is it possible to sort the permutation using exactly one preliminary exchange. for example, if k=2 and permutation is [2,4,3,1] , then you can make a preliminary exchange of p1 and p4 , which will produce permutation [1,4,3,2] , which is possible to sort with given k . input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains two integers n and k ( 2≤n≤2⋅105 ; 1≤k≤n−1 ) — length of the permutation, and a distance between elements that can be swapped. the second line of each test case contains n integers p1,p2,…,pn ( 1≤pi≤n ) — elements of the permutation p . it is guaranteed that the sum of n over all test cases does not exceed 2⋅105 . output for each test case print 0, if it is possible to sort the permutation without preliminary exchange; 1, if it is possible to sort the permutation with one preliminary exchange, but not possible without preliminary exchange; -1, if it is not possible to sort the permutation with at most one preliminary exchange. example input copy 6 4 1 3 1 2 4 4 2 3 4 1 2 4 2 3 1 4 2 10 3 4 5 9 1 8 6 10 2 3 7 10 3 4 6 9 1 8 5 10 2 3 7 10 3 4 6 9 1 8 5 10 3 2 7 output copy 0 0 1 0 1 -1 note in the first test case, there is no need in preliminary exchange, as it is possible to swap (p1,p2) and then (p2,p3) . in the second test case, there is no need in preliminary exchange, as it is possible to swap (p1,p3) and then (p2,p4) . in the third test case, you need to apply preliminary exchange to (p2,p3) . after that the permutation becomes [3,4,1,2] and can be sorted with k=2 .
magic triples (hard version) time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output this is the hard version of the problem. the only difference is that in this version, ai≤109 . for a given sequence of n integers a , a triple (i,j,k) is called magic if: 1≤i,j,k≤n . i , j , k are pairwise distinct. there exists a positive integer b such that ai⋅b=aj and aj⋅b=ak . kolya received a sequence of integers a as a gift and now wants to count the number of magic triples for it. help him with this task! note that there are no constraints on the order of integers i , j and k . input the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of the test cases follows. the first line of the test case contains a single integer n ( 3≤n≤2⋅105 ) — the length of the sequence. the second line of the test contains n integers a1,a2,a3,…,an ( 1≤ai≤109 ) — the elements of the sequence a . the sum of n over all test cases does not exceed 2⋅105 . output for each test case, output a single integer — the number of magic triples for the sequence a . example input copy 7 5 1 7 7 2 7 3 6 2 18 9 1 2 3 4 5 6 7 8 9 4 1000 993 986 179 7 1 10 100 1000 10000 100000 1000000 8 1 1 2 2 4 4 8 8 9 1 1 1 2 2 2 4 4 4 output copy 6 1 3 0 9 16 45 note in the first example, there are 6 magic triples for the sequence a — (2,3,5) , (2,5,3) , (3,2,5) , (3,5,2) , (5,2,3) , (5,3,2) . in the second example, there is a single magic triple for the sequence a — (2,1,3) .
running miles time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output there is a street with n sights, with sight number i being i miles from the beginning of the street. sight number i has beauty bi . you want to start your morning jog l miles and end it r miles from the beginning of the street. by the time you run, you will see sights you run by (including sights at l and r miles from the start). you are interested in the 3 most beautiful sights along your jog, but every mile you run, you get more and more tired. so choose l and r , such that there are at least 3 sights you run by, and the sum of beauties of the 3 most beautiful sights minus the distance in miles you have to run is maximized. more formally, choose l and r , such that bi1+bi2+bi3−(r−l) is maximum possible, where i1,i2,i3 are the indices of the three maximum elements in range [l,r] . input the first line contains a single integer t ( 1≤t≤105 ) — the number of test cases. the first line of each test case contains a single integer n ( 3≤n≤105 ). the second line of each test case contains n integers bi ( 1≤bi≤108 ) — beauties of sights i miles from the beginning of the street. it's guaranteed that the sum of all n does not exceed 105 . output for each test case output a single integer equal to the maximum value bi1+bi2+bi3−(r−l) for some running range [l,r] . example input copy 4 5 5 1 4 2 3 4 1 1 1 1 6 9 8 7 6 5 4 7 100000000 1 100000000 1 100000000 1 100000000 output copy 8 1 22 299999996 note in the first example, we can choose l and r to be 1 and 5 . so we visit all the sights and the three sights with the maximum beauty are the sights with indices 1 , 3 , and 5 with beauties 5 , 4 , and 3 , respectively. so the total value is 5+4+3−(5−1)=8 . in the second example, the range [l,r] can be [1,3] or [2,4] , the total value is 1+1+1−(3−1)=1 .
magic triples (easy version) time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output this is the easy version of the problem. the only difference is that in this version, ai≤106 . for a given sequence of n integers a , a triple (i,j,k) is called magic if: 1≤i,j,k≤n . i , j , k are pairwise distinct. there exists a positive integer b such that ai⋅b=aj and aj⋅b=ak . kolya received a sequence of integers a as a gift and now wants to count the number of magic triples for it. help him with this task! note that there are no constraints on the order of integers i , j and k . input the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of the test cases follows. the first line of the test case contains a single integer n ( 3≤n≤2⋅105 ) — the length of the sequence. the second line of the test contains n integers a1,a2,a3,…,an ( 1≤ai≤106 ) — the elements of the sequence a . the sum of n over all test cases does not exceed 2⋅105 . output for each test case, output a single integer — the number of magic triples for the sequence a . example input copy 7 5 1 7 7 2 7 3 6 2 18 9 1 2 3 4 5 6 7 8 9 4 1000 993 986 179 7 1 10 100 1000 10000 100000 1000000 8 1 1 2 2 4 4 8 8 9 1 1 1 2 2 2 4 4 4 output copy 6 1 3 0 9 16 45 note in the first example, there are 6 magic triples for the sequence a — (2,3,5) , (2,5,3) , (3,2,5) , (3,5,2) , (5,2,3) , (5,3,2) . in the second example, there is a single magic triple for the sequence a — (2,1,3) .
bracket coloring time limit per test2 seconds memory limit per test512 megabytes inputstandard input outputstandard output a regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters "1" and "+" between the original characters of the sequence. for example: the bracket sequences "()()" and "(())" are regular (the resulting expressions are: "(1)+(1)" and "((1+1)+1)"); the bracket sequences ")(", "(" and ")" are not. a bracket sequence is called beautiful if one of the following conditions is satisfied: it is a regular bracket sequence; if the order of the characters in this sequence is reversed, it becomes a regular bracket sequence. for example, the bracket sequences "()()", "(())", ")))(((", "))()((" are beautiful. you are given a bracket sequence s . you have to color it in such a way that: every bracket is colored into one color; for every color, there is at least one bracket colored into that color; for every color, if you write down the sequence of brackets having that color in the order they appear, you will get a beautiful bracket sequence. color the given bracket sequence s into the minimum number of colors according to these constraints, or report that it is impossible. input the first line contains one integer t ( 1≤t≤104 ) — the number of test cases. each test case consists of two lines. the first line contains one integer n ( 2≤n≤2⋅105 ) — the number of characters in s . the second line contains s — a string of n characters, where each character is either "(" or ")". additional constraint on the input: the sum of n over all test cases does not exceed 2⋅105 . output for each test case, print the answer as follows: if it is impossible to color the brackets according to the problem statement, print −1 ; otherwise, print two lines. in the first line, print one integer k ( 1≤k≤n ) — the minimum number of colors. in the second line, print n integers c1,c2,…,cn ( 1≤ci≤k ), where ci is the color of the i -th bracket. if there are multiple answers, print any of them. example input copy 4 8 ((())))( 4 (()) 4 ))(( 3 (() output copy 2 2 2 2 1 2 2 2 1 1 1 1 1 1 1 1 1 1 1 -1
best binary string time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are given a string s consisting of the characters 0, 1 and/or ?. let's call it a pattern. let's say that the binary string (a string where each character is either 0 or 1) matches the pattern if you can replace each character ? with 0 or 1 (for each character, the choice is independent) so that the strings become equal. for example, 0010 matches ?01?, but 010 doesn't match 1??, ??, or ????. let's define the cost of the binary string as the minimum number of operations of the form "reverse an arbitrary contiguous substring of the string" required to sort the string in non-descending order. you have to find a binary string with the minimum possible cost among those that match the given pattern. if there are multiple answers, print any of them. input the first line contains a single integer t ( 1≤t≤3⋅104 ) — the number of test cases. the first and only line of each test case contains the string s ( 1≤|s|≤3⋅105 ) consisting of characters 0, 1, and/or ?. the sum of the string lengths over all test cases does not exceed 3⋅105 . output for each test case, print a binary string with the minimum possible cost among those that match the given pattern. if there are multiple answers, print any of them. example input copy 4 ??01? 10100 1??10? 0?1?10?10 output copy 00011 10100 111101 011110010 note in the first test case of the example, the cost of the resulting string is 0 . in the second test case, the cost of the resulting string is 2 : we can reverse the substring from the 1 -st character to the 5 -th character, and we obtain the string 00101. then we reverse the substring from the 3 -rd to the 4 -th character, and we obtain the string 00011, which is sorted in non-descending order.
bully sort time limit per test10 seconds memory limit per test1024 megabytes inputstandard input outputstandard output on a permutation p of length n , we define a bully swap as follows: let i be the index of the largest element pi such that pi≠i . let j be the index of the smallest element pj such that i<j . swap pi and pj . we define f(p) as the number of bully swaps we need to perform until p becomes sorted. note that if p is the identity permutation, f(p)=0 . you are given n and a permutation p of length n . you need to process the following q updates. in each update, you are given two integers x and y . you will swap px and py and then find the value of f(p) . note that the updates are persistent. changes made to the permutation p will apply when processing future updates. input the first line of the input contains two integers n and q ( 2≤n≤5⋅105 , 1≤q≤5⋅104 ) — the length of the permutation and the number of updates. the second line of input contains n integer p1,p2,…,pn ( 1≤pi≤n ) — the permutation p . all elements of p are distinct. the i -th of the next q lines of input contains two integers xi and yi ( 1≤xi<yi≤n ) — describing the i -th update. output after each update, output f(p) . example input copy 8 5 6 2 1 5 3 4 7 8 1 8 2 3 4 7 7 8 3 6 output copy 5 6 9 8 7 note after the first update, we have f(p)=5 . the 5 bully swaps are illustrated below. [1,2,8,5,3,4,7,6] , [1,2,3,5,8,4,7,6] , [1,2,3,5,4,8,7,6] , [1,2,3,5,4,6,7,8] , [1,2,3,4,5,6,7,8] .
bun lover time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output tema loves cinnabon rolls — buns with cinnabon and chocolate in the shape of a "snail". cinnabon rolls come in different sizes and are square when viewed from above. the most delicious part of a roll is the chocolate, which is poured in a thin layer over the cinnabon roll in the form of a spiral and around the bun, as in the following picture: cinnabon rolls of sizes 4, 5, 6 for a cinnabon roll of size n , the length of the outer side of the square is n , and the length of the shortest vertical chocolate segment in the central part is one. formally, the bun consists of two dough spirals separated by chocolate. a cinnabon roll of size n+1 is obtained from a cinnabon roll of size n by wrapping each of the dough spirals around the cinnabon roll for another layer. it is important that a cinnabon roll of size n is defined in a unique way. tema is interested in how much chocolate is in his cinnabon roll of size n . since tema has long stopped buying small cinnabon rolls, it is guaranteed that n≥4 . answer this non-obvious question by calculating the total length of the chocolate layer. input the first line of the input contains a single integer t ( 1≤t≤105 ) — the number of test cases. the following t lines describe the test cases. each test case is described by a single integer n ( 4≤n≤109 ) — the size of the cinnabon roll. output output t integers. the i -th of them should be equal to the total length of the chocolate layer in the i -th test case. example input copy 4 4 5 6 179179179 output copy 26 37 50 32105178545472401
range sorting (easy version) time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output the only difference between this problem and the hard version is the constraints on t and n . you are given an array a , consisting of n distinct integers a1,a2,…,an . define the beauty of an array p1,p2,…pk as the minimum amount of time needed to sort this array using an arbitrary number of range-sort operations. in each range-sort operation, you will do the following: choose two integers l and r ( 1≤l<r≤k ). sort the subarray pl,pl+1,…,pr in r−l seconds. please calculate the sum of beauty over all subarrays of array a . a subarray of an array is defined as a sequence of consecutive elements of the array. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤5⋅103 ). the description of the test cases follows. the first line of each test case contains a single integer n ( 1≤n≤5⋅103 ) — the length of the array a . the second line of each test case consists of n integers a1,a2,…,an ( 1≤ai≤109 ). it is guaranteed that all elements of a are pairwise distinct. it is guaranteed that the sum of n over all test cases does not exceed 5⋅103 . output for each test case, output the sum of beauty over all subarrays of array a . example input copy 5 2 6 4 3 3 10 6 4 4 8 7 2 5 9 8 2 4 6 12 2 6 13 3 15 5 10 8 16 9 11 18 output copy 1 2 8 16 232 note in the first test case: the subarray [6] is already sorted, so its beauty is 0 . the subarray [4] is already sorted, so its beauty is 0 . you can sort the subarray [6,4] in one operation by choosing l=1 and r=2 . its beauty is equal to 1 . the sum of beauty over all subarrays of the given array is equal to 0+0+1=1 . in the second test case: the subarray [3] is already sorted, so its beauty is 0 . the subarray [10] is already sorted, so its beauty is 0 . the subarray [6] is already sorted, so its beauty is 0 . the subarray [3,10] is already sorted, so its beauty is 0 . you can sort the subarray [10,6] in one operation by choosing l=1 and r=2 . its beauty is equal to 2−1=1 . you can sort the subarray [3,10,6] in one operation by choosing l=2 and r=3 . its beauty is equal to 3−2=1 . the sum of beauty over all subarrays of the given array is equal to 0+0+0+0+1+1=2 .
divisible array time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given a positive integer n . please find an array a1,a2,…,an that is perfect. a perfect array a1,a2,…,an satisfies the following criteria: 1≤ai≤1000 for all 1≤i≤n . ai is divisible by i for all 1≤i≤n . a1+a2+…+an is divisible by n . input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤200 ). the description of the test cases follows. the only line of each test case contains a single positive integer n ( 1≤n≤200 ) — the length of the array a . output for each test case, output an array a1,a2,…,an that is perfect. we can show that an answer always exists. if there are multiple solutions, print any. example input copy 7 1 2 3 4 5 6 7 output copy 1 2 4 1 2 3 2 8 6 4 3 4 9 4 5 1 10 18 8 5 36 3 6 21 24 10 6 14 note in the third test case: a1=1 is divisible by 1 . a2=2 is divisible by 2 . a3=3 is divisible by 3 . a1+a2+a3=1+2+3=6 is divisible by 3 . in the fifth test case: a1=3 is divisible by 1 . a2=4 is divisible by 2 . a3=9 is divisible by 3 . a4=4 is divisible by 4 . a5=5 is divisible by 5 . a1+a2+a3+a4+a5=3+4+9+4+5=25 is divisible by 5 .
two centroids time limit per test1.5 seconds memory limit per test1024 megabytes inputstandard input outputstandard output you are given a tree (an undirected connected acyclic graph) which initially only contains vertex 1 . there will be several queries to the given tree. in the i -th query, vertex i+1 will appear and be connected to vertex pi ( 1≤pi≤i ). after each query, please find out the least number of operations required to make the current tree has two centroids. in one operation, you can add one vertex and one edge to the tree such that it remains a tree. a vertex is called a centroid if its removal splits the tree into subtrees with at most ⌊ n 2 ⌋ vertices each, with n as the number of vertices of the tree. for example, the centroid of the following tree is 3 because the biggest subtree after removing the centroid has 2 vertices. in the next tree, vertex 1 and 2 are both centroids. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains a single integer n ( 2≤n≤5⋅105 ) — the number of nodes of the final tree. the second line of each test case contains n−1 integers p1,p2,…,pn−1 ( 1≤pi≤i ) — the index of the vertex that is connected to vertex i+1 . it is guaranteed that the sum of n over all test cases does not exceed 5⋅105 . output for each test case, output n−1 integers. the i -th integer is the answer to the i -th query — the least number of operations required to make the current tree have two centroids. we can show that an answer always exists. example input copy 5 2 1 3 1 1 4 1 2 3 7 1 2 3 2 5 2 10 1 2 2 4 5 5 7 8 9 output copy 0 0 1 0 1 0 0 1 0 1 2 3 0 1 2 1 0 1 0 1 2 note the illustrations below are of the fourth example test case. after the third query: the tree already has vertices 2 and 3 as centroids, so no operations are needed. after the fourth query: adding vertex x to the tree makes vertices 2 and 3 centroids. only one operation is needed. after the fifth query: adding vertex x and y to the tree makes vertices 5 and 2 centroids. two operations are needed. after the sixth query: adding vertex x , y , and z to the tree makes vertices 5 and 2 centroids. three operations are needed.
karina and array time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output karina has an array of n integers a1,a2,a3,…,an . she loves multiplying numbers, so she decided that the beauty of a pair of numbers is their product. and the beauty of an array is the maximum beauty of a pair of adjacent elements in the array. for example, for n=4 , a=[3,5,7,4] , the beauty of the array is \max ( 3 \cdot 5 , 5 \cdot 7 , 7 \cdot 4 ) = \max ( 15 , 35 , 28 ) = 35 . karina wants her array to be as beautiful as possible. in order to achieve her goal, she can remove some elements (possibly zero) from the array. after karina removes all elements she wants to, the array must contain at least two elements. unfortunately, karina doesn't have enough time to do all her tasks, so she asks you to calculate the maximum beauty of the array that she can get by removing any number of elements (possibly zero). input the first line of the input contains an integer t ( 1 \le t \le 10^4 ) — the number of test cases. the description of the test cases follows. the first line of a test case contains an integer n ( 2 \le n \le 2 \cdot 10^5 ) — the length of the array a . the second line of a test case contains n integers a_1, a_2, a_3, \dots, a_n ( -10^9 \le a_i \le 10^9 ) — the elements of the array a . the sum of all values of n across all test cases does not exceed 2 \cdot 10^5 . output output t integers, each of which is the answer to the corresponding test case — the maximum beauty of the array that karina can get. example input copy 7 4 5 0 2 1 3 -1 1 0 5 2 0 -1 -4 0 6 -8 4 3 7 1 -9 6 0 3 -2 5 -4 -4 2 1000000000 910000000 7 -1 -7 -2 -5 -4 -6 -3 output copy 10 0 4 72 16 910000000000000000 42 note in the first test case of the example, to get the maximum beauty, you need to remove the 2 -nd element. in the second and third test cases of the example, there is no need to remove any elements to achieve maximum beauty. in the fourth test case of the example, you need to leave only the first and last elements.
luotianyi and the show time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output there are n people taking part in a show about vocaloid. they will sit in the row of seats, numbered 1 to m from left to right. the n people come and sit in order. each person occupies a seat in one of three ways: sit in the seat next to the left of the leftmost person who is already sitting, or if seat 1 is taken, then leave the show. if there is no one currently sitting, sit in seat m . sit in the seat next to the right of the rightmost person who is already sitting, or if seat m is taken, then leave the show. if there is no one currently sitting, sit in seat 1 . sit in the seat numbered xi . if this seat is taken, then leave the show. now you want to know what is the maximum number of people that can take a seat, if you can let people into the show in any order? input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of test cases follows. the first line of each test case contains two integers n and m ( 1≤n,m≤105 ) — the number of people and the number of seats. the second line of each test case contains n integers x1,x2,…,xn ( −2≤xi≤m , xi≠0 ), the i -th of which describes the way in which the i -th person occupies a seat: if xi=−1 , then i -th person takes the seat in the first way. if xi=−2 , then i -th person takes the seat in the second way. if xi>0 , then the i -th person takes a seat in the third way, i.e. he wants to sit in the seat with the number xi or leave the show if it is occupied.. it is guaranteed that sum of n and the sum of m over all test cases don't exceed 105 . output for each test case output a single integer — the maximum number of people who can occupy a seat. example input copy 10 3 10 5 5 5 4 6 1 -2 -2 1 5 7 -1 -1 4 -2 -2 6 7 5 -2 -2 -2 -2 -2 6 6 -1 1 4 5 -1 4 6 8 -1 -1 -1 3 -1 -2 6 7 5 -1 -2 -2 -2 -2 3 1 -2 -2 1 2 5 5 -2 1 2 -1 output copy 1 3 5 6 5 5 5 1 2 1 note in the first test case, all the people want to occupy the 5 seat, so only 1 people can occupy the seat. in the second test case, we can let people in order 1,2,3,4 , then all but the last person can take a seat. in the third test case, we can let people into the show in that order: let the third person in: – – – 3 – – – let the fourth person in: – – – 3 4 – – let the fifth person in: – – – 3 4 5 – let the first person in: – – 1 3 4 5 – let the second person in: – 2 1 3 4 5 – thus, all 5 people took seats. in the fifth test case, we can let people into the show in this order: let the fourth person in: – – – – 4 – let the third person in: – – – 3 4 – let the sixth person in, he'll leave the show because he takes the third seat the third way and has to sit in the 4 seat, but it's already taken: – – – 3 4 – let the fifth person in: – – 5 3 4 – let the first person in: – 1 5 3 4 – let the second person in: 2 1 5 3 4 – thus, 5 of people took seats. in the seventh test case, we can let people into the show in this order: let the third person in: 3 – – – – – – let the fourth person in: 3 4 – – – – – let the fifth person in: 3 4 5 – – – – let the sixth person in: 3 4 5 6 – – – let the first person in: 3 4 5 6 1 – – let the second person in, he will leave the show because he occupies the first way, but the 1 seat is taken: 3 4 5 6 1 – – thus, 5 people took seats.
entangled substrings time limit per test2 seconds memory limit per test256 mebibytes inputstandard input outputstandard output quantum entanglement is when two particles link together in a certain way no matter how far apart they are in space. you are given a string s . a pair of its non-empty substrings (a,b) is called entangled if there is a (possibly empty) link string c such that: every occurrence of a in s is immediately followed by cb ; every occurrence of b in s is immediately preceded by ac . in other words, a and b occur in s only as substrings of acb . compute the total number of entangled pairs of substrings of s . a string a is a substring of a string b if a can be obtained from b by the deletion of several (possibly zero or all) characters from the beginning and several (possibly zero or all) characters from the end. input the first and only line contains a string s of lowercase english letters ( 1≤|s|≤105 ) — the string for which you should count pairs of entangled substrings. output output a single integer, the number of entangled pairs of substrings of s . examples input copy abba output copy 1 input copy abacaba output copy 0 input copy abcabcabcabc output copy 5 input copy adamant output copy 82 note in the first example, the only entangled pair is (ab,ba). for this pair, the corresponding link string c is empty, as they only occur as substrings of the whole string abba, which doesn't have any characters between ab and ba. in the second example, there are no entangled pairs. in the third example, the entangled pairs are (a,b), (b,c), (a,c), (a,bc), and (ab,c). for most pairs, the corresponding link string c is empty, except for the pair (a,c), for which the link string c is b, as a and c only occur as substrings of the string abc.
matching time limit per test2 seconds memory limit per test512 megabytes inputstandard input outputstandard output an integer template is a string consisting of digits and/or question marks. a positive (strictly greater than 0 ) integer matches the integer template if it is possible to replace every question mark in the template with a digit in such a way that we get the decimal representation of that integer without any leading zeroes. for example: 42 matches 4?; 1337 matches ????; 1337 matches 1?3?; 1337 matches 1337; 3 does not match ??; 8 does not match ???8; 1337 does not match 1?7. you are given an integer template consisting of at most 5 characters. calculate the number of positive (strictly greater than 0 ) integers that match it. input the first line contains one integer t ( 1≤t≤2⋅104 ) — the number of test cases. each test case consists of one line containing the string s ( 1≤|s|≤5 ) consisting of digits and/or question marks — the integer template for the corresponding test case. output for each test case, print one integer — the number of positive (strictly greater than 0 ) integers that match the template. example input copy 8 ?? ? 0 9 03 1??7 ?5? 9??99 output copy 90 9 0 1 0 100 90 100
contrast value time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output for an array of integers [a1,a2,…,an] , let's call the value |a1−a2|+|a2−a3|+⋯+|an−1−an| the contrast of the array. note that the contrast of an array of size 1 is equal to 0 . you are given an array of integers a . your task is to build an array of b in such a way that all the following conditions are met: b is not empty, i.e there is at least one element; b is a subsequence of a , i.e b can be produced by deleting some elements from a (maybe zero); the contrast of b is equal to the contrast of a . what is the minimum possible size of the array b ? input the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the first line of each test case contains a single integer n ( 1≤n≤3⋅105 ) — the size of the array a . the second line contains n integers a1,a2,⋅,an ( 0≤ai≤109 ) — elements of the array itself. the sum of n over all test cases doesn't exceed 3⋅105 . output for each test case, print a single integer — the minimum possible size of the array b . example input copy 4 5 1 3 3 3 7 2 4 2 4 1 1 1 1 7 5 4 2 1 0 0 4 output copy 2 2 1 3
trust nobody time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output there is a group of n people. some of them might be liars, who always tell lies. other people always tell the truth. the i -th person says "there are at least li liars amongst us". determine if what people are saying is contradictory, or if it is possible. if it is possible, output the number of liars in the group. if there are multiple possible answers, output any one of them. input the first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. the first line of each test case contains a single integer n ( 1≤n≤100 ). the second line of each test case contains n integers li ( 0≤li≤n ) — the number said by the i -th person. it's guaranteed that the sum of all n does not exceed 104 . output for each test case output a single integer. if what people are saying is contradictory, output −1 . otherwise, output the number of liars in the group. if there are multiple possible answers, output any one of them. example input copy 7 2 1 2 2 2 2 2 0 0 1 1 1 0 5 5 5 3 3 5 6 5 3 6 6 3 5 output copy 1 -1 0 -1 0 3 4 note in the first example, the only possible answer is that the second person is a liar, so the answer is 1 liar. in the second example, it can be proven that we can't choose the liars so that all the requirements are satisfied. in the third example, everybody tells the truth, so the answer is 0 liars.
unique palindromes time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output a palindrome is a string that reads the same backwards as forwards. for example, the string abcba is palindrome, while the string abca is not. let p(t) be the number of unique palindromic substrings of string t , i. e. the number of substrings t[l…r] that are palindromes themselves. even if some substring occurs in t several times, it's counted exactly once. (the whole string t is also counted as a substring of t ). for example, string t = abcbbcabcb has p(t)=6 unique palindromic substrings: a, b, c, bb, bcb and cbbc. now, let's define p(s,m)=p(t) where t=s[1…m] . in other words, p(s,m) is the number of palindromic substrings in the prefix of s of length m . for example, p( abcbbcabcb ,5) = p( abcbb )=5 . you are given an integer n and k "conditions" ( k≤20 ). let's say that string s , consisting of n lowercase latin letters, is good if all k conditions are satisfied at the same time. a condition is a pair (xi,ci) and have the following meaning: p(s,xi)=ci , i. e. a prefix of s of length xi contains exactly ci unique palindromic substrings. find a good string s or report that such s doesn't exist. look in notes if you need further clarifications. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains two integers n and k ( 3≤n≤2⋅105 ; 1≤k≤20 ) — length of good string s and number of conditions. the second line of each test case contains k integers x1,x2,…,xk ( 3≤x1<x2<⋯<xk=n ) where xi is the length of the prefix in the i -th condition. the third line of each test case contains k integers c1,c2,…,ck ( 3≤c1≤c2≤⋯≤ck≤min(109, (n+1)n 2 ) ) where ci is the number of palindromic substrings in the i -th condition. it is guaranteed that the sum of n over all test cases does not exceed 2⋅105 . output for each test case, if there is no good string s of length n that satisfies all conditions, print no. otherwise, print yes and a string s of length n , consisting of lowercase latin letters, that satisfies all conditions. if there are multiple answers, print any of them. example input copy 7 10 2 5 10 5 6 3 1 3 3 4 2 3 4 3 3 4 2 3 4 3 4 4 1 4 5 10 3 4 6 10 4 5 8 10 4 4 6 7 10 4 5 7 8 output copy yes abcbbcabcb yes foo yes ayda yes wada no yes abcbcacbab no note in the first test case, string s = abcbbcabcb satisfies k=2 conditions: p(s,x1)=p(s,5)= p( abcbb )=5=s1 . palindromic substrings are a, b, c, bb and bcb. p(s,x2)=p(s,10)= p( abcbbcabcb )=6=s2 . palindromic substrings are the same as above, and one extra substring cbbc. in the second test case, string foo satisfies k=1 condition: p( foo )=3 . palindromic substrings are f, o and oo. there are other possible answers. in the third test case, string ayda satisfies k=2 conditions: p( ayd )=3 . palindromic substrings are a, y and d. p( ayda )=3 . palindromic substrings are the same. in the fourth test case, string wada satisfies k=2 conditions: p( wad )=3 . palindromic substrings are w, a and d. p( wada )=4 . palindromic substrings are the same, and one extra substring ada. in the fifth test case, it can be proven that there is no string of length 4 which has 5 palindromic substrings. in the sixth test case, string abcbcacbab satisfies k=3 conditions: p( abcb )=4 . palindromic substrings are a, b, c and bcb. p( abcbca )=5 . palindromic substrings are the same, and one extra substring cbc. p( abcbcacbab )=8 . palindromic substrings are the same, and three extra substrings cac, bab and bcacb.
oh no1 (-2-3-4) time limit per test4 seconds memory limit per test512 megabytes inputstandard input outputstandard output you are given an undirected graph with n vertices and 3m edges. the graph may contain multi-edges, but does not contain self-loops. the graph satisfies the following property: the given edges can be divided into m groups of 3 , such that each group is a triangle. a triangle is defined as three edges (a,b) , (b,c) and (c,a) for some three distinct vertices a,b,c ( 1≤a,b,c≤n ). initially, each vertex v has a non-negative integer weight av . for every edge (u,v) in the graph, you should perform the following operation exactly once: choose an integer x between 1 and 4 . then increase both au and av by x . after performing all operations, the following requirement should be satisfied: if u and v are connected by an edge, then au≠av . it can be proven this is always possible under the constraints of the task. output a way to do so, by outputting the choice of x for each edge. it is easy to see that the order of operations does not matter. if there are multiple valid answers, output any. input the first line contains a single integer t ( 1≤t≤105 ) — the number of test cases. the description of test cases follows. the first line of each test case contains two integers n and m ( 3≤n≤106 , 1≤m≤4⋅105 ) — denoting the graph have n vertices and 3m edges. the second line of each test case contains n integers a1,a2,…,an ( 0≤ai≤106 ) — the initial weights of each vertex. then m lines follow. the i -th line contains three integers ai , bi , ci ( 1≤ai<bi<ci≤n ) — denotes that three edges (ai,bi) , (bi,ci) and (ci,ai) . note that the graph may contain multi-edges: a pair (x,y) may appear in multiple triangles. it is guaranteed that the sum of n over all test cases does not exceed 106 and the sum of m over all test cases does not exceed 4⋅105 . output for each test case, output m lines of 3 integers each. the i -th line should contains three integers eab,ebc,eca ( 1≤eab,ebc,eca≤4 ), denoting the choice of value x for edges (ai,bi) , (bi,ci) and (ci,ai) respectively. example input copy 4 4 1 0 0 0 0 1 2 3 5 2 0 0 0 0 0 1 2 3 1 4 5 4 4 3 4 5 6 1 2 3 1 2 4 1 3 4 2 3 4 5 4 0 1000000 412 412 412 1 2 3 1 4 5 2 4 5 3 4 5 output copy 2 1 3 2 3 3 4 3 3 3 1 2 2 2 3 2 3 4 3 1 1 2 3 4 1 2 4 4 4 3 4 1 1 note in the first test case, the initial weights are [0,0,0,0] . we have added values as follows: added 2 to vertices 1 and 2 added 1 to vertices 2 and 3 added 3 to vertices 3 and 1 the final weights are [5,3,4,0] . the output is valid because a1≠a2 , a1≠a3 , a2≠a3 , and that all chosen values are between 1 and 4 . in the second test case, the initial weights are [0,0,0,0,0] . the weights after the operations are [12,5,6,7,6] . the output is valid because a1≠a2 , a1≠a3 , a2≠a3 , and that a1≠a4 , a1≠a5 , a4≠a5 , and that all chosen values are between 1 and 4 . in the third test case, the initial weights are [3,4,5,6] . the weights after the operations are [19,16,17,20] , and all final weights are distinct, which means no two adjacent vertices have the same weight.
timber time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output there is a beautiful alley with trees in front of a shopping mall. unfortunately, it has to go to make space for the parking lot. the trees on the alley all grow in a single line. there are n spots for trees, index 0 is the shopping mall, index n+1 is the road and indices from 1 to n are the spots for trees. some of them are taken — there grow trees of the same height k . no more than one tree grows in each spot. when you chop down a tree in the spot x , you can make it fall either left or right. if it falls to the left, it takes up spots from x−k to x , inclusive. if it falls to the right, it takes up spots from x to x+k , inclusive. let m trees on the alley grow in some spots x1,x2,…,xm . let an alley be called unfortunate if all m trees can be chopped down in such a way that: no tree falls on the shopping mall or the road; each spot is taken up by no more than one fallen tree. calculate the number of different unfortunate alleys with m trees of height k . two alleys are considered different if there is a spot y such that a tree grows in y on the first alley and doesn't grow in y on the second alley. output the number modulo 998244353 . input the only line contains three integers n,m and k ( 1≤m,k≤n≤3⋅105 ) — the number of spots for the trees, the number of trees and the height of each tree. output print a single integer — the number of different unfortunate alleys with m trees of height k , modulo 998244353 . examples input copy 6 1 4 output copy 4 input copy 5 2 2 output copy 0 input copy 6 2 2 output copy 4 input copy 15 3 2 output copy 311
red-blue operations (hard version) time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output the only difference between easy and hard versions is the maximum values of n and q . you are given an array, consisting of n integers. initially, all elements are red. you can apply the following operation to the array multiple times. during the i -th operation, you select an element of the array; then: if the element is red, it increases by i and becomes blue; if the element is blue, it decreases by i and becomes red. the operations are numbered from 1 , i. e. during the first operation some element is changed by 1 and so on. you are asked q queries of the following form: given an integer k , what can the largest minimum in the array be if you apply exactly k operations to it? note that the operations don't affect the array between queries, all queries are asked on the initial array a . input the first line contains two integers n and q ( 1≤n,q≤2⋅105 ) — the number of elements in the array and the number of queries. the second line contains n integers a1,a2,…,an ( 1 \le a_i \le 10^9 ). the third line contains q integers k_1, k_2, \dots, k_q ( 1 \le k_j \le 10^9 ). output for each query, print a single integer — the largest minimum that the array can have after you apply exactly k operations to it. examples input copy 4 10 5 2 8 4 1 2 3 4 5 6 7 8 9 10 output copy 3 4 5 6 7 8 8 10 8 12 input copy 5 10 5 2 8 4 4 1 2 3 4 5 6 7 8 9 10 output copy 3 4 5 6 7 8 9 8 11 8 input copy 2 5 2 3 10 6 8 1 3 output copy 10 7 8 3 3
luotianyi and the function time limit per test7 seconds memory limit per test1024 megabytes inputstandard input outputstandard output luotianyi gives you an array a of n integers and the index begins from 1 . define g(i,j) as follows: g(i,j) is the largest integer x that satisfies {ap:i≤p≤j}⊆{aq:x≤q≤j} while i≤j ; and g(i,j)=0 while i>j . there are q queries. for each query you are given four integers l,r,x,y , you need to calculate r ∑ i=l y ∑ j=x g(i,j) . input the first line contains two integers n and q ( 1≤n,q≤106 ) — the length of the array a and the number of queries. the second line contains n integers a1,a2,…,an ( 1≤ai≤n ) — the elements of the array a . next q lines describe a query. the i -th line contains four integers l,r,x,y ( 1≤l≤r≤n,1≤x≤y≤n ) — the integers in the i -th query. output print q lines where i -th line contains one integer — the answer for the i -th query. examples input copy 6 4 1 2 2 1 3 4 1 1 4 5 2 3 3 3 3 6 1 2 6 6 6 6 output copy 6 6 0 6 input copy 10 5 10 2 8 10 9 8 2 1 1 8 1 1 10 10 2 2 3 3 6 6 6 6 1 1 4 5 4 8 4 8 output copy 4 2 6 4 80 note in the first example: in the first query, the answer is g(1,4)+g(1,5)=3+3=6 . x=1,2,3 can satisfies {ap:1≤p≤4}⊆{aq:x≤q≤4} , 3 is the largest integer so g(1,4)=3 . in the second query, the answer is g(2,3)+g(3,3)=3+3=6 . in the third query, the answer is 0 , because all i>j and g(i,j)=0 . in the fourth query, the answer is g(6,6)=6 . in the second example: in the second query, the answer is g(2,3)=2 . in the fourth query, the answer is g(1,4)+g(1,5)=2+2=4 .
ksyusha and chinchilla time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output ksyusha has a pet chinchilla, a tree on n vertices and huge scissors. a tree is a connected graph without cycles. during a boring physics lesson ksyusha thought about how to entertain her pet. chinchillas like to play with branches. a branch is a tree of 3 vertices. the branch looks like this. a cut is the removal of some (not yet cut) edge in the tree. ksyusha has plenty of free time, so she can afford to make enough cuts so that the tree splits into branches. in other words, after several (possibly zero) cuts, each vertex must belong to exactly one branch. help ksyusha choose the edges to be cut or tell that it is impossible. input the first line contains a single integer t ( 1≤t≤104 ) — number of testcases. the first line of each testcase contains a single integer n ( 2≤n≤2⋅105 ) — the number of vertices in the tree. the next n−1 rows of each testcase contain integers vi and ui ( 1≤vi,ui≤n ) — the numbers of vertices that the i -th edge connects. it is guaranteed that this set of edges forms a tree. it is also guaranteed that the sum of n over all testcases does not exceed 2⋅105 . output print the answer for each testcase. if the desired way to cut the tree does not exist, print −1 . otherwise, print an integer k — the number of edges to be cut. in the next line, print k different integers ei ( 1≤ei<n ) — numbers of the edges to be cut. if k=0 , print an empty string instead. if there are several solutions, you can print any. examples input copy 4 9 1 2 4 3 7 9 5 4 4 6 3 2 8 7 1 7 6 1 2 1 3 4 3 1 5 6 1 6 1 2 3 2 3 4 4 5 6 5 5 1 3 5 3 5 2 3 4 output copy 2 2 8 -1 1 3 -1 input copy 4 2 1 2 3 1 2 3 1 6 1 2 3 1 3 4 3 5 6 1 9 2 6 6 9 9 1 9 7 1 8 7 3 8 5 4 7 output copy -1 0 1 2 2 4 3 note the first testcase in first test.
luotianyi and xor-tree time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output luotianyi gives you a tree with values in its vertices, and the root of the tree is vertex 1 . in one operation, you can change the value in one vertex to any non-negative integer. now you need to find the minimum number of operations you need to perform to make each path from the root to leaf † has a bitwise xor value of zero. † a leaf in a rooted tree is a vertex that has exactly one neighbor and is not a root. input the first line contains a single integer n ( 2≤n≤105 ) — the number of vertices in the tree. the second line contains n integers a1,a2,…,an ( 1≤ai≤109 ), the i -th number represents the value in the i -th vertex. next n−1 lines describe the edges of the tree. the i -th line contains two integers ui and vi ( 1≤ui,vi≤n,ui≠vi ) — the vertices connected by an edge of the tree. it's guaranteed that the given edges form a tree. output print a single integer — the minimum number of operations. examples input copy 6 3 5 7 5 8 4 1 2 1 3 1 4 3 5 4 6 output copy 3 input copy 8 7 10 7 16 19 9 16 11 1 5 4 2 6 5 5 2 7 2 2 3 3 8 output copy 3 input copy 4 1 2 1 2 1 2 2 3 4 3 output copy 0 input copy 9 4 3 6 1 5 5 5 2 7 1 2 2 3 4 1 4 5 4 6 4 7 8 1 8 9 output copy 2 note the tree in the first example: if we change the value in the vertex 2 to 3 , the value in the vertex 5 to 4 , and the value in the vertex 6 to 6 , then the tree will be ok. the bitwise xor from the root to the leaf 2 will be 3⊕3=0 . the bitwise xor from the root to the leaf 5 will be 4⊕7⊕3=0 . the bitwise xor from the root to the leaf 6 will be 6⊕5⊕3=0 . the tree in the second example: if we change the value in the vertex 2 to 4 , the value in the vertex 3 to 27 , and the value in the vertex 6 to 20 , then the tree will be ok. the bitwise xor from the root to the leaf 6 will be 20⊕19⊕7=0 . the bitwise xor from the root to the leaf 8 will be 11⊕27⊕4⊕19⊕7=0 . the bitwise xor from the root to the leaf 4 will be 16⊕4⊕19⊕7=0 . the bitwise xor from the root to the leaf 7 will be 16⊕4⊕19⊕7=0 . in the third example, the only leaf is the vertex 4 and the bitwise xor on the path to it is 1⊕2⊕1⊕2=0 , so we don't need to change values. in the fourth example, we can change the value in the vertex 1 to 5 , and the value in the vertex 4 to 0 . here ⊕ denotes the bitwise xor operation.
the boss can count pairs time limit per test4 seconds memory limit per test512 megabytes inputstandard input outputstandard output you are given two arrays a and b , both of length n . your task is to count the number of pairs of integers (i,j) such that 1≤i<j≤n and ai⋅aj=bi+bj . input each test contains multiple test cases. the first line of input contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of test cases follows. the first line of each test case contains a single integer n ( 2≤n≤2⋅105 ) — the length of the arrays. the second line of each test case contains n integers a1,a2,…,an ( 1≤ai≤n ) — the elements of array a . the third line of each test case contains n integers b1,b2,…,bn ( 1≤bi≤n ) — the elements of array b . it is guaranteed that the sum of n across all test cases does not exceed 2⋅105 . output for each test case, output the number of good pairs. example input copy 3 3 2 3 2 3 3 1 8 4 2 8 2 1 2 7 5 3 5 8 8 1 1 6 5 8 4 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 output copy 2 7 1 note in the first sample, there are 2 good pairs: (1,2) , (1,3) . in the second sample, there are 7 good pairs: (1,2) , (1,5) , (2,8) , (3,4) , (4,7) , (5,6) , (5,7) .
twin permutations time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given a permutation † a of length n . find any permutation b of length n such that a1+b1≤a2+b2≤a3+b3≤…≤an+bn . it can be proven that a permutation b that satisfies the condition above always exists. † a permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. for example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation ( 2 appears twice in the array), and [1,3,4] is also not a permutation ( n=3 but there is 4 in the array). input each test contains multiple test cases. the first line of input contains a single integer t ( 1≤t≤2000 ) — the number of test cases. the description of test cases follows. the first line of each test case contains a single integer n ( 1≤n≤100 ) — the length of permutations a and b . the second line of each test case contains n distinct integers a1,a2,…,an ( 1≤ai≤n ) — the elements of permutation a . all elements of a are distinct. note that there is no bound on the sum of n over all test cases. output for each test case, output any permutation b which satisfies the constraints mentioned in the statement. it can be proven that a permutation b that satisfies the condition above always exists. example input copy 5 5 1 2 4 5 3 2 1 2 1 1 3 3 2 1 4 1 4 3 2 output copy 1 2 4 3 5 2 1 1 1 2 3 1 2 3 4 note in the first test case a=[1,2,4,5,3] . then the permutation b=[1,2,4,3,5] satisfies the condition because 1+1≤2+2≤4+4≤5+3≤3+5 .
love story time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output timur loves codeforces. that's why he has a string s having length 10 made containing only lowercase latin letters. timur wants to know how many indices string s differs from the string "codeforces". for example string s= "coolforsez" differs from "codeforces" in 4 indices, shown in bold. help timur by finding the number of indices where string s differs from "codeforces". note that you can't reorder the characters in the string s . input the first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. each test case is one line and contains the string s , consisting of exactly 10 lowercase latin characters. output for each test case, output a single integer — the number of indices where string s differs. example input copy 5 coolforsez cadafurcie codeforces paiuforces forcescode output copy 4 5 0 4 9
luotianyi and the palindrome string time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output luotianyi gives you a palindrome † string s , and she wants you to find out the length of the longest non-empty subsequence ‡ of s which is not a palindrome string. if there is no such subsequence, output −1 instead. † a palindrome is a string that reads the same backward as forward. for example, strings "z", "aaa", "aba", "abccba" are palindromes, but strings "codeforces", "reality", "ab" are not. ‡ a string a is a subsequence of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from b . for example, strings "a", "aaa", "bab" are subsequences of string "abaab", but strings "codeforces", "bbb", "h" are not. input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. the description of test cases follows. the first and the only line of each test case contains a single string s ( 1≤|s|≤50 ) consisting of lowercase english letters — the string that luotianyi gives you. it's guaranteed that s is a palindrome string. output for each test case, output a single integer — the length of the longest non-empty subsequence which is not a palindrome string. if there is no such subsequence, output −1 . example input copy 4 abacaba aaa codeforcesecrofedoc lol output copy 6 -1 18 2 note in the first test case, "abcaba" is a subsequence of "abacaba" as we can delete the third letter of "abacaba" to get "abcaba", and "abcaba" is not a palindrome string. we can prove that "abcaba" is an example of the longest subsequences of "abacaba" that isn't palindrome, so that the answer is 6 . in the second test case, we can only get "a" and "aa", but they are all palindrome strings, so the answer is −1 .
grasshopper on a line time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are given two integers x and k . grasshopper starts in a point 0 on an ox axis. in one move, it can jump some integer distance, that is not divisible by k , to the left or to the right. what's the smallest number of moves it takes the grasshopper to reach point x ? what are these moves? if there are multiple answers, print any of them. input the first line contains a single integer t ( 1≤t≤1000 ) — the number of testcases. the only line of each testcase contains two integers x and k ( 1≤x≤100 ; 2≤k≤100 ) — the endpoint and the constraint on the jumps, respectively. output for each testcase, in the first line, print a single integer n — the smallest number of moves it takes the grasshopper to reach point x . in the second line, print n integers, each of them not divisible by k . a positive integer would mean jumping to the right, a negative integer would mean jumping to the left. the endpoint after the jumps should be exactly x . each jump distance should be from −109 to 109 . in can be shown that, for any solution with the smallest number of jumps, there exists a solution with the same number of jumps such that each jump is from −109 to 109 . it can be shown that the answer always exists under the given constraints. if there are multiple answers, print any of them. example input copy 3 10 2 10 3 3 4 output copy 2 7 3 1 10 1 3
bosco and particle time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output bosco is studying the behaviour of particles. he decided to investigate on the peculiar behaviour of the so-called "four-one-two" particle. he does the following: there is a line of length n+1 , where the topmost point is position 0 and bottommost is position n+1 . the particle is initially (at time t=0 ) at position 0 and heading downwards. the particle moves at the speed of 1 unit per second. there are n oscillators at positions 1,2,…,n . each oscillator can be described by a binary string. the initial state of each oscillator is the first character of its binary string. when the particle hits with an oscillator, the particle reverses its direction if its current state is 1 and continues to move at the same direction if its current state is 0 , and that oscillator moves on to the next state (the next state of the last state is defined as the first state). additionally, the particle always reverses its direction when it is at position 0 or n+1 at time t>0 . bosco would like to know the cycle length of the movement of particle. the cycle length is defined as the minimum value of c such that for any time t≥0 , the position of the particle at time t is same as the position of the particle at time t+c . it can be proved that such value c always exists. as he realises the answer might be too large, he asks you to output your answer modulo 998244353 . input the first line contains an integer n ( 1≤n≤106 ) — the number of oscillators. the i -th of the next n line contains a binary string si ( 1≤|si|≤106 ) — the binary string, that contains only characters 0 and 1 , describing the oscillator at position i . it is guaranteed that the sum of all |si| does not exceed 106 . output output a single integer integer — the cycle length of the movement of the particle, modulo 998244353 . examples input copy 1 00 output copy 4 input copy 2 01 010 output copy 16 input copy 4 0101 000 1 01 output copy 12 input copy 4 01010 0001 11 0001 output copy 120 note in the first sample, the only oscillator at position 1 always has state 0 . at time moments 0,1,2,3 positions the particle are 0,1,2,1 respectively. then the same positions will be repeated, so c=4 . animation for the second sample: here or a smoother animation.
luotianyi and the table time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output luotianyi gave an array b of n⋅m integers. she asks you to construct a table a of size n×m , filled with these n⋅m numbers, and each element of the array must be used exactly once. also she asked you to maximize the following value: n ∑ i=1 m ∑ j=1 ( max 1≤x≤i,1≤y≤j ax,y− min 1≤x≤i,1≤y≤j ax,y) this means that we consider n⋅m subtables with the upper left corner in (1,1) and the bottom right corner in (i, j) ( 1 \le i \le n , 1 \le j \le m ), for each such subtable calculate the difference of the maximum and minimum elements in it, then sum up all these differences. you should maximize the resulting sum. help her find the maximal possible value, you don't need to reconstruct the table itself. input each test consists of multiple test cases. the first line contains a single integer t ( 1 \le t \le 200 ) — the number of test cases. the description of test cases follows. the first line of each test case contains two integers n and m ( 2 \le n, m \le 100 ) — the number of rows and columns of the table. the second line of each test case contains n \cdot m integers b_1, b_2, \ldots, b_{n\cdot m} ( -10^5 \le b_{i} \le 10^5 ) — the numbers you can put in the table. note, that integers in the array b can be negative. it is guaranteed that the sum of n \cdot m over all test cases doesn't exceed 2\cdot 10^5 . output for each test case, output a single integer — the maximal value, that can be obtained. example input copy 5 2 2 1 3 1 4 2 2 -1 -1 -1 -1 2 3 7 8 9 -3 10 8 3 2 4 8 -3 0 -7 1 4 3 -32030 59554 16854 -85927 68060 -64460 -79547 90932 85063 82703 -12001 38762 output copy 9 0 64 71 1933711 note in the first test case, the table is follows: 4 1 1 3 in the subtable with the bottom right corner in (1, 1) , the difference of the maximal and minimal elements is 4 - 4 = 0 . in the subtable with the bottom right corner in (1, 2) , the difference of the maximal and minimal elements is 4 - 1 = 3 . in the subtable with the bottom right corner in (2, 1) , the difference of the maximal and minimal elements is 4 - 1 = 3 . in the subtable with the bottom right corner in (2, 2) , the difference of the maximal and minimal elements is 4 - 1 = 3 . then the maximum possible value is 0+3+3+3=9 . in the second test case, all elements are equal, so all differences are 0 , and the answer is 0 .
range sorting (easy version) time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output the only difference between this problem and the hard version is the constraints on t and n . you are given an array a , consisting of n distinct integers a1,a2,…,an . define the beauty of an array p1,p2,…pk as the minimum amount of time needed to sort this array using an arbitrary number of range-sort operations. in each range-sort operation, you will do the following: choose two integers l and r ( 1≤l<r≤k ). sort the subarray pl,pl+1,…,pr in r−l seconds. please calculate the sum of beauty over all subarrays of array a . a subarray of an array is defined as a sequence of consecutive elements of the array. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤5⋅103 ). the description of the test cases follows. the first line of each test case contains a single integer n ( 1≤n≤5⋅103 ) — the length of the array a . the second line of each test case consists of n integers a1,a2,…,an ( 1≤ai≤109 ). it is guaranteed that all elements of a are pairwise distinct. it is guaranteed that the sum of n over all test cases does not exceed 5⋅103 . output for each test case, output the sum of beauty over all subarrays of array a . example input copy 5 2 6 4 3 3 10 6 4 4 8 7 2 5 9 8 2 4 6 12 2 6 13 3 15 5 10 8 16 9 11 18 output copy 1 2 8 16 232 note in the first test case: the subarray [6] is already sorted, so its beauty is 0 . the subarray [4] is already sorted, so its beauty is 0 . you can sort the subarray [6,4] in one operation by choosing l=1 and r=2 . its beauty is equal to 1 . the sum of beauty over all subarrays of the given array is equal to 0+0+1=1 . in the second test case: the subarray [3] is already sorted, so its beauty is 0 . the subarray [10] is already sorted, so its beauty is 0 . the subarray [6] is already sorted, so its beauty is 0 . the subarray [3,10] is already sorted, so its beauty is 0 . you can sort the subarray [10,6] in one operation by choosing l=1 and r=2 . its beauty is equal to 2−1=1 . you can sort the subarray [3,10,6] in one operation by choosing l=2 and r=3 . its beauty is equal to 3−2=1 . the sum of beauty over all subarrays of the given array is equal to 0+0+0+0+1+1=2 .
luotianyi and cartridge time limit per test3 seconds memory limit per test1024 megabytes inputstandard input outputstandard output luotianyi is watching the anime made in abyss. she finds that making a cartridge is interesting. to describe the process of making a cartridge more clearly, she abstracts the original problem and gives you the following problem. you are given a tree t consisting of n vertices. each vertex has values ai and bi and each edge has values cj and dj . now you are aim to build a tree t′ as follows: first, select p vertices from t ( p is a number chosen by yourself) as the vertex set s′ of t′ . next, select p−1 edges from t one by one (you cannot select one edge more than once). may you have chosen the j -th edge connects vertices xj and yj with values (cj,dj) , then you can choose two vertices u and v in s′ that satisfy the edge (xj,yj) is contained in the simple path from u to v in t , and link u and v in t′ by the edge with values (cj,dj) ( u and v shouldn't be contained in one connected component before in t′ ). a tree with three vertices, min(a,c)=1,b+d=7 , the cost is 7 . selected vertices 2 and 3 as s′ , used the edge (1,2) with cj=2 and dj=1 to link this vertices, now min(a,c)=2,b+d=4 , the cost is 8 . let a be the minimum of values ai in t′ and c be the minimum of values ci in t′ . let b be the sum of bi in t′ and d be the sum of values di in t′ . let min(a,c)⋅(b+d) be the cost of t′ . you need to find the maximum possible cost of t′ . input the first line contains one integer n ( 3≤n≤2⋅105 ) — the number of vertices in the tree t . the second line contains n integers a1,a2,…,an ( 1≤ai≤2⋅105 ), where the i -th integer represents the ai value of the i -th vertex. the third line contains n integers b1,b2,…,bn ( 1≤bi≤2⋅105 ), where the i -th integer represents the bi value of the i -th vertex. then n−1 lines follow, the j -th of them contains four integers xj,yj,cj,dj ( 1≤xj,yj≤n,1≤cj,dj≤2⋅105 ) representing the edge (xj,yj) and its values cj and dj respectively. it's guaranteed that edges form a tree. output print a single integer — the maximum possible cost of t′ . examples input copy 3 1 2 2 1 1 2 1 2 2 1 1 3 1 2 output copy 8 input copy 5 2 4 2 1 1 2 4 4 4 4 2 5 3 3 3 5 2 4 4 2 5 5 5 1 1 5 output copy 35 input copy 6 5 7 10 7 9 4 6 9 7 9 8 5 2 1 5 1 3 2 2 4 4 3 6 3 5 1 7 4 6 5 6 8 output copy 216 input copy 5 1000 1000 1 1000 1000 1000 1000 1 1000 1000 1 2 1 1 2 3 1000 1000 3 4 1000 1000 3 5 1000 1000 output copy 7000000 note the tree from the first example is shown in the statement. the tree from the second example is shown below: a=1,b=18,c=1,d=17 , so the cost is min(1,1)⋅(18+17)=35 .
zombies time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output polycarp plays a computer game in a post-apocalyptic setting. the zombies have taken over the world, and polycarp with a small team of survivors is defending against hordes trying to invade their base. the zombies are invading for x minutes starting from minute 0 . there are n entrances to the base, and every minute one zombie attempts to enter through every entrance. the survivors can defend the entrances against the zombies. there are two options: manually — shoot the zombies coming through a certain entrance; automatically — set up an electric fence on a certain entrance to fry the zombies. if an entrance is defended either or both ways during some minute, no zombie goes through. every entrance is defended by a single dedicated survivor. the i -th entrance is defended manually from minute li until minute ri , non-inclusive — [li,ri) . there are k generators that can be used to defend the entrances automatically. every entrance should be connected to exactly one generator, but a generator can be connected to multiple entrances (or even none of them). each generator will work for exactly m consecutive minutes. polycarp can choose when to power on each generator independently of each other, the m minute long interval should be fully inside the [0,x) time interval. polycarp is a weird gamer. he wants the game to be as difficult as possible for him. so he wants to connect each entrance to a generator and choose the time for each generator in such a way that as many zombies as possible enter the base. please, help him to achieve that! input the first line contains four integers n,k,x and m ( 1≤k≤n≤2000 ; 1≤m≤x≤109 ) — the number of entrances, the number of generators, the duration of the zombie invasion and the duration of all generators. the i -th of the next n lines contains two integers li and ri ( 0≤li<ri≤x ) — the time interval the i -th entrance is defended manually. output print a single integer — the largest number of zombies that can enter the base after polycarp connects each entrance to some generator and chooses the time for each generator. examples input copy 3 3 10 3 0 2 1 7 4 7 output copy 18 input copy 3 2 10 3 0 2 1 7 4 7 output copy 18 input copy 3 1 10 3 0 2 1 7 4 7 output copy 16 input copy 2 1 20 6 11 13 2 14 output copy 22 input copy 5 3 7 4 4 6 0 3 4 7 1 5 2 7 output copy 14 input copy 6 3 9 4 3 9 4 9 2 5 0 5 6 9 2 3 output copy 26
random walk time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are given a tree consisting of n vertices and n−1 edges, and each vertex v has a counter c(v) assigned to it. initially, there is a chip placed at vertex s and all counters, except c(s) , are set to 0 ; c(s) is set to 1 . your goal is to place the chip at vertex t . you can achieve it by a series of moves. suppose right now the chip is placed at the vertex v . in one move, you do the following: choose one of neighbors to of vertex v uniformly at random ( to is neighbor of v if and only if there is an edge {v,to} in the tree); move the chip to vertex to and increase c(to) by 1 ; you'll repeat the move above until you reach the vertex t . for each vertex v calculate the expected value of c(v) modulo 998244353 . input the first line contains three integers n , s and t ( 2≤n≤2⋅105 ; 1≤s,t≤n ; s≠t ) — number of vertices in the tree and the starting and finishing vertices. next n−1 lines contain edges of the tree: one edge per line. the i -th line contains two integers ui and vi ( 1≤ui,vi≤n ; ui≠vi ), denoting the edge between the nodes ui and vi . it's guaranteed that the given edges form a tree. output print n numbers: expected values of c(v) modulo 998244353 for each v from 1 to n . formally, let m=998244353 . it can be shown that the answer can be expressed as an irreducible fraction p q , where p and q are integers and q≢0(modm) . output the integer equal to p⋅q−1modm . in other words, output such an integer x that 0≤x<m and x⋅q≡p(modm) . examples input copy 3 1 3 1 2 2 3 output copy 2 2 1 input copy 4 1 3 1 2 2 3 1 4 output copy 4 2 1 2 input copy 8 2 6 6 4 6 2 5 4 3 1 2 3 7 4 8 2 output copy 1 3 2 0 0 1 0 1 note the tree from the first example is shown below: let's calculate expected value e[c(1)] : p(c(1)=0)=0 , since c(1) is set to 1 from the start. p(c(1)=1)= 1 2 , since there is the only one series of moves that leads c(1)=1 . it's 1→2→3 with probability 1⋅ 1 2 . p(c(1)=2)= 1 4 : the only path is 1→12→0.51→12→0.53 . p(c(1)=3)= 1 8 : the only path is 1→12→0.51→12→0.51→12→0.53 . p(c(1)=i)= 1 2i in general case. as a result, e[c(1)]= ∞ ∑ i=1 i 1 2i =2 . image of tree in second test image of tree in third test
almost increasing subsequence time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output a sequence is almost-increasing if it does not contain three consecutive elements x,y,z such that x≥y≥z . you are given an array a1,a2,…,an and q queries. each query consists of two integers 1≤l≤r≤n . for each query, find the length of the longest almost-increasing subsequence of the subarray al,al+1,…,ar . a subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements. input the first line of input contains two integers, n and q ( 1≤n,q≤200000 ) — the length of the array a and the number of queries. the second line contains n integers a1,a2,…,an ( 1≤ai≤109 ) — the values of the array a . each of the next q lines contains the description of a query. each line contains two integers l and r ( 1≤l≤r≤n ) — the query is about the subarray al,al+1,…,ar . output for each of the q queries, print a line containing the length of the longest almost-increasing subsequence of the subarray al,al+1,…,ar . example input copy 9 8 1 2 4 3 3 5 6 2 1 1 3 1 4 2 5 6 6 3 7 7 8 1 8 8 8 output copy 3 4 3 1 4 2 7 1 note in the first query, the subarray is a1,a2,a3=[1,2,4] . the whole subarray is almost-increasing, so the answer is 3 . in the second query, the subarray is a1,a2,a3,a4=[1,2,4,3] . the whole subarray is a almost-increasing, because there are no three consecutive elements such that x≥y≥z . so the answer is 4 . in the third query, the subarray is a2,a3,a4,a5=[2,4,3,3] . the whole subarray is not almost-increasing, because the last three elements satisfy 4≥3≥3 . an almost-increasing subsequence of length 3 can be found (for example taking a2,a3,a5=[2,4,3] ). so the answer is 3 .
vlad building beautiful array time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output vlad was given an array a of n positive integers. now he wants to build a beautiful array b of length n from it. vlad considers an array beautiful if all the numbers in it are positive and have the same parity. that is, all numbers in the beautiful array are greater than zero and are either all even or all odd. to build the array b , vlad can assign each bi either the value ai or ai−aj , where any j from 1 to n can be chosen. to avoid trying to do the impossible, vlad asks you to determine whether it is possible to build a beautiful array b of length n using his array a . input the first line of input contains an integer t ( 1≤t≤104 ) — the number of test cases. then follow the descriptions of the test cases. the first line of each case contains a single integer n ( 1≤n≤2⋅105 ) — the length of the array a . the second line of each case contains n positive integers a1,a2,…,an ( 1≤ai≤109 ) — the elements of the array a . it is guaranteed that the sum of n over all cases does not exceed 2⋅105 . output output t strings, each of which is the answer to the corresponding test case. as the answer, output "yes" if vlad can build a beautiful array b , and "no" otherwise. you can output the answer in any case (for example, the strings "yes", "yes", "yes" and "yes" will be recognized as a positive answer). example input copy 7 5 2 6 8 4 3 5 1 4 7 6 9 4 2 6 4 10 7 5 29 13 9 10000001 11 3 5 2 1 2 4 2 5 2 4 5 4 3 4 2 5 5 4 output copy no yes yes yes yes no no
a-characteristic time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output consider an array a1,a2,…,an consisting of numbers 1 and −1 . define a -characteristic of this array as a number of pairs of indices 1≤i<j≤n , such that ai⋅aj=1 . find any array a with given length n with a -characteristic equal to the given value k . input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤100 ). the description of the test cases follows. the only line of each test case contains two integers n and k ( 2≤n≤100 ; 0≤k≤ (n−1)n 2 ) — the length of required array and required a -characteristic. output for each test case, if there is no array a with given a -characteristic k , print no. otherwise, print yes and n numbers 1 and −1 , which form the required array a . if there are multiple answers, print any of them. example input copy 7 2 0 2 1 3 1 3 2 3 3 5 4 5 5 output copy yes 1 -1 yes 1 1 yes 1 -1 1 no yes 1 1 1 yes -1 1 -1 1 1 no note in the first test case, there is only one pair of different elements in the array, and their product is a1⋅a2=−1≠1 , hence its a -characteristic is 0 . in the second test case, there is only one pair of different elements in the array, and their product is a1⋅a2=1 , hence its a -characteristic is 1 . in the third test case, there are three pairs of different elements in the array, and their product are: a1⋅a2=−1 , a1⋅a3=1 , a2⋅a3=−1 , hence its a -characteristic is 1 . in the fourth test case, we can show, that there is no array with length 3 , which a -characteristic is 2 .
copil copac draws trees time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output copil copac is given a list of n−1 edges describing a tree of n vertices. he decides to draw it using the following algorithm: step 0 : draws the first vertex (vertex 1 ). go to step 1 . step 1 : for every edge in the input, in order: if the edge connects an already drawn vertex u to an undrawn vertex v , he will draw the undrawn vertex v and the edge. after checking every edge, go to step 2 . step 2 : if all the vertices are drawn, terminate the algorithm. else, go to step 1 . the number of readings is defined as the number of times copil copac performs step 1 . find the number of readings needed by copil copac to draw the tree. input each test contains multiple test cases. the first line of input contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of test cases follows. the first line of each test case contains a single integer n ( 2≤n≤2⋅105 ) — the number of vertices of the tree. the following n−1 lines of each test case contain two integers ui and vi ( 1≤ui,vi≤n , ui≠vi ) — indicating that (ui,vi) is the i -th edge in the list. it is guaranteed that the given edges form a tree. it is guaranteed that the sum of n over all test cases does not exceed 2⋅105 . output for each test case, output the number of readings copil copac needs to draw the tree. example input copy 2 6 4 5 1 3 1 2 3 4 1 6 7 5 6 2 4 2 7 1 3 1 2 4 5 output copy 2 3 note in the first test case: after the first reading, the tree will look like this: after the second reading: therefore, copil copac needs 2 readings to draw the tree.
playoff fixing time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output 2k teams participate in a playoff tournament. the teams are numbered from 1 to 2k , in order of decreasing strength. so, team 1 is the strongest one, team 2k is the weakest one. a team with a smaller number always defeats a team with a larger number. first of all, the teams are arranged in some order during a procedure called seeding. each team is assigned another unique value from 1 to 2k , called a seed, that represents its starting position in the playoff. the tournament consists of 2k−1 games. they are held as follows: the teams are split into pairs: team with seed 1 plays against team with seed 2 , team with seed 3 plays against team with seed 4 (exactly in this order), and so on (so, 2k−1 games are played in that phase). when a team loses a game, it is eliminated. after that, only 2k−1 teams remain. if only one team remains, it is declared the champion; otherwise, 2k−2 games are played: in the first one of them, the winner of the game "seed 1 vs seed 2 " plays against the winner of the game "seed 3 vs seed 4 ", then the winner of the game "seed 5 vs seed 6 " plays against the winner of the game "seed 7 vs seed 8 ", and so on. this process repeats until only one team remains. after the tournament ends, the teams are assigned places according to the tournament phase when they were eliminated. in particular: the winner of the tournament gets place 1 ; the team eliminated in the finals gets place 2 ; both teams eliminated in the semifinals get place 3 ; all teams eliminated in the quarterfinals get place 5 ; all teams eliminated in the 1/8 finals get place 9 , and so on. now that we established the rules, we do a little rigging. in particular, we want: team 1 (not team with seed 1 ) to take place 1 ; team 2 to take place 2 ; teams 3 and 4 to take place 3 ; teams from 5 to 8 to take place 5 , and so on. for example, this picture describes one of the possible ways the tournament can go with k=3 , and the resulting places of the teams: some seeds are already reserved for some teams (we are not the only ones rigging the tournament, apparently). we have to fill the rest of the seeds with the remaining teams to achieve the desired placements. how many ways are there to do that? since that value might be large, print it modulo 998244353 . input the first line contains a single integer k ( 0≤k≤19 ) — there are 2k teams. the second line contains 2k integers a1,a2,…,a2k ( ai=−1 or 1≤ai≤2k ). if ai≠−1 , then team ai has seed i . otherwise, the seed i is not reserved for any team. all values, that are not −1 , are distinct. output print a single integer — the number of ways to fill the non-reserved seeds so that the tournament goes as planned, modulo 998244353 . examples input copy 2 1 2 3 4 output copy 0 input copy 2 1 3 4 2 output copy 1 input copy 1 -1 -1 output copy 2 input copy 2 -1 -1 -1 -1 output copy 16 input copy 3 -1 -1 -1 -1 2 -1 -1 -1 output copy 768 input copy 0 1 output copy 1
round dance time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output n people came to the festival and decided to dance a few round dances. there are at least 2 people in the round dance and each person has exactly two neighbors. if there are 2 people in the round dance then they have the same neighbor on each side. you decided to find out exactly how many dances there were. but each participant of the holiday remembered exactly one neighbor. your task is to determine what the minimum and maximum number of round dances could be. for example, if there were 6 people at the holiday, and the numbers of the neighbors they remembered are equal [2,1,4,3,6,5] , then the minimum number of round dances is 1 : 1−2−3−4−5−6−1 and the maximum is 3 : 1−2−1 3−4−3 5−6−5 input the first line contains a positive number t ( 1≤t≤104 ) — the number of test cases. the following is a description of the test cases. the first line of the description of each test case contains a positive number n ( 2≤n≤2⋅105 ) — the number of people at the holiday. the second line of the description of each test case contains n integers ai ( 1≤ai≤n,ai≠i ) — the number of the neighbor that the i th person remembered. it is guaranteed that the test cases are correct and corresponds to at least one division of people into round dances. it is guaranteed that the sum of n for all test cases does not exceed 2⋅105 . output for each test case, output two integers — the minimum and maximum number of round dances that could be. example input copy 10 6 2 1 4 3 6 5 6 2 3 1 5 6 4 9 2 3 2 5 6 5 8 9 8 2 2 1 4 4 3 2 1 5 2 3 4 5 1 6 5 3 4 1 1 2 5 3 5 4 1 2 6 6 3 2 5 4 3 6 5 1 4 3 4 2 output copy 1 3 2 2 1 3 1 1 1 2 1 1 1 1 2 2 1 2 1 1
combinatorics problem time limit per test4 seconds memory limit per test1024 megabytes inputstandard input outputstandard output recall that the binomial coefficient ( x y ) is calculated as follows ( x and y are non-negative integers): if x<y , then ( x y )=0 ; otherwise, ( x y )= x! y!⋅(x−y)! . you are given an array a1,a2,…,an and an integer k . you have to calculate a new array b1,b2,…,bn , where b1=(( 1 k )⋅a1)mod998244353 ; b2=(( 2 k )⋅a1+( 1 k )⋅a2)mod998244353 ; b_3 = (\binom{3}{k} \cdot a_1 + \binom{2}{k} \cdot a_2 + \binom{1}{k} \cdot a_3) \bmod 998244353 , and so on. formally, b_i = (\sum\limits_{j=1}^{i} \binom{i - j + 1}{k} \cdot a_j) \bmod 998244353 . note that the array is given in a modified way, and you have to output it in a modified way as well. input the only line of the input contains six integers n , a_1 , x , y , m and k ( 1 \le n \le 10^7 ; 0 \le a_1, x, y < m ; 2 \le m \le 998244353 ; 1 \le k \le 5 ). the array [a_1, a_2, \dots, a_n] is generated as follows: a_1 is given in the input; for 2 \le i \le n , a_i = (a_{i-1} \cdot x + y) \bmod m . output since outputting up to 10^7 integers might be too slow, you have to do the following: let c_i = b_i \cdot i (without taking modulo 998244353 after the multiplication). print the integer c_1 \oplus c_2 \oplus \dots \oplus c_n , where \oplus denotes the bitwise xor operator. example input copy 5 8 2 3 100 2 output copy 1283
sort the subarray time limit per test2 seconds memory limit per test512 megabytes inputstandard input outputstandard output monocarp had an array a consisting of n integers. he has decided to choose two integers l and r such that 1≤l≤r≤n , and then sort the subarray a[l..r] (the subarray a[l..r] is the part of the array a containing the elements al,al+1,al+2,…,ar−1,ar ) in non-descending order. after sorting the subarray, monocarp has obtained a new array, which we denote as a′ . for example, if a=[6,7,3,4,4,6,5] , and monocarp has chosen l=2,r=5 , then a′=[6,3,4,4,7,6,5] . you are given the arrays a and a′ . find the integers l and r that monocarp could have chosen. if there are multiple pairs of values (l,r) , find the one which corresponds to the longest subarray. input the first line contains one integer t ( 1≤t≤104 ) — the number of test cases. each test case consists of three lines: the first line contains one integer n ( 2≤n≤2⋅105 ); the second line contains n integers a1,a2,…,an ( 1≤ai≤n ); the third line contains n integers a ′ 1 ,a ′ 2 ,…,a ′ n ( 1≤a ′ i ≤n ). additional constraints on the input: the sum of n over all test cases does not exceed 2⋅105 ; it is possible to obtain the array a′ by sorting one subarray of a ; a′≠a (there exists at least one position in which these two arrays are different). output for each test case, print two integers — the values of l and r ( 1≤l≤r≤n ). if there are multiple answers, print the values that correspond to the longest subarray. if there are still multiple answers, print any of them. example input copy 3 7 6 7 3 4 4 6 5 6 3 4 4 7 6 5 3 1 2 1 1 1 2 3 2 2 1 2 1 2 output copy 2 5 1 3 2 3
toy machine time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output there is a toy machine with toys arranged in two rows of n cells each ( n is odd). initial state for n=9 . initially, n−2 toys are placed in the non-corner cells of the top row. the bottom row is initially empty, and its leftmost, rightmost, and central cells are blocked. there are 4 buttons to control the toy machine: left, right, up, and down marked by the letters l, r, u, and d correspondingly. when pressing l, r, u, or d, all the toys will be moved simultaneously in the corresponding direction and will only stop if they push into another toy, the wall or a blocked cell. your goal is to move the k -th toy into the leftmost cell of the top row. the toys are numbered from 1 to n−2 from left to right. given n and k , find a solution that uses at most 1000000 button presses. to test out the toy machine, a web page is available that lets you play the game in real time. input the first and only line contains two integers, n and k ( 5≤n≤100000 , n is odd, 1≤k≤n−2 ) — the number of cells in a row, and the index of the toy that has to be moved to the leftmost cell of the top row. output on a single line, output a description of the button presses as a string of at most 1000000 characters. the string should only contain the characters l, r, u, and d. the i -th character in the string is the i -th button that is pressed. after all the button presses are performed, the k -th toy should be in the leftmost cell of the top row. if there are multiple solutions, print any. the number of button presses does not have to be minimized. examples input copy 5 1 output copy rdl input copy 7 2 output copy rdl note in the first example, there will be 5−2=3 toys. the first toy needs to end up in the leftmost cell of the top row. the moves rdl will achieve this, see the picture for a better understanding. another possible solution would be to do one button press l. visualization of the moves for the first example.
timber time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output there is a beautiful alley with trees in front of a shopping mall. unfortunately, it has to go to make space for the parking lot. the trees on the alley all grow in a single line. there are n spots for trees, index 0 is the shopping mall, index n+1 is the road and indices from 1 to n are the spots for trees. some of them are taken — there grow trees of the same height k . no more than one tree grows in each spot. when you chop down a tree in the spot x , you can make it fall either left or right. if it falls to the left, it takes up spots from x−k to x , inclusive. if it falls to the right, it takes up spots from x to x+k , inclusive. let m trees on the alley grow in some spots x1,x2,…,xm . let an alley be called unfortunate if all m trees can be chopped down in such a way that: no tree falls on the shopping mall or the road; each spot is taken up by no more than one fallen tree. calculate the number of different unfortunate alleys with m trees of height k . two alleys are considered different if there is a spot y such that a tree grows in y on the first alley and doesn't grow in y on the second alley. output the number modulo 998244353 . input the only line contains three integers n,m and k ( 1≤m,k≤n≤3⋅105 ) — the number of spots for the trees, the number of trees and the height of each tree. output print a single integer — the number of different unfortunate alleys with m trees of height k , modulo 998244353 . examples input copy 6 1 4 output copy 4 input copy 5 2 2 output copy 0 input copy 6 2 2 output copy 4 input copy 15 3 2 output copy 311
editorial for two time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output berland intercollegiate contest has just finished. monocarp and polycarp, as the jury, are going to conduct an editorial. unfortunately, the time is limited, since they have to finish before the closing ceremony. there were n problems in the contest. the problems are numbered from 1 to n . the editorial for the i -th problem takes ai minutes. monocarp and polycarp are going to conduct an editorial for exactly k of the problems. the editorial goes as follows. they have a full problemset of n problems before them, in order. they remove n−k problems without changing the order of the remaining k problems. then, monocarp takes some prefix of these k problems (possibly, an empty one or all problems). polycarp takes the remaining suffix of them. after that, they go to different rooms and conduct editorials for their problems in parallel. so, the editorial takes as much time as the longer of these two does. please, help monocarp and polycarp to choose the problems and the split in such a way that the editorial finishes as early as possible. print the duration of the editorial. input the first line contains a single integer t ( 1≤t≤104 ) — the number of testcases. the first line of each testcase contains two integers n and k ( 1≤k≤n≤3⋅105 ) — the number of problems in the full problemset and the number of problems monocarp and polycarp are going to conduct an editorial for. the second line contains n integers a1,a2,…,an ( 1≤ai≤109 ) — the time each editorial takes. the sum of n over all testcases doesn't exceed 3⋅105 . output for each testcase, print a single integer — the smallest amount of time the editorial takes, if monocarp and polycarp can choose which k of n problems to conduct an editorial for and how to split them among themselves. example input copy 6 5 4 1 10 1 1 1 5 3 1 20 5 15 3 5 3 1 20 3 15 5 10 6 10 8 20 14 3 8 6 4 16 11 10 5 9 9 2 13 15 19 4 9 13 12 1 1 1 output copy 2 6 5 21 18 1
ira and flamenco time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output ira loves spanish flamenco dance very much. she decided to start her own dance studio and found n students, i th of whom has level ai . ira can choose several of her students and set a dance with them. so she can set a huge number of dances, but she is only interested in magnificent dances. the dance is called magnificent if the following is true: exactly m students participate in the dance; levels of all dancers are pairwise distinct; levels of every two dancers have an absolute difference strictly less than m . for example, if m=3 and a=[4,2,2,3,6] , the following dances are magnificent (students participating in the dance are highlighted in red): [4,2,2,3,6] , [4,2,2,3,6] . at the same time dances [4,2,2,3,6] , [4,2,2,3,6] , [4,2,2,3,6] are not magnificent. in the dance [4,2,2,3,6] only 2 students participate, although m=3 . the dance [4,2,2,3,6] involves students with levels 2 and 2 , although levels of all dancers must be pairwise distinct. in the dance [4,2,2,3,6] students with levels 3 and 6 participate, but |3−6|=3 , although m=3 . help ira count the number of magnificent dances that she can set. since this number can be very large, count it modulo 109+7 . two dances are considered different if the sets of students participating in them are different. input the first line contains a single integer t ( 1≤t≤104 ) — number of testcases. the first line of each testcase contains integers n and m ( 1≤m≤n≤2⋅105 ) — the number of ira students and the number of dancers in the magnificent dance. the second line of each testcase contains n integers a1,a2,…,an ( 1≤ai≤109 ) — levels of students. it is guaranteed that the sum of n over all testcases does not exceed 2⋅105 . output for each testcase, print a single integer — the number of magnificent dances. since this number can be very large, print it modulo 109+7 . example input copy 9 7 4 8 10 10 9 6 11 7 5 3 4 2 2 3 6 8 2 1 5 2 2 3 1 3 3 3 3 3 3 3 5 1 3 4 3 10 7 12 3 5 2 1 1 4 3 5 5 5 2 7 5 1 1 1 3 2 1 2 3 2 2 1 2 output copy 5 2 10 0 5 11 1 2 1 note in the first testcase, ira can set such magnificent dances: [8,10,10,9,6,11,7] , [8,10,10,9,6,11,7] , [8,10,10,9,6,11,7] , [8,10,10,9,6,11,7] , [8,10,10,9,6,11,7] . the second testcase is explained in the statements.
comparison string time limit per test2 seconds memory limit per test512 megabytes inputstandard input outputstandard output you are given a string s of length n , where each character is either < or >. an array a consisting of n+1 elements is compatible with the string s if, for every i from 1 to n , the character si represents the result of comparing ai and ai+1 , i. e.: si is < if and only if ai<ai+1 ; si is > if and only if ai>ai+1 . for example, the array [1,2,5,4,2] is compatible with the string <<>>. there are other arrays with are compatible with that string, for example, [13,37,42,37,13] . the cost of the array is the number of different elements in it. for example, the cost of [1,2,5,4,2] is 4 ; the cost of [13,37,42,37,13] is 3 . you have to calculate the minimum cost among all arrays which are compatible with the given string s . input the first line contains one integer t ( 1≤t≤500 ) — the number of test cases. each test case consists of two lines: the first line contains one integer n ( 1≤n≤100 ); the second line contains the string s , consisting of n characters. each character of s is either < or >. output for each test case, print one integer — the minimum cost among all arrays which are compatible with the given string s . example input copy 4 4 <<>> 4 >><< 5 >>>>> 7 <><><>< output copy 3 3 6 2 note in the first test case of the example, the array can be [13,37,42,37,13] . in the second test case of the example, the array can be [42,37,13,37,42] .
lunatic never content time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output you have an array a of n non-negative integers. let's define f(a,x)=[a1modx,a2modx,…,anmodx] for some positive integer x . find the biggest x , such that f(a,x) is a palindrome. here, amodx is the remainder of the integer division of a by x . an array is a palindrome if it reads the same backward as forward. more formally, an array a of length n is a palindrome if for every i ( 1≤i≤n ) ai=an−i+1 . input the first line contains a single integer t ( 1≤t≤105 ) — the number of test cases. the first line of each test case contains a single integer n ( 1≤n≤105 ). the second line of each test case contains n integers ai ( 0≤ai≤109 ). it's guaranteed that the sum of all n does not exceed 105 . output for each test case output the biggest x , such that f(a,x) is a palindrome. if x can be infinitely large, output 0 instead. example input copy 4 2 1 2 8 3 0 1 2 0 3 2 1 1 0 3 100 1 1000000000 output copy 1 2 0 999999900 note in the first example, f(a,x=1)=[0,0] which is a palindrome. in the second example, f(a,x=2)=[1,0,1,0,0,1,0,1] which is a palindrome. it can be proven that in the first two examples, no larger x satisfies the condition. in the third example, f(a,x)=[0] for any x , so we can choose it infinitely large, so the answer is 0 .
don't blame me time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output sadly, the problem setter couldn't think of an interesting story, thus he just asks you to solve the following problem. given an array a consisting of n positive integers, count the number of non-empty subsequences for which the bitwise and of the elements in the subsequence has exactly k set bits in its binary representation. the answer may be large, so output it modulo 109+7 . recall that the subsequence of an array a is a sequence that can be obtained from a by removing some (possibly, zero) elements. for example, [1,2,3] , [3] , [1,3] are subsequences of [1,2,3] , but [3,2] and [4,5,6] are not. note that and represents the bitwise and operation. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case consists of two integers n and k ( 1≤n≤2⋅105 , 0≤k≤6 ) — the length of the array and the number of set bits that the bitwise and the counted subsequences should have in their binary representation. the second line of each test case consists of n integers ai ( 0≤ai≤63 ) — the array a . it is guaranteed that the sum of n over all test cases doesn't exceed 2⋅105 . output for each test case, output a single integer — the number of subsequences that have exactly k set bits in their bitwise and value's binary representation. the answer may be large, so output it modulo 109+7 . example input copy 6 5 1 1 1 1 1 1 4 0 0 1 2 3 5 1 5 5 7 4 2 1 2 3 12 0 0 2 0 2 0 2 0 2 0 2 0 2 10 6 63 0 63 5 5 63 63 4 12 13 output copy 31 10 10 1 4032 15
maximum sum time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are given an array a1,a2,…,an , where all elements are different. you have to perform exactly k operations with it. during each operation, you do exactly one of the following two actions (you choose which to do yourself): find two minimum elements in the array, and delete them; find the maximum element in the array, and delete it. you have to calculate the maximum possible sum of elements in the resulting array. input the first line contains one integer t ( 1≤t≤104 ) — the number of test cases. each test case consists of two lines: the first line contains two integers n and k ( 3≤n≤2⋅105 ; 1≤k≤99999 ; 2k<n ) — the number of elements and operations, respectively. the second line contains n integers a1,a2,…,an ( 1≤ai≤109 ; all ai are different) — the elements of the array. additional constraint on the input: the sum of n does not exceed 2⋅105 . output for each test case, print one integer — the maximum possible sum of elements in the resulting array. example input copy 6 5 1 2 5 1 10 6 5 2 2 5 1 10 6 3 1 1 2 3 6 1 15 22 12 10 13 11 6 2 15 22 12 10 13 11 5 1 999999996 999999999 999999997 999999998 999999995 output copy 21 11 3 62 46 3999999986 note in the first testcase, applying the first operation produces the following outcome: two minimums are 1 and 2 ; removing them leaves the array as [5,10,6] , with sum 21 ; a maximum is 10 ; removing it leaves the array as [2,5,1,6] , with sum 14 . 21 is the best answer. in the second testcase, it's optimal to first erase two minimums, then a maximum.
politics time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output in a debate club with n members, including yourself (member 1 ), there are k opinions to be discussed in sequence. during each discussion, members express their agreement or disagreement with the opinion. let's define y as the number of members who agree and n as the number of members who disagree. after each discussion, members leave the club based on the following criteria: if more members agree than disagree ( y>n ), all members who disagreed leave the club. if more members disagree than agree ( y<n ), all members who agreed leave the club. if there is a tie ( y=n ), all members leave the club. as the club president, your goal is to stay in the club and maximize the number of members remaining after the meeting. you have access to each member's stance on all k opinions before the meeting starts, and you can expel any number of members (excluding yourself) before the meeting begins. determine the maximum number of members, including yourself, who can remain in the club after the meeting. you don't need to provide the specific expulsion strategy but only the maximum number of members that can stay. ensure that you remain in the club after the meeting as well. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤1000 ). description of the test cases follows. the first line of each test case contains two positive integers n and k ( 1≤n,k≤100 ) — the number of members and the number of discussions. the i -th of the following n lines contains a string ti of length k . the j -th character in the string ti indicates whether the i -th member agrees or disagrees with the j -th opinion if they are present during that discussion. a "+" symbol means the member agrees, while a "-" symbol means the member disagrees. it is guaranteed that the sum of n⋅k over all test cases does not exceed 5⋅104 . output for each test case, output the maximum number of members, including yourself, who can remain in the club after the meeting. example input copy 5 2 2 ++ +- 1 3 +-+ 4 1 + - - + 5 4 ++++ +--+ ++-+ +-++ ++++ 4 2 ++ -- -- -+ output copy 1 1 2 2 1 note for convenience, we will analyze the examples based on who actually attended the meeting (i. e. was not expelled) rather than who was expelled. example 1: only the first member could have attended the meeting, otherwise both members would have left after the second opinion is discussed. example 2: there is only a single member that attends the meeting and stays till the end. example 3: the club has 4 members and only one opinion will be discussed during the meeting. let's analyze the possible outcomes based on the participants in the meeting: if only the first member attends, they'll be the only one left after the meeting. if the first member attends with the second or third member, they will be a tie in the discussion, making them both leave. if the first member attends with the second and third members, the first member will be in the minority and will leave after the discussion, which contradicts the statement. if the first and fourth members attend, they will agree during the discussion and both remain till the end. if the first, second, and fourth members attend, the second member will be in the minority during the discussion, and only the first and fourth members will remain at the end. the same happens if the second member is replaced by the third member. if all four members attend, there will be a tie during the discussion, making everyone leave. the maximum number of members remaining after the meeting is 2 . example 4: the club has 5 members and 4 opinions will be discussed during the meeting. one way to achieve the maximum number of members is if only the first, third, and fifth members attend the meeting. in this case, they all agree during the first two discussions, after which the third member is in the minority during the third discussion. then, the first and fifth members agree in the last discussion, and those two members stay till the end of the meeting. example 5: the club has 4 members and 2 opinions will be discussed. if the first three members attend the meeting, the first member will be in the minority during the first discussion and will leave the club. after that, the second and third members will both disagree with the second opinion, and they both will stay till the end of the meeting. in this way, there will be 2 members left after the meeting, but it is an invalid outcome, as it forces the first member to leave. therefore, the maximum number of 1 member is achieved if only the first member attends the meeting.
new palindrome time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output a palindrome is a string that reads the same from left to right as from right to left. for example, abacaba, aaaa, abba, racecar are palindromes. you are given a string s consisting of lowercase latin letters. the string s is a palindrome. you have to check whether it is possible to rearrange the letters in it to get another palindrome (not equal to the given string s ). input the first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. the only line of each test case contains a string s ( 2≤|s|≤50 ) consisting of lowercase latin letters. this string is a palindrome. output for each test case, print yes if it is possible to rearrange the letters in the given string to get another palindrome. otherwise, print no. you may print each letter in any case (yes, yes, yes will all be recognized as positive answer, no, no and no will all be recognized as negative answer). example input copy 3 codedoc gg aabaa output copy yes no no note in the first test case, it is possible to rearrange the letters in the palindrome codedoc to obtain the string ocdedco, which is different from the given string, but also a palindrome.
luotianyi and the floating islands (easy version) time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output this is the easy version of the problem. the only difference is that in this version k≤min(n,3) . you can make hacks only if both versions of the problem are solved. chtholly and the floating islands. luotianyi now lives in a world with n floating islands. the floating islands are connected by n−1 undirected air routes, and any two of them can reach each other by passing the routes. that means, the n floating islands form a tree. one day, luotianyi wants to meet her friends: chtholly, nephren, william, .... totally, she wants to meet k people. she doesn't know the exact positions of them, but she knows that they are in pairwise distinct islands. she define an island is good if and only if the sum of the distances † from it to the islands with k people is the minimal among all the n islands. now, luotianyi wants to know that, if the k people are randomly set in k distinct of the n islands, then what is the expect number of the good islands? you just need to tell her the expect number modulo 109+7 . † the distance between two islands is the minimum number of air routes you need to take to get from one island to the other. input the first line contains two integers n and k ( 1≤k≤min(n,3),1≤n≤2⋅105 ) — the number of the islands and people respectively. next n−1 lines describe the air routes. the i -th of them contains two integers ui and vi ( 1≤ui,vi≤n,ui≠vi ) — the islands connected by the i -th air route. output print a single integer — the expect number of the good islands modulo 109+7 . formally, let m=109+7 . it can be shown that the answer can be expressed as an irreducible fraction p q , where p and q are integers and q≢0 ( modm ). output the integer equal to p⋅q−1 modm . in other words, output such an integer x that 0≤x<m and x⋅q≡p ( modm ). examples input copy 4 2 1 2 2 3 3 4 output copy 666666674 input copy 5 1 1 2 2 3 3 4 3 5 output copy 1 note in the first example the air routes form the following tree: if the people are in the islands 1 and 2 , then islands 1 and 2 will be good. the sum of the distances from island 1 or 2 to all the people is 1+0=1 , which is the minimal. while the sum of the distances from island 3 to all the people is 2+1=3 , which is greater than 1 . like this, when the people are in island 1 and 3 , then islands 1,2 and 3 will be good. when the people are in islands 1 and 4 , then islands 1,2,3 and 4 will be good. when the people are in islands 2 and 3 , then islands 2 and 3 will be good. when the people are in islands 2 and 4 , then islands 2,3 and 4 will be good. when the people are in islands 3 and 4 , then islands 3 and 4 will be good. so the expect of the number of the good islands is 16 6 , which equals to 666666674 modulo 109+7 . in the second example the air routes form the following tree: there is always the only good island, so the expected number is 1 .
grid reconstruction time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output consider a 2×n grid, where n is an even integer. you may place the integers 1,2,…,2n on the grid, using each integer exactly once. a path is a sequence of cells achieved by starting at (1,1) , then repeatedly walking either downwards or to the right, and stopping when (2,n) is reached. the path should not extend beyond the grid. the cost of a path is the alternating sum of the numbers written on the cells in a path. that is, let the numbers written on the cells be a1,a2,…,ak (in the order that it is visited), the cost of the path is a1−a2+a3−a4+…=∑ k i=1 ai⋅(−1)i+1 . construct a way to place the integers 1,2,…,2n on the grid, such that the minimum cost over all paths from (1,1) to (2,n) is maximized. if there are multiple such grids that result in the maximum value, output any of them. input the first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. the description of test cases follows. the first and the only line of each test case contains a single integer n ( 2≤n≤105 , n is even) — the number of the columns in the grid. it is guaranteed that the sum of n over all test cases does not exceed 105 . output for each test case, output 2 lines, each containing n integers — the desired grid. if there are multiple solutions, output any of them. example input copy 3 2 4 6 output copy 3 2 1 4 8 2 6 4 1 5 3 7 11 5 9 1 7 3 6 10 2 8 4 12 note in the first test case, there are only two paths from cell (1,1) to cell (2,2) . their costs are 3−1+4=6 and 3−2+4=5 . then the minimum cost is 5 , which is the maximum possible value. in the second test case, there are four paths from cell (1,1) to cell (2,4) . their costs are 8−1+5−3+7=16 , 8−2+5−3+7=15 , 8−2+6−3+7=16 , and 8−2+6−4+7=15 . then the minimum value is 15 , which is the maximum possible value.
permutation swap time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given an unsorted permutation p1,p2,…,pn . to sort the permutation, you choose a constant k ( k≥1 ) and do some operations on the permutation. in one operation, you can choose two integers i , j ( 1≤j<i≤n ) such that i−j=k , then swap pi and pj . what is the maximum value of k that you can choose to sort the given permutation? a permutation is an array consisting of n distinct integers from 1 to n in arbitrary order. for example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation ( 2 appears twice in the array) and [1,3,4] is also not a permutation ( n=3 but there is 4 in the array). an unsorted permutation p is a permutation such that there is at least one position i that satisfies pi≠i . input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains a single integer n ( 2≤n≤105 ) — the length of the permutation p . the second line of each test case contains n distinct integers p1,p2,…,pn ( 1≤pi≤n ) — the permutation p . it is guaranteed that the given numbers form a permutation of length n and the given permutation is unsorted. it is guaranteed that the sum of n over all test cases does not exceed 2⋅105 . output for each test case, output the maximum value of k that you can choose to sort the given permutation. we can show that an answer always exists. example input copy 7 3 3 1 2 4 3 4 1 2 7 4 2 6 7 5 3 1 9 1 6 7 4 9 2 3 8 5 6 1 5 3 4 2 6 10 3 10 5 2 9 6 7 8 1 4 11 1 11 6 4 8 3 7 5 9 10 2 output copy 1 2 3 4 3 2 3 note in the first test case, the maximum value of k you can choose is 1 . the operations used to sort the permutation are: swap p2 and p1 ( 2−1=1 ) → p=[1,3,2] swap p2 and p3 ( 3−2=1 ) → p=[1,2,3] in the second test case, the maximum value of k you can choose is 2 . the operations used to sort the permutation are: swap p3 and p1 ( 3−1=2 ) → p=[1,4,3,2] swap p4 and p2 ( 4−2=2 ) → p=[1,2,3,4]
rearrange brackets time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output a regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters "1" and "+" between the original characters of the sequence. for example: bracket sequences "()()" and "(())" are regular (the resulting expressions are: "(1)+(1)" and "((1+1)+1)"); bracket sequences ")(", "(" and ")" are not. you are given a regular bracket sequence. in one move, you can remove a pair of adjacent brackets such that the left one is an opening bracket and the right one is a closing bracket. then concatenate the resulting parts without changing the order. the cost of this move is the number of brackets to the right of the right bracket of this pair. the cost of the regular bracket sequence is the smallest total cost of the moves required to make the sequence empty. actually, you are not removing any brackets. instead, you are given a regular bracket sequence and an integer k . you can perform the following operation at most k times: extract some bracket from the sequence and insert it back at any position (between any two brackets, at the start or at the end; possibly, at the same place it was before). after all operations are performed, the bracket sequence has to be regular. what is the smallest possible cost of the resulting regular bracket sequence? input the first line contains a single integer t ( 1≤t≤104 ) — the number of testcases. the first line of each testcase contains a single integer k ( 0≤k≤5 ) — the maximum number of operations you can perform. the second line contains a non-empty regular bracket sequence, it consists only of characters '(' and ')'. the total length of the regular bracket sequences over all testcases doesn't exceed 2⋅105 . output for each testcase, print a single integer — the smallest possible cost of the regular bracket sequence after you perform at most k operations on it. example input copy 7 0 () 0 (()) 1 (()) 5 () 1 (()()(())) 2 ((())()(()())((()))) 3 ((())()(()())((()))) output copy 0 1 0 0 1 4 2
strongly composite time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output a prime number is an integer greater than 1 , which has exactly two divisors. for example, 7 is a prime, since it has two divisors {1,7} . a composite number is an integer greater than 1 , which has more than two different divisors. note that the integer 1 is neither prime nor composite. let's look at some composite number v . it has several divisors: some divisors are prime, others are composite themselves. if the number of prime divisors of v is less or equal to the number of composite divisors, let's name v as strongly composite. for example, number 12 has 6 divisors: {1,2,3,4,6,12} , two divisors 2 and 3 are prime, while three divisors 4 , 6 and 12 are composite. so, 12 is strongly composite. other examples of strongly composite numbers are 4 , 8 , 9 , 16 and so on. on the other side, divisors of 15 are {1,3,5,15} : 3 and 5 are prime, 15 is composite. so, 15 is not a strongly composite. other examples are: 2 , 3 , 5 , 6 , 7 , 10 and so on. you are given n integers a1,a2,…,an ( ai>1 ). you have to build an array b1,b2,…,bk such that following conditions are satisfied: product of all elements of array a is equal to product of all elements of array b : a1⋅a2⋅…⋅an=b1⋅b2⋅…⋅bk ; all elements of array b are integers greater than 1 and strongly composite; the size k of array b is the maximum possible. find the size k of array b , or report, that there is no array b satisfying the conditions. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤1000 ). the description of the test cases follows. the first line of each test case contains one integer n ( 1≤n≤1000 ) — the size of the array a . the second line of each test case contains n integer a1,a2,…an ( 2≤ai≤107 ) — the array a itself. it is guaranteed that the sum of n over all test cases does not exceed 1000 . output for each test case, print the size k of array b , or 0 , if there is no array b satisfying the conditions. example input copy 8 2 3 6 3 3 4 5 2 2 3 3 3 10 14 2 25 30 1 1080 9 3 3 3 5 5 5 7 7 7 20 12 15 2 2 2 2 2 3 3 3 17 21 21 21 30 6 6 33 31 39 output copy 1 1 0 2 2 3 4 15 note in the first test case, we can get array b=[18] : a1⋅a2=18=b1 ; 18 is strongly composite number. in the second test case, we can get array b=[60] : a1⋅a2⋅a3=60=b1 ; 60 is strongly composite number. in the third test case, there is no array b satisfying the conditions. in the fourth test case, we can get array b=[4,105] : a1⋅a2⋅a3=420=b1⋅b2 ; 4 and 105 are strongly composite numbers.
bus routes time limit per test2.5 seconds memory limit per test1024 megabytes inputstandard input outputstandard output there is a country consisting of n cities and n−1 bidirectional roads connecting them such that we can travel between any two cities using these roads. in other words, these cities and roads form a tree. there are m bus routes connecting the cities together. a bus route between city x and city y allows you to travel between any two cities in the simple path between x and y with this route. determine if for every pair of cities u and v , you can travel from u to v using at most two bus routes. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains two integers n and m ( 2≤n≤5⋅105,0≤m≤5⋅105 ) — the number of cities and the number of bus routes. then n−1 lines follow. each line contains two integers u and v denoting a road connecting city u and city v ( 1≤u,v≤n,u≠v ). it is guaranteed that these cities and roads form a tree. then m lines follow. each line contains two integers x and y denoting a bus route between city x and city y ( 1≤x,y≤n ). it is guaranteed that the sum of n over all test cases does not exceed 5⋅105 and the sum of m over all test cases does not exceed 5⋅105 . output for each test case, output "yes" if you can travel between any pair of cities using at most two bus routes. otherwise, output "no". in the next line, output two cities x and y ( 1≤x,y≤n ) such that it is impossible to reach city y from city x using at most two bus routes. you can output the answer in any case (upper or lower). for example, the strings "yes", "yes", "yes", and "yes" will be recognized as positive responses. example input copy 4 5 2 1 2 2 3 3 4 2 5 1 4 5 2 5 1 1 2 2 3 3 4 2 5 1 5 2 0 1 2 6 3 1 2 2 3 3 4 4 5 5 6 1 3 2 5 4 6 output copy yes no 1 3 no 1 2 no 1 6 note here are the graphs of test case 1 , 2 , and 4 : sample 1 sample 2 sample 4
similar polynomials time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output a polynomial a(x) of degree d is an expression of the form a(x)=a0+a1x+a2x2+⋯+adxd , where ai are integers, and ad≠0 . two polynomials a(x) and b(x) are called similar if there is an integer s such that for any integer x it holds that b(x)≡a(x+s)(mod109+7). for two similar polynomials a(x) and b(x) of degree d , you're given their values in the points x=0,1,…,d modulo 109+7 . find a value s such that b(x)≡a(x+s)(mod109+7) for all integers x . input the first line contains a single integer d ( 1≤d≤2500000 ). the second line contains d+1 integers a(0),a(1),…,a(d) ( 0≤a(i)<109+7 ) — the values of the polynomial a(x) . the third line contains d+1 integers b(0),b(1),…,b(d) ( 0≤b(i)<109+7 ) — the values of the polynomial b(x) . it is guaranteed that a(x) and b(x) are similar and that the leading coefficients (i.e., the coefficients in front of xd ) of a(x) and b(x) are not divisible by 109+7 . output print a single integer s ( 0≤s<109+7 ) such that b(x)≡a(x+s)(mod109+7) for all integers x . if there are multiple solutions, print any. examples input copy 1 1000000006 0 2 3 output copy 3 input copy 2 1 4 9 100 121 144 output copy 9 note in the first example, a(x)≡x−1(mod109+7) and b(x)≡x+2(mod109+7) . they're similar because b(x)≡a(x+3)(mod109+7). in the second example, a(x)≡(x+1)2(mod109+7) and b(x)≡(x+10)2(mod109+7) , hence b(x)≡a(x+9)(mod109+7).
range sorting (hard version) time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output the only difference between this problem and the easy version is the constraints on t and n . you are given an array a , consisting of n distinct integers a1,a2,…,an . define the beauty of an array p1,p2,…pk as the minimum amount of time needed to sort this array using an arbitrary number of range-sort operations. in each range-sort operation, you will do the following: choose two integers l and r ( 1≤l<r≤k ). sort the subarray pl,pl+1,…,pr in r−l seconds. please calculate the sum of beauty over all subarrays of array a . a subarray of an array is defined as a sequence of consecutive elements of the array. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains a single integer n ( 1≤n≤3⋅105 ) — the length of the array a . the second line of each test case consists of n integers a1,a2,…,an ( 1≤ai≤109 ). it is guaranteed that all elements of a are pairwise distinct. it is guaranteed that the sum of n over all test cases does not exceed 3⋅105 . output for each test case, output the sum of beauty over all subarrays of array a . example input copy 5 2 6 4 3 3 10 6 4 4 8 7 2 5 9 8 2 4 6 12 2 6 13 3 15 5 10 8 16 9 11 18 output copy 1 2 8 16 232 note in the first test case: the subarray [6] is already sorted, so its beauty is 0 . the subarray [4] is already sorted, so its beauty is 0 . you can sort the subarray [6,4] in one operation by choosing l=1 and r=2 . its beauty is equal to 1 . the sum of beauty over all subarrays of the given array is equal to 0+0+1=1 . in the second test case: the subarray [3] is already sorted, so its beauty is 0 . the subarray [10] is already sorted, so its beauty is 0 . the subarray [6] is already sorted, so its beauty is 0 . the subarray [3,10] is already sorted, so its beauty is 0 . you can sort the subarray [10,6] in one operation by choosing l=1 and r=2 . its beauty is equal to 2−1=1 . you can sort the subarray [3,10,6] in one operation by choosing l=2 and r=3 . its beauty is equal to 3−2=1 . the sum of beauty over all subarrays of the given array is equal to 0+0+0+0+1+1=2 .
black cells time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are playing with a really long strip consisting of 1018 white cells, numbered from left to right as 0 , 1 , 2 and so on. you are controlling a special pointer that is initially in cell 0 . also, you have a "shift" button you can press and hold. in one move, you can do one of three actions: move the pointer to the right (from cell x to cell x+1 ); press and hold the "shift" button; release the "shift" button: the moment you release "shift", all cells that were visited while "shift" was pressed are colored in black. (of course, you can't press shift if you already hold it. similarly, you can't release shift if you haven't pressed it.) your goal is to color at least k cells, but there is a restriction: you are given n segments [li,ri] — you can color cells only inside these segments, i. e. you can color the cell x if and only if li≤x≤ri for some i . what is the minimum number of moves you need to make in order to color at least k cells black? input the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the first line of each test case contains two integers n and k ( 1≤n≤2⋅105 ; 1≤k≤109 ) — the number of segments and the desired number of black cells, respectively. the second line contains n integers l1,l2,…,ln ( 1≤l1<l2<⋯<ln≤109 ), where li is the left border of the i -th segment. the third line contains n integers r1,r2,…,rn ( 1≤ri≤109 ; li≤ri<li+1−1 ), where ri is the right border of the i -th segment. additional constraints on the input: every cell belongs to at most one segment; the sum of n doesn't exceed 2⋅105 . output for each test case, print the minimum number of moves to color at least k cells black, or −1 if it's impossible. example input copy 4 2 3 1 3 1 4 4 20 10 13 16 19 11 14 17 20 2 3 1 3 1 10 2 4 99 999999999 100 1000000000 output copy 8 -1 7 1000000004 note in the first test case, one of the optimal sequences of operations is the following: move right: pointer is moving into cell 1 ; press shift; release shift: cell 1 is colored black; move right: pointer is moving into cell 2 ; move right: pointer is moving into cell 3 ; press shift; move right: pointer is moving into cell 4 ; release shift: cells 3 and 4 are colored in black. we've colored 3 cells in 8 moves. in the second test case, we can color at most 8 cells, while we need 20 cell to color. in the third test case, one of the optimal sequences of operations is the following: move right: pointer is moving into cell 1 ; move right: pointer is moving into cell 2 ; move right: pointer is moving into cell 3 ; press shift; move right: pointer is moving into cell 4 ; move right: pointer is moving into cell 5 ; release shift: cells 3 , 4 and 5 are colored in black. we've colored 3 cells in 7 moves.
mex tree time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are given a tree with n nodes. for each node, you either color it in 0 or 1 . the value of a path (u,v) is equal to the mex † of the colors of the nodes from the shortest path between u and v . the value of a coloring is equal to the sum of values of all paths (u,v) such that 1≤u≤v≤n . what is the maximum possible value of any coloring of the tree? † the mex (minimum excluded) of an array is the smallest non-negative integer that does not belong to the array. for instance: the mex of [2,2,1] is 0 , because 0 does not belong to the array. the mex of [3,1,0,1] is 2 , because 0 and 1 belong to the array, but 2 does not. the mex of [0,3,1,2] is 4 because 0 , 1 , 2 , and 3 belong to the array, but 4 does not. input each test contains multiple test cases. the first line of input contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of test cases follows. the first line of each test case contains a single integer n ( 1≤n≤2⋅105 ) — the number of nodes in the tree. the following n−1 lines of each test case contains 2 integers ai and bi ( 1≤ai,bi≤n,ai≠bi ) — indicating an edge between vertices ai and bi . it is guaranteed that the given edges form a tree. it is guaranteed that the sum of n across all test cases does not exceed 2⋅105 . output for each test case, print the maximum possible value of any coloring of the tree. example input copy 4 3 1 2 2 3 4 1 2 1 3 1 4 10 1 2 1 3 3 4 3 5 1 6 5 7 2 8 6 9 6 10 1 output copy 8 15 96 1 note in the first sample, we will color vertex 2 in 1 and vertices 1,3 in 0 . after this, we consider all paths: (1,1) with value 1 (1,2) with value 2 (1,3) with value 2 (2,2) with value 0 (2,3) with value 2 (3,3) with value 1 we notice the sum of values is 8 which is the maximum possible.
zombies time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output polycarp plays a computer game in a post-apocalyptic setting. the zombies have taken over the world, and polycarp with a small team of survivors is defending against hordes trying to invade their base. the zombies are invading for x minutes starting from minute 0 . there are n entrances to the base, and every minute one zombie attempts to enter through every entrance. the survivors can defend the entrances against the zombies. there are two options: manually — shoot the zombies coming through a certain entrance; automatically — set up an electric fence on a certain entrance to fry the zombies. if an entrance is defended either or both ways during some minute, no zombie goes through. every entrance is defended by a single dedicated survivor. the i -th entrance is defended manually from minute li until minute ri , non-inclusive — [li,ri) . there are k generators that can be used to defend the entrances automatically. every entrance should be connected to exactly one generator, but a generator can be connected to multiple entrances (or even none of them). each generator will work for exactly m consecutive minutes. polycarp can choose when to power on each generator independently of each other, the m minute long interval should be fully inside the [0,x) time interval. polycarp is a weird gamer. he wants the game to be as difficult as possible for him. so he wants to connect each entrance to a generator and choose the time for each generator in such a way that as many zombies as possible enter the base. please, help him to achieve that! input the first line contains four integers n,k,x and m ( 1≤k≤n≤2000 ; 1≤m≤x≤109 ) — the number of entrances, the number of generators, the duration of the zombie invasion and the duration of all generators. the i -th of the next n lines contains two integers li and ri ( 0≤li<ri≤x ) — the time interval the i -th entrance is defended manually. output print a single integer — the largest number of zombies that can enter the base after polycarp connects each entrance to some generator and chooses the time for each generator. examples input copy 3 3 10 3 0 2 1 7 4 7 output copy 18 input copy 3 2 10 3 0 2 1 7 4 7 output copy 18 input copy 3 1 10 3 0 2 1 7 4 7 output copy 16 input copy 2 1 20 6 11 13 2 14 output copy 22 input copy 5 3 7 4 4 6 0 3 4 7 1 5 2 7 output copy 14 input copy 6 3 9 4 3 9 4 9 2 5 0 5 6 9 2 3 output copy 26
dreaming of freedom time limit per test2.5 seconds memory limit per test256 megabytes inputstandard input outputstandard output because to take away a man's freedom of choice, even his freedom to make the wrong choice, is to manipulate him as though he were a puppet and not a person. — madeleine l'engle there are n programmers choosing their favorite algorithm amongst m different choice options. before the first round, all m options are available. in each round, every programmer makes a vote for one of the remaining algorithms. after the round, only the algorithms with the maximum number of votes remain. the voting process ends when there is only one option left. determine whether the voting process can continue indefinitely or no matter how people vote, they will eventually choose a single option after some finite amount of rounds? input the first line contains a single integer t ( 1≤t≤105 ) — the number of test cases. each test case consists of a single line containing two integers n and m ( 1≤n,m≤106 ) — the number of people and choice options respectively. output for each test case output "yes" if the programmers will eventually choose a single option, and "no" otherwise. you may print each letter in any case (for example, yes, yes, yes, yes will all be recognized as a positive answer). example input copy 5 3 2 4 2 5 3 1000000 1000000 1 1000000 output copy yes no yes no yes note in the first example, there are 8 ways people could vote: {1|1|1,1|1|2,1|2|1,1|2|2,2|1|1,2|1|2,2|2|1,2|2|2} . in cases 1 , 2 , 3 , and 5 , the programmers are left with the first algorithm, and in the remaining cases people are left with the second one, so the voting ends in one round in any case. in the second example, the programmers could always vote 1|1|2|2 . both algorithms have the maximum number of votes and remain for the next round, so the voting never ends.
mr. perfectly fine time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output victor wants to become "mr. perfectly fine". for that, he needs to acquire a certain set of skills. more precisely, he has 2 skills he needs to acquire. victor has n books. reading book i takes him mi minutes and will give him some (possibly none) of the required two skills, represented by a binary string of length 2 . what is the minimum amount of time required so that victor acquires all of the two skills? input the input consists of multiple test cases. the first line contains an integer t ( 1≤t≤1000 ) — the number of test cases. the description of the test cases follows. the first line of each test case contains an integer n ( 1≤n≤2⋅105 ) — the number of books available. then n lines follow. line i contains a positive integer mi ( 1≤mi≤2⋅105 ) and a binary string of length 2 , where si1=1 if reading book i acquires victor skill 1 , and si1=0 otherwise, and si2=1 if reading book i acquires victor skill 2 , and si2=0 otherwise. it is guaranteed that the sum of n over all test cases doesn't exceed 2⋅105 . output for each test case, output a single integer denoting the minimum amount of minutes required for victor to obtain both needed skills and −1 in case it's impossible to obtain the two skills after reading any amount of books. example input copy 6 4 2 00 3 10 4 01 4 00 5 3 01 3 01 5 01 2 10 9 10 1 5 11 3 9 11 8 01 7 10 6 4 01 6 01 7 01 8 00 9 01 1 00 4 8 00 9 10 9 11 8 11 output copy 7 5 5 9 -1 8 note in the first test case, we can use books 2 and 3 , with a total amount of minutes spent equal to 3+4=7 . in the second test case, we can use the books 1 and 4 , with a total amount of minutes spent equal to 3+2=5 . in the third test case, we have only one option and that is reading book 1 for a total amount of minutes spent equal to 5 .
removing graph time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output alice and bob are playing a game on a graph. they have an undirected graph without self-loops and multiple edges. all vertices of the graph have degree equal to 2 . the graph may consist of several components. note that if such graph has n vertices, it will have exactly n edges. alice and bob take turn. alice goes first. in each turn, the player can choose k ( l≤k≤r ; l<r ) vertices that form a connected subgraph and erase these vertices from the graph, including all incident edges. the player who can't make a step loses. for example, suppose they are playing on the given graph with given l=2 and r=3 : a valid vertex set for alice to choose at the first move is one of the following: {1,2} {1,3} {2,3} {4,5} {4,6} {5,6} {1,2,3} {4,5,6} suppose, alice chooses subgraph {4,6} . then a valid vertex set for bob to choose at the first move is one of the following: {1,2} {1,3} {2,3} {1,2,3} suppose, bob chooses subgraph {1,2,3} . alice can't make a move, so she loses. you are given a graph of size n and integers l and r . who will win if both alice and bob play optimally. input the first line contains three integers n , l and r ( 3≤n≤2⋅105 ; 1≤l<r≤n ) — the number of vertices in the graph, and the constraints on the number of vertices alice or bob can choose in one move. next n lines contains edges of the graph: one edge per line. the i -th line contains two integers ui and vi ( 1≤ui,vi≤n ; ui≠vi ) — description of the i -th edge. it's guaranteed that the degree of each vertex of the given graph is equal to 2 . output print alice (case-insensitive) if alice wins, or bob otherwise. examples input copy 6 2 3 1 2 2 3 3 1 4 5 5 6 6 4 output copy bob input copy 6 1 2 1 2 2 3 3 1 4 5 5 6 6 4 output copy bob input copy 12 1 3 1 2 2 3 3 1 4 5 5 6 6 7 7 4 8 9 9 10 10 11 11 12 12 8 output copy alice note in the first test the same input as in legend is shown. in the second test the same graph as in legend is shown, but with l=1 and r=2 .
ian visits mary time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output ian and mary are frogs living on lattice points of the cartesian coordinate plane, with ian living on (0,0) and mary living on (a,b) . ian would like to visit mary by jumping around the cartesian coordinate plane. every second, he jumps from his current position (xp,yp) to another lattice point (xq,yq) , such that no lattice point other than (xp,yp) and (xq,yq) lies on the segment between point (xp,yp) and point (xq,yq) . as ian wants to meet mary as soon as possible, he wants to jump towards point (a,b) using at most 2 jumps. unfortunately, ian is not good at maths. can you help him? a lattice point is defined as a point with both the x -coordinate and y -coordinate being integers. input the first line contains a single integer t ( 1≤t≤500 ) — the number of test cases. the description of test cases follows. the first and only line of each test case contains two integers a and b ( 1≤a,b≤109 ) — the coordinates of the lattice point where mary lives. output for each test case, print an integer n ( 1≤n≤2 ) on the first line, denoting the number of jumps ian uses in order to meet mary. note that you do not need to minimize the number of jumps. on the i -th line of the next n lines, print two integers 0≤xi,yi≤109 separated by a space, denoting ian's location (xi,yi) after the i -th jump. xn=a , yn=b must hold. ian's initial location and his locations after each of the n jumps need not be distinct. if there are multiple solutions, output any. example input copy 8 3 4 4 4 3 6 2 2 1 1 7 3 2022 2023 1000000000 1000000000 output copy 1 3 4 2 3 2 4 4 2 5 3 3 6 2 1 0 2 2 1 1 1 1 7 3 1 2022 2023 2 69420420 469696969 1000000000 1000000000 note in the first test case: (0,0)→(3,4) in the second test case: (0,0)→(3,2)→(4,4) in the third test case: (0,0)→(5,3)→(3,6)
making anti-palindromes time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given a string s , consisting of lowercase english letters. in one operation, you are allowed to swap any two characters of the string s . a string s of length n is called an anti-palindrome, if s[i]≠s[n−i+1] for every i ( 1≤i≤n ). for example, the strings "codeforces", "string" are anti-palindromes, but the strings "abacaba", "abc", "test" are not. determine the minimum number of operations required to make the string s an anti-palindrome, or output −1 , if this is not possible. input the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of the test cases follows. each test case consists of two lines. the first line contains a single integer n ( 1≤n≤2⋅105 ) — the length of the string s . the second line contains the string s , consisting of n lowercase english letters. the sum of n over all test cases does not exceed 2⋅105 . output for each test case, output a single integer — the minimum number of operations required to make the string s an anti-palindrome, or −1 if this is not possible. example input copy 10 10 codeforces 3 abc 10 taarrrataa 10 dcbdbdcccc 4 wwww 12 cabbaccabaac 10 aadaaaaddc 14 aacdaaaacadcdc 6 abccba 12 dcbcaebacccd output copy 0 -1 1 1 -1 3 -1 2 2 2 note in the first test case, the string "codeforces" is already an anti-palindrome, so the answer is 0 . in the second test case, it can be shown that the string "abc" cannot be transformed into an anti-palindrome by performing the allowed operations, so the answer is −1 . in the third test case, it is enough to swap the second and the fifth characters of the string "taarrrataa", and the new string "trararataa" will be an anti-palindrome, so the answer is 1 .
forever winter time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output a snowflake graph is generated from two integers x and y , both greater than 1 , as follows: start with one central vertex. connect x new vertices to this central vertex. connect y new vertices to each of these x vertices. for example, below is a snowflake graph for x=5 and y=3 . the snowflake graph above has a central vertex 15 , then x=5 vertices attached to it ( 3 , 6 , 7 , 8 , and 20 ), and then y=3 vertices attached to each of those. given a snowflake graph, determine the values of x and y . input the first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. the first line of each test case contains two integers n and m ( 2≤n≤200 ; 1≤m≤min(1000, n(n−1) 2 ) ) — the number of vertices and edges in the graph, respectively. the next m lines each contain two integers each u and v ( 1≤u,v≤n , u≠v ) — the numbers of vertices connected by an edge. the graph does not contain multiple edges and self-loops. it is guaranteed that this graph is a snowflake graph for some integers x and y both greater than 1 . output for each test case, on a separate line output the values of x and y , in that order, separated by a space. example input copy 3 21 20 21 20 5 20 13 20 1 3 11 3 10 3 4 8 19 8 14 8 9 7 12 7 17 7 18 6 16 6 2 6 6 15 7 15 8 15 20 15 3 15 7 6 1 2 1 3 2 4 2 5 3 6 3 7 9 8 9 3 3 6 6 2 2 1 5 2 2 7 4 3 3 8 output copy 5 3 2 2 2 3 note the first test case is pictured in the statement. note that the output 3 5 is incorrect, since x should be output before y .
gardening friends time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output two friends, alisa and yuki, planted a tree with n vertices in their garden. a tree is an undirected graph without cycles, loops, or multiple edges. each edge in this tree has a length of k . initially, vertex 1 is the root of the tree. alisa and yuki are growing the tree not just for fun, they want to sell it. the cost of the tree is defined as the maximum distance from the root to a vertex among all vertices of the tree. the distance between two vertices u and v is the sum of the lengths of the edges on the path from u to v . the girls took a course in gardening, so they know how to modify the tree. alisa and yuki can spend c coins to shift the root of the tree to one of the neighbors of the current root. this operation can be performed any number of times (possibly zero). note that the structure of the tree is left unchanged; the only change is which vertex is the root. the friends want to sell the tree with the maximum profit. the profit is defined as the difference between the cost of the tree and the total cost of operations. the profit is cost of the tree minus the total cost of operations. help the girls and find the maximum profit they can get by applying operations to the tree any number of times (possibly zero). input the first line of the input contains one integer t ( 1≤t≤104 ) — the number of test cases. the description of the test cases follows. the first line of each test case contains integers n , k , c ( 2≤n≤2⋅105 ; 1≤k,c≤109 ) — the number of vertices in the tree, the length of each edge, and the cost of the operation. the next n−1 lines of the test case contain pairs of integers ui , vi ( 1≤ui,vi≤n ) — the edges of the graph. these edges form a tree. the sum of the values of n over all test cases does not exceed 2⋅105 . output for each test case, output a single integer — the maximum profit that yuki and alisa can get. example input copy 4 3 2 3 2 1 3 1 5 4 1 2 1 4 2 5 4 3 4 6 5 3 4 1 6 1 2 6 5 1 3 2 10 6 4 1 3 1 9 9 7 7 6 6 4 9 2 2 8 8 5 5 10 output copy 2 12 17 32
willy-nilly, crack, into release! time limit per test3 seconds memory limit per test1024 megabytes inputstandard input outputstandard output you have long dreamed of working in a large it company and finally got a job there. you have studied all existing modern technologies for a long time and are ready to apply all your knowledge in practice. but then you sit down at your desk and see a sheet of paper with the company's motto printed in large letters: abcdabcdabcdabcd.... the company's motto contains four main principles— a (willi), b (nilli), c (crack), d (release). therefore, you consider strings of length n consisting of these four latin letters. unordered pairs of letters "ab", "bc", "cd", and "da" in this motto are adjacent, so we will call such pairs of symbols good. so, if you are given a string s of length n , and it is known that the unordered pair of symbols {x,y} is good, then you can perform one of the following operations on the string: if sn=x , then you are allowed to replace this symbol with y , if there exists 1≤i<n such that si=x and si+1=…=sn=y , then you are allowed to replace the i -th symbol of the string with y , and all subsequent symbols with x . for example, the string bacdd can be replaced with one of the strings bacda, bacdc, or badcc, and the string aac can be replaced with aab or aad. a non-empty sequence of operations for the string s will be called correct if the following two conditions are met: after performing all operations, the string becomes s again, no string, except for s , will occur more than once during the operations. at the same time, the string s can occur exactly twice - before the start of the operations and after performing all operations. now we are ready to move on to the problem statement! you have a set of strings that is initially empty. then, each of q queries adds another string ti to the set, or removes the string ti from the set. after each query, you need to output the minimum and maximum size of a correct sequence of operations in which each word occurs at least once. the choice of the initial string s is up to you. input the first line contains two integers n and q ( 1≤n≤20 , 1≤q≤100000 ) — the length of the strings under consideration and the number of queries to modify the set of strings. each of the next q lines contains a string ti ( |ti|=n ). all strings consist of characters "a", "b", "c" and "d". if the string ti was not in the set before the query, it is added to the set, otherwise it is removed from the set. output for each of the q queries, output two integers: the minimum and maximum size of a correct sequence of operations in which each word from the set appears at least once. if there is no sequence of operations that satisfies the condition of the problem, output a single number −1 . examples input copy 2 4 aa ac dd ac output copy 2 12 4 4 -1 12 12 input copy 3 2 acc bdd output copy 2 44 28 44 note let's consider the first test example. after the first query, the set of important words is equal to { aa } , the minimum sequence of actions has the following form: aa, ab, aa. the maximum sequence of actions that fits is aa, ab, ba, bb, bc, cb, cc, cd, dc, dd, da, ad, aa. after the second query, the set of important words is equal to { aa, ac } . the minimum and maximum sequences of actions are: aa, ab, ac, ad, aa. after the third query, the set of important words is equal to { aa, ac, dd } . there is no sequence of actions that fits the condition, so −1 should be outputted. after the fourth query, the set of important words is equal to { aa, dd } . the minimum and maximum sequences of actions are as follows: aa, ab, ba, bb, bc, cb, cc, cd, dc, dd, da, ad, aa.
xor counting time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output given two positive integers n and m . find the sum of all possible values of a1⨁a2⨁…⨁am , where a1,a2,…,am are non-negative integers such that a1+a2+…+am=n . note that all possible values a1⨁a2⨁…⨁am should be counted in the sum exactly once. as the answer may be too large, output your answer modulo 998244353 . here, ⨁ denotes the bitwise xor operation. input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of test cases follows. the first and only line of each test case contains two integers n and m ( 0≤n≤1018,1≤m≤105 ) — the sum and the number of integers in the set, respectively. output for each test case, output the sum of all possible values of a1⨁a2⨁…⨁am among all non-negative integers a1,a2,…,am with a1+a2+…+am=n . as the answer may be too large, output your answer modulo 998244353 . example input copy 7 69 1 5 2 0 10 420 69 12 26 73 34 1000000000000000000 10 output copy 69 6 0 44310 42 1369 216734648 note for the first test case, we must have a1=69 , so it's the only possible value of a1 , therefore our answer is 69 . for the second test case, (a1,a2) can be (0,5),(1,4),(2,3),(3,2),(4,1) or (5,0) , in which a1⨁a2 are 5,5,1,1,5,5 respectively. so a1⨁a2 can be 1 or 5 , therefore our answer is 1+5=6 . for the third test case, a1,a2,…,a10 must be all 0 , so a1⨁a2⨁…⨁a10=0 . therefore our answer is 0 .
yura's new name time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output after holding one team contest, boy yura got very tired and wanted to change his life and move to japan. in honor of such a change, yura changed his name to something nice. fascinated by this idea he already thought up a name s consisting only of characters "_" and "^". but there's a problem — yura likes smiley faces "^_^" and "^^". therefore any character of the name must be a part of at least one such smiley. note that only the consecutive characters of the name can be a smiley face. more formally, consider all occurrences of the strings "^_^" and "^^" in the string s . then all such occurrences must cover the whole string s , possibly with intersections. for example, in the string "^^__^_^^__^" the characters at positions 3,4,9,10 and 11 are not contained inside any smileys, and the other characters at positions 1,2,5,6,7 and 8 are contained inside smileys. in one operation jura can insert one of the characters "_" and "^" into his name s (you can insert it at any position in the string). he asks you to tell him the minimum number of operations you need to do to make the name fit yura's criteria. input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤100 ) —the number of test cases. the description of test cases follows. the first and only line of each test case contains a single string s ( 1≤|s|≤100 ), consisting of characters "_" and "^", — the name to change. output for each test case, output a single integer — the minimum number of characters you need to add to the name to make it fit for yura. if you don't need to change anything in the name, print 0 . example input copy 7 ^______^ ___^_^^^_^___^ ^_ ^ ^_^^^^^_^_^^ ___^^ _ output copy 5 5 1 1 0 3 2 note in the first test case, you can get the following name by adding 5 characters: ^_^_^_^_^_^_^ in the third test case, we can add one character "^" to the end of the name, then we get the name: ^_^ in the fourth test case, we can add one character "^" to the end of the name, then we get the name: ^^ in the fifth test case, all of the characters are already contained in smiley faces, so the answer is 0 . in the seventh test case, you can add one character "^" at the beginning of the name and one character "^" at the end of the name, then you get the name: ^_^
fish graph time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given a simple undirected graph with n nodes and m edges. note that the graph is not necessarily connected. the nodes are labeled from 1 to n . we define a graph to be a fish graph if it contains a simple cycle with a special node u belonging to the cycle. apart from the edges in the cycle, the graph should have exactly 2 extra edges. both edges should connect to node u , but they should not be connected to any other node of the cycle. determine if the graph contains a subgraph that is a fish graph, and if so, find any such subgraph. in this problem, we define a subgraph as a graph obtained by taking any subset of the edges of the original graph. visualization of example 1. the red edges form one possible subgraph that is a fish graph. input the first line of input contains the integer t ( 1≤t≤1000 ), the number of test cases. the description of test cases follows. the first line of each test case contains two integers, n and m ( 1≤n,m≤2000 ) — the number of nodes and the number of edges. each of the next m lines contains the description of an edge. each line contains two integers ui and vi ( 1≤ui,vi≤n , ui≠vi ) — an edge connects node ui to node vi . it is guaranteed that no two edges connect the same unordered pair of nodes. furthermore, it is guaranteed that the sum of n and the sum of m over all test cases both do not exceed 2000 . output for each testcase, output "yes" if the graph contains a subgraph that is a fish graph, otherwise print "no". if the answer is "yes", on the following lines output a description of the subgraph. the first line of the description contains one integer k — the number of edges of the subgraph. on the next k lines, output the edges of the chosen subgraph. each of the k lines should contains two integers u and v ( 1≤u,v≤n , u≠v ) — the edge between u and v belongs to the subgraph. the order in which u and v are printed does not matter, as long as the two nodes are connected by an edge in the original graph. the order in which you print the edges does not matter, as long as the resulting subgraph is a fish graph. if there are multiple solutions, print any. example input copy 3 7 8 1 2 2 3 3 4 4 1 4 5 4 6 4 2 6 7 7 7 6 7 1 2 2 3 3 4 4 1 1 3 3 5 4 4 1 3 3 4 4 1 1 2 output copy yes 6 5 4 6 4 4 3 1 4 2 1 3 2 yes 5 5 3 2 3 3 1 4 3 1 4 no note in the first example, a possible valid subgraph contains the cycle 1→2→3→4→1 . the special node of this cycle is node 4 . the two extra edges 4−5 and 4−6 are both connected to 4 , completing the fish graph. in the second example, a possible valid subgraph contains the cycle 1→3→4→1 . the special node of this cycle is node 3 . the two extra edges 3−2 and 3−5 are both connected to 3 , completing the fish graph. in the last example, it can be proven that there is no valid subgraph.
super-permutation time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output a permutation is a sequence n integers, where each integer from 1 to n appears exactly once. for example, [1] , [3,5,2,1,4] , [1,3,2] are permutations, while [2,3,2] , [4,3,1] , [0] are not. given a permutation a , we construct an array b , where bi=(a1+a2+ … +ai)modn . a permutation of numbers [a1,a2,…,an] is called a super-permutation if [b1+1,b2+1,…,bn+1] is also a permutation of length n . grisha became interested whether a super-permutation of length n exists. help him solve this non-trivial problem. output any super-permutation of length n , if it exists. otherwise, output −1 . input the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of the test cases follows. each test case consists of a single line containing one integer n ( 1≤n≤2⋅105 ) — the length of the desired permutation. the sum of n over all test cases does not exceed 2⋅105 . output for each test case, output in a separate line: n integers — a super-permutation of length n , if it exists. −1 , otherwise. if there are several suitable permutations, output any of them. example input copy 4 1 2 3 6 output copy 1 2 1 -1 6 5 2 3 4 1
new palindrome time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output a palindrome is a string that reads the same from left to right as from right to left. for example, abacaba, aaaa, abba, racecar are palindromes. you are given a string s consisting of lowercase latin letters. the string s is a palindrome. you have to check whether it is possible to rearrange the letters in it to get another palindrome (not equal to the given string s ). input the first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. the only line of each test case contains a string s ( 2≤|s|≤50 ) consisting of lowercase latin letters. this string is a palindrome. output for each test case, print yes if it is possible to rearrange the letters in the given string to get another palindrome. otherwise, print no. you may print each letter in any case (yes, yes, yes will all be recognized as positive answer, no, no and no will all be recognized as negative answer). example input copy 3 codedoc gg aabaa output copy yes no no note in the first test case, it is possible to rearrange the letters in the palindrome codedoc to obtain the string ocdedco, which is different from the given string, but also a palindrome.
array merging time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given two arrays a and b both of length n . you will merge † these arrays forming another array c of length 2⋅n . you have to find the maximum length of a subarray consisting of equal values across all arrays c that could be obtained. † a merge of two arrays results in an array c composed by successively taking the first element of either array (as long as that array is nonempty) and removing it. after this step, the element is appended to the back of c . we repeat this operation as long as we can (i.e. at least one array is nonempty). input each test contains multiple test cases. the first line of input contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of test cases follows. the first line of each test case contains a single integer n ( 1≤n≤2⋅105 ) — the length of the array a and b . the second line of each test case contains n integers a1,a2,…,an ( 1≤ai≤2⋅n ) — the elements of array a . the third line of each test case contains n integers b1,b2,…,bn ( 1≤bi≤2⋅n ) — the elements of array b . it is guaranteed that the sum of n across all test cases does not exceed 2⋅105 . output for each test case, output the maximum length of a subarray consisting of equal values across all merges. example input copy 4 1 2 2 3 1 2 3 4 5 6 2 1 2 2 1 5 1 2 2 2 2 2 1 1 1 1 output copy 2 1 2 5 note in the first test case, we can only make c=[2,2] , thus the answer is 2 . in the second test case, since all values are distinct, the answer must be 1 . in the third test case, the arrays c we can make are [1,2,1,2] , [1,2,2,1] , [2,1,1,2] , [2,1,2,1] . we can see that the answer is 2 when we choose c=[1,2,2,1] .
red-blue operations (easy version) time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output the only difference between easy and hard versions is the maximum values of n and q . you are given an array, consisting of n integers. initially, all elements are red. you can apply the following operation to the array multiple times. during the i -th operation, you select an element of the array; then: if the element is red, it increases by i and becomes blue; if the element is blue, it decreases by i and becomes red. the operations are numbered from 1 , i. e. during the first operation some element is changed by 1 and so on. you are asked q queries of the following form: given an integer k , what can the largest minimum in the array be if you apply exactly k operations to it? note that the operations don't affect the array between queries, all queries are asked on the initial array a . input the first line contains two integers n and q ( 1≤n,q≤1000 ) — the number of elements in the array and the number of queries. the second line contains n integers a1,a2,…,an ( 1≤ai≤109 ). the third line contains q integers k1,k2,…,kq ( 1≤kj≤109 ). output for each query, print a single integer — the largest minimum that the array can have after you apply exactly k operations to it. examples input copy 4 10 5 2 8 4 1 2 3 4 5 6 7 8 9 10 output copy 3 4 5 6 7 8 8 10 8 12 input copy 5 10 5 2 8 4 4 1 2 3 4 5 6 7 8 9 10 output copy 3 4 5 6 7 8 9 8 11 8 input copy 2 5 2 3 10 6 8 1 3 output copy 10 7 8 3 3
musical puzzle time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output vlad decided to compose a melody on his guitar. let's represent the melody as a sequence of notes corresponding to the characters 'a', 'b', 'c', 'd', 'e', 'f', and 'g'. however, vlad is not very experienced in playing the guitar and can only record exactly two notes at a time. vlad wants to obtain the melody s , and to do this, he can merge the recorded melodies together. in this case, the last sound of the first melody must match the first sound of the second melody. for example, if vlad recorded the melodies "ab" and "ba", he can merge them together and obtain the melody "aba", and then merge the result with "ab" to get "abab". help vlad determine the minimum number of melodies consisting of two notes that he needs to record in order to obtain the melody s . input the first line of input contains an integer t ( 1≤t≤104 ) — the number of test cases. following that are the descriptions of the test cases. the first line of each test case contains an integer n ( 2≤n≤50 ) — the length of the melody s . the second line of each test case contains a string s of length n , consisting of characters 'a', 'b', 'c', 'd', 'e', 'f', 'g'. output output t integers, each representing the answer for the corresponding test case. as the answer output minimum number of melodies consisting of two notes that vlad needs to record. example input copy 5 4 abab 7 abacaba 6 aaaaaa 7 abcdefg 5 babdd output copy 2 4 1 6 4 note in the first sample, you need to record the melodies "ab" and "ba", as described in the problem statement. in the second sample, you need to record the melodies "ab", "ba", "ac", and "ca". in the third sample, the only necessary melody is "aa".
copium permutation time limit per test2 seconds memory limit per test1024 megabytes inputstandard input outputstandard output you are given a permutation a1,a2,…,an of the first n positive integers. a subarray [l,r] is called copium if we can rearrange it so that it becomes a sequence of consecutive integers, or more formally, if max(al,al+1,…,ar)−min(al,al+1,…,ar)=r−l for each k in the range [0,n] , print out the maximum number of copium subarrays of a over all ways of rearranging the last n−k elements of a . input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains a single integer n ( 1≤n≤2⋅105 ). the second line of each test case contains n integers a1,a2,…,an ( 1≤ai≤n ). it is guaranteed that the given numbers form a permutation of length n . it is guaranteed that the sum of n over all test cases does not exceed 2⋅105 . output for each test case print n+1 integers as the answers for each k in the range [0,n] . example input copy 5 5 5 2 1 4 3 4 2 1 4 3 1 1 8 7 5 8 1 4 2 6 3 10 1 4 5 3 7 8 9 2 10 6 output copy 15 15 11 10 9 9 10 8 8 7 7 1 1 36 30 25 19 15 13 12 9 9 55 55 41 35 35 25 22 22 19 17 17 note in the first test case, the answer permutations for each k are [1,2,3,4,5] , [5,4,3,2,1] , [5,2,3,4,1] , [5,2,1,3,4] , [5,2,1,4,3] , [5,2,1,4,3] . in the second test case, the answer permutations for each k are [1,2,3,4] , [2,1,3,4] , [2,1,3,4] , [2,1,4,3] , [2,1,4,3] .
fish graph time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given a simple undirected graph with n nodes and m edges. note that the graph is not necessarily connected. the nodes are labeled from 1 to n . we define a graph to be a fish graph if it contains a simple cycle with a special node u belonging to the cycle. apart from the edges in the cycle, the graph should have exactly 2 extra edges. both edges should connect to node u , but they should not be connected to any other node of the cycle. determine if the graph contains a subgraph that is a fish graph, and if so, find any such subgraph. in this problem, we define a subgraph as a graph obtained by taking any subset of the edges of the original graph. visualization of example 1. the red edges form one possible subgraph that is a fish graph. input the first line of input contains the integer t ( 1≤t≤1000 ), the number of test cases. the description of test cases follows. the first line of each test case contains two integers, n and m ( 1≤n,m≤2000 ) — the number of nodes and the number of edges. each of the next m lines contains the description of an edge. each line contains two integers ui and vi ( 1≤ui,vi≤n , ui≠vi ) — an edge connects node ui to node vi . it is guaranteed that no two edges connect the same unordered pair of nodes. furthermore, it is guaranteed that the sum of n and the sum of m over all test cases both do not exceed 2000 . output for each testcase, output "yes" if the graph contains a subgraph that is a fish graph, otherwise print "no". if the answer is "yes", on the following lines output a description of the subgraph. the first line of the description contains one integer k — the number of edges of the subgraph. on the next k lines, output the edges of the chosen subgraph. each of the k lines should contains two integers u and v ( 1≤u,v≤n , u≠v ) — the edge between u and v belongs to the subgraph. the order in which u and v are printed does not matter, as long as the two nodes are connected by an edge in the original graph. the order in which you print the edges does not matter, as long as the resulting subgraph is a fish graph. if there are multiple solutions, print any. example input copy 3 7 8 1 2 2 3 3 4 4 1 4 5 4 6 4 2 6 7 7 7 6 7 1 2 2 3 3 4 4 1 1 3 3 5 4 4 1 3 3 4 4 1 1 2 output copy yes 6 5 4 6 4 4 3 1 4 2 1 3 2 yes 5 5 3 2 3 3 1 4 3 1 4 no note in the first example, a possible valid subgraph contains the cycle 1→2→3→4→1 . the special node of this cycle is node 4 . the two extra edges 4−5 and 4−6 are both connected to 4 , completing the fish graph. in the second example, a possible valid subgraph contains the cycle 1→3→4→1 . the special node of this cycle is node 3 . the two extra edges 3−2 and 3−5 are both connected to 3 , completing the fish graph. in the last example, it can be proven that there is no valid subgraph.
the butcher time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output anton plays his favorite game "defense of the ancients 2" for his favorite hero — the butcher. now he wants to make his own dinner. to do this he will take a rectangle of height h and width w , then make a vertical or horizontal cut so that both resulting parts have integer sides. after that, he will put one of the parts in the box and cut the other again, and so on. more formally, a rectangle of size h×w can be cut into two parts of sizes x×w and (h−x)×w , where x is an integer from 1 to (h−1) , or into two parts of sizes h×y and h×(w−y) , where y is an integer from 1 to (w−1) . he will repeat this operation n−1 times, and then put the remaining rectangle into the box too. thus, the box will contain n rectangles, of which n−1 rectangles were put in the box as a result of the cuts, and the n -th rectangle is the one that the butcher has left after all n−1 cuts. unfortunately, butcher forgot the numbers h and w , but he still has n rectangles mixed in random order. note that butcher didn't rotate the rectangles, but only shuffled them. now he wants to know all possible pairs (h,w) from which this set of rectangles can be obtained. and you have to help him do it! it is guaranteed that there exists at least one pair (h,w) from which this set of rectangles can be obtained. input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of test cases follows. the first line of each test case contains a single integer n ( 1≤n≤2⋅105 ) — the number of rectangles obtained. the i -th of the next n lines contains two integers ai and bi ( 1≤ai,bi≤106 ) — the height and width of the i -th rectangle. it is guaranteed that the sum of n over all test cases does not exceed 2⋅105 . output for each test case, on the first line output a single integer m — the number of pairs (h,w) denoting the sizes of rectangles from which the given rectangles can be obtained. two rectangles are considered different if they have different heights or widths. on each of the following m lines print output integers hi and wi — the height and width of the rectangle from which the given rectangles can be obtained. you can output the rectangles in any order. example input copy 4 3 1 2 3 5 1 3 3 1 1 1 1 1 1 1 10 10 4 3 2 5 5 2 2 8 7 output copy 1 4 5 2 1 3 3 1 1 10 10 1 13 7 note in the first test case, butcher could only have a rectangle of size 4×5 . then the cuts could look like this (first the green cut was made, then the red one): in the second test case, butcher could have either a rectangle of 1×3 or 3×1 . the cuts would have looked like this (first the green cut was made, then the red cut): in the third test case, butcher did not make any cuts, so the rectangle is 10×10 .
jojo's incredible adventures time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output did you think there was going to be a jojo legend here? but no, that was me, dio! given a binary string s of length n , consisting of characters 0 and 1. let's build a square table of size n×n , consisting of 0 and 1 characters as follows. in the first row of the table write the original string s . in the second row of the table write cyclic shift of the string s by one to the right. in the third row of the table, write the cyclic shift of line s by two to the right. and so on. thus, the row with number k will contain a cyclic shift of string s by k to the right. the rows are numbered from 0 to n−1 top-to-bottom. in the resulting table we need to find the rectangle consisting only of ones that has the largest area. we call a rectangle the set of all cells (i,j) in the table, such that x1≤i≤x2 and y1≤j≤y2 for some integers 0≤x1≤x2<n and 0≤y1≤y2<n . recall that the cyclic shift of string s by k to the right is the string sn−k+1…sns1s2…sn−k . for example, the cyclic shift of the string "01011" by 0 to the right is the string itself "01011", its cyclic shift by 3 to the right is the string "01101". input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤2⋅104 ) — the number of test cases. the description of test cases follows. the first and the only line of each test case contains a single binary string s ( 1≤|s|≤2⋅105 ), consisting of characters 0 and 1. it is guaranteed that the sum of string lengths |s| over all test cases does not exceed 2⋅105 . output for each test case, output a single integer — the maximum area of a rectangle consisting only of ones. if there is no such rectangle, output 0 . example input copy 5 0 1 101 011110 101010 output copy 0 1 2 6 1 note in the first test case, there is a table 1×1 consisting of a single character 0, so there are no rectangles consisting of ones, and the answer is 0 . in the second test case, there is a table 1×1 , consisting of a single character 1, so the answer is 1 . in the third test case, there is a table: 1 0 1 1 1 0 0 1 1 in the fourth test case, there is a table: 0 1 1 1 1 0 0 0 1 1 1 1 1 0 0 1 1 1 1 1 0 0 1 1 1 1 1 0 0 1 1 1 1 1 0 0 in the fifth test case, there is a table: 1 0 1 0 1 0 0 1 0 1 0 1 1 0 1 0 1 0 0 1 0 1 0 1 1 0 1 0 1 0 0 1 0 1 0 1 rectangles with maximum area are shown in bold.
luotianyi and the floating islands (hard version) time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output this is the hard version of the problem. the only difference is that in this version k≤n . you can make hacks only if both versions of the problem are solved. chtholly and the floating islands. luotianyi now lives in a world with n floating islands. the floating islands are connected by n−1 undirected air routes, and any two of them can reach each other by passing the routes. that means, the n floating islands form a tree. one day, luotianyi wants to meet her friends: chtholly, nephren, william, .... totally, she wants to meet k people. she doesn't know the exact positions of them, but she knows that they are in pairwise distinct islands. she define an island is good if and only if the sum of the distances † from it to the islands with k people is the minimal among all the n islands. now, luotianyi wants to know that, if the k people are randomly set in k distinct of the n islands, then what is the expect number of the good islands? you just need to tell her the expect number modulo 109+7 . † the distance between two islands is the minimum number of air routes you need to take to get from one island to the other. input the first line contains two integers n and k ( 1≤k≤n≤2⋅105 ) — the number of the islands and people respectively. next n−1 lines describe the air routes. the i -th of them contains two integers ui and vi ( 1≤ui,vi≤n,ui≠vi ) — the islands connected by the i -th air route. output print a single integer — the expect number of the good islands modulo 109+7 . formally, let m=109+7 . it can be shown that the answer can be expressed as an irreducible fraction p q , where p and q are integers and q≢0 ( modm ). output the integer equal to p⋅q−1 modm . in other words, output such an integer x that 0≤x<m and x⋅q≡p ( modm ). examples input copy 4 2 1 2 2 3 3 4 output copy 666666674 input copy 5 5 1 2 2 3 3 4 3 5 output copy 1 note in the first example the air routes form the following tree: if the people are in the islands 1 and 2 , then islands 1 and 2 will be good. the sum of the distances from island 1 or 2 to all the people is 1+0=1 , which is the minimal. while the sum of the distances from island 3 to all the people is 2+1=3 , which is greater than 1 . like this, when the people are in island 1 and 3 , then islands 1,2 and 3 will be good. when the people are in islands 1 and 4 , then islands 1,2,3 and 4 will be good. when the people are in islands 2 and 3 , then islands 2 and 3 will be good. when the people are in islands 2 and 4 , then islands 2,3 and 4 will be good. when the people are in islands 3 and 4 , then islands 3 and 4 will be good. so the expect of the number of the good islands is 16 6 , which equals to 666666674 modulo 109+7 . in the second example the air routes form the following tree: we can see that there is one person in each island, and only the island 3 is good. so the expect number is 1 .
removing graph time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output alice and bob are playing a game on a graph. they have an undirected graph without self-loops and multiple edges. all vertices of the graph have degree equal to 2 . the graph may consist of several components. note that if such graph has n vertices, it will have exactly n edges. alice and bob take turn. alice goes first. in each turn, the player can choose k ( l≤k≤r ; l<r ) vertices that form a connected subgraph and erase these vertices from the graph, including all incident edges. the player who can't make a step loses. for example, suppose they are playing on the given graph with given l=2 and r=3 : a valid vertex set for alice to choose at the first move is one of the following: {1,2} {1,3} {2,3} {4,5} {4,6} {5,6} {1,2,3} {4,5,6} suppose, alice chooses subgraph {4,6} . then a valid vertex set for bob to choose at the first move is one of the following: {1,2} {1,3} {2,3} {1,2,3} suppose, bob chooses subgraph {1,2,3} . alice can't make a move, so she loses. you are given a graph of size n and integers l and r . who will win if both alice and bob play optimally. input the first line contains three integers n , l and r ( 3≤n≤2⋅105 ; 1≤l<r≤n ) — the number of vertices in the graph, and the constraints on the number of vertices alice or bob can choose in one move. next n lines contains edges of the graph: one edge per line. the i -th line contains two integers ui and vi ( 1≤ui,vi≤n ; ui≠vi ) — description of the i -th edge. it's guaranteed that the degree of each vertex of the given graph is equal to 2 . output print alice (case-insensitive) if alice wins, or bob otherwise. examples input copy 6 2 3 1 2 2 3 3 1 4 5 5 6 6 4 output copy bob input copy 6 1 2 1 2 2 3 3 1 4 5 5 6 6 4 output copy bob input copy 12 1 3 1 2 2 3 3 1 4 5 5 6 6 7 7 4 8 9 9 10 10 11 11 12 12 8 output copy alice note in the first test the same input as in legend is shown. in the second test the same graph as in legend is shown, but with l=1 and r=2 .
the fox and the complete tree traversal time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output the fox yae climbed the tree of the sacred sakura. a tree is a connected undirected graph that does not contain cycles. the fox uses her magical powers to move around the tree. yae can jump from vertex v to another vertex u if and only if the distance between these vertices does not exceed 2 . in other words, in one jump yae can jump from vertex v to vertex u if vertices v and u are connected by an edge, or if there exists such vertex w that vertices v and w are connected by an edge, and also vertices u and w are connected by an edge. after yae was able to get the sakura petal, she wondered if there was a cyclic route in the tree v1,v2,…,vn such that: the fox can jump from vertex vi to vertex vi+1 , the fox can jump from vertex vn to vertex v1 , all vi are pairwise distinct. help the fox determine if the required traversal exists. input the first line contains one integer n ( 2≤n≤2⋅105 ) —the number of vertices of the tree. each of the following n−1 lines contains two integers u and v ( 1≤u,v≤n , u≠v ) — vertices connected by an edge. it is guaranteed that these edges form a tree. output on the first line, print "yes" (without quotes) if the required route of the tree exists, or "no" (without quotes) otherwise. if the required tree traversal exists, on the second line print n integers of different integers v1,v2,…,vn ( 1≤vi≤n ) — the vertices of the tree in traversal order. if there are several correct traversals, output any of them. examples input copy 5 1 2 1 3 3 4 3 5 output copy yes 4 5 1 2 3 input copy 3 1 2 1 3 output copy yes 1 2 3 input copy 15 1 2 1 3 2 4 2 5 3 6 3 7 4 8 4 9 5 10 5 11 6 12 6 13 7 14 7 15 output copy no note the tree from the first example is shown below. the bold arrows indicate the fox's route. in the second example, any sequence of three different vertices is a correct route, because the fox can jump from any vertex to any vertex. the tree from the third example is shown below. it can be shown that there is no required route for it.
counting orders time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given two arrays a and b each consisting of n integers. all elements of a are pairwise distinct. find the number of ways to reorder a such that ai>bi for all 1≤i≤n , modulo 109+7 . two ways of reordering are considered different if the resulting arrays are different. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains a single integer n ( 1≤n≤2⋅105 ) — the length of the array a and b . the second line of each test case contains n distinct integers a1 , a2 , … , an ( 1≤ai≤109 ) — the array a . it is guaranteed that all elements of a are pairwise distinct. the second line of each test case contains n integers b1 , b2 , … , bn ( 1≤bi≤109 ) — the array b . it is guaranteed that the sum of n over all test cases does not exceed 2⋅105 . output for each test case, output the number of ways to reorder array a such that ai>bi for all 1≤i≤n , modulo 109+7 . example input copy 5 6 9 6 8 4 5 2 4 1 5 6 3 1 3 4 3 2 3 4 9 1 2 1 3 2 3 4 1 3 3 12 2 3 7 10 23 28 29 50 69 135 420 1000 1 1 2 3 5 8 13 21 34 55 89 144 output copy 32 0 1 0 13824
hyperregular bracket strings time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are given an integer n and k intervals. the i -th interval is [li,ri] where 1≤li≤ri≤n . let us call a regular bracket sequence †,‡ of length n hyperregular if for each i such that 1≤i≤k , the substring ¯ slisli+1…sri is also a regular bracket sequence. your task is to count the number of hyperregular bracket sequences. since this number can be really large, you are only required to find it modulo 998244353 . † a bracket sequence is a string containing only the characters "(" and ")". ‡ a bracket sequence is called regular if one can turn it into a valid math expression by adding characters + and 1. for example, sequences (())(), (), (()(())) and the empty string are regular, while )(, ((), and (()))( are not. input each test contains multiple test cases. the first line of input contains a single integer t ( 1≤t≤105 ) — the number of test cases. the description of test cases follows. the first line of each test case contains two integers n and k ( 1≤n≤3⋅105 , 0≤k≤3⋅105 ) — the length of the hyperregular bracket sequences and the number of intervals respectively. the following k lines of each test case contains two integers li and ri ( 1≤l≤r≤n ). it is guaranteed that the sum of n across all test cases does not exceed 3⋅105 and the sum of k across all test cases does not exceed 3⋅105 . output for each test case, output the number of hyperregular bracket sequences modulo 998244353 . example input copy 7 6 0 5 0 8 1 1 3 10 2 3 4 6 9 1000 3 100 701 200 801 300 901 28 5 1 12 3 20 11 14 4 9 18 19 4 3 1 4 1 4 1 4 output copy 5 0 0 4 839415253 140 2 note for the first testcase, the 5 hyperregular bracket strings of length 6 are: ((())), (()()), (())(), ()(()) and ()()(). for the second testcase, there are no regular bracket strings of length 5 , and consequently, there are no hyperregular bracket strings of length 5 . for the third testcase, there are no hyperregular bracket strings of length 8 for which the substring [1…3] is a regular bracket string. for the fourth testcase, there 4 hyperregular bracket strings are: ((())(())), ((())()()), ()()((())) and ()()(()())
walk the runway time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output a fashion tour consists of m identical runway shows in different cities. there are n models willing to participate in the tour, numbered from 1 to n . people in different cities have different views on the fashion industry, so they rate each model differently. in particular, people in city i rate model j with rating ri,j . you are to choose some number of k models, and their order, let the chosen models have indices j1,j2,…,jk in the chosen order. in each city, these k models will walk the runway one after another in this order. to make the show exciting, in each city, the ratings of models should be strictly increasing in the order of their performance. more formally, for any city i and index t ( 2≤t≤k ), the ratings must satisfy ri,jt−1<ri,jt . after all, the fashion industry is all about money, so choosing model j to participate in the tour profits you pj money. compute the maximum total profit you can make by choosing the models and their order while satisfying all the requirements. input the first line contains two integers m and n ( 1≤m≤500 , 1≤n≤5000 ) — the number of shows and the number of models willing to participate respectively. the second line contains n integers pj ( 1≤pj≤109 ) — the profit you get inviting the j -th model to the tour. the next m lines each contain n integers. line number i contains n integers ri,j ( 1≤ri,j≤n ) — the ratings of models in city i . output output a single integer — the largest total amount of money you can get. examples input copy 3 5 10 10 10 10 10 1 2 3 4 5 1 5 2 3 4 2 3 4 5 1 output copy 30 input copy 3 5 10 10 10 10 50 1 2 3 4 5 1 5 2 3 4 2 3 4 5 1 output copy 50 input copy 1 1 1000000000 1 output copy 1000000000 input copy 5 5 1000000000 1000000000 1000000000 1000000000 1000000000 5 4 3 2 1 5 4 3 2 1 5 4 3 2 1 5 4 3 2 1 5 4 3 2 1 output copy 5000000000 input copy 1 3 1 2 3 3 3 3 output copy 3 note in the first example, there are 3 invited models. the show consists of models in the order [1,3,4] . then, the corresponding ratings in the cities are as follows: city 1 — [1,3,4] . city 2 — [1,2,3] . city 3 — [2,4,5] . you can see that the ratings are increasing. so the total profit is 10+10+10=30 . it can be proven that we can't achieve a bigger profit. in the second example, we can invite the fifth model to the tour, which would result in a total profit of 50 . it can be proven that we can't achieve a bigger profit. in the third example, we invite the single model to the tour, which results in a total profit of 1000000000 . in the fourth test case, we can invite all the models and make the show in the order [5,4,3,2,1] . the total profit is 5⋅1000000000=5000000000 .
constructive problem time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output as you know, any problem that does not require the use of complex data structures is considered constructive. you are offered to solve one of such problems. you are given an array a of n non-negative integers. you are allowed to perform the following operation exactly once: choose some non-empty subsegment al,al+1,…,ar of the array a and a non-negative integer k , and assign value k to all elements of the array on the chosen subsegment. the task is to find out whether mex(a) can be increased by exactly one by performing such an operation. in other words, if before the operation mex(a)=m held, then after the operation it must hold that mex(a)=m+1 . recall that mex of a set of integers c1,c2,…,ck is defined as the smallest non-negative integer x which does not occur in the set c . input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤50000 ) — the number of test cases. the description of the test cases follows. the first line of each test case contains a single integer n ( 1≤n≤200000 ) — the number of elements of array a . the second line of each test case contains n integers a1,a2,…,an ( 0≤ai≤109 ) — elements of array a . it is guaranteed that the sum n over all test cases does not exceed 200000 . output for each test case, print "yes" if you can increase mex(a) by exactly one by performing the operation from the statement exactly once, otherwise print "no". you can output the answer in any case (upper or lower). for example, the strings "yes", "yes", "yes", and "yes" will be recognized as positive responses. example input copy 4 3 1 2 1 4 0 2 2 0 4 3 2 0 2 1 0 output copy yes yes no no note in the first test case, mex(a)=0 . if you set all elements of a to 0 , then mex of the resulting array will be 1 , and thus will increase by one. in the second test case, mex(a)=1 . if we assign a value of 1 to the elements of a on a subsegment from 2 to 3 , we get an array [0,1,1,0] for which mex is 2 , and thus is increased by one compared to the original. it can be shown that in the third and fourth test cases it is impossible to perform an operation so that the value of mex(a) increases by exactly one.
roads in e city time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output this is an interactive problem. as is well known, the city "e" has never had its roads repaired in its a thousand and a half years old history. and only recently the city administration repaired some of them. it is known that in total in the city "e" there are n intersections and m roads, which can be used in both directions, numbered with integers from 1 to m . the i -th road connects intersections with numbers ai and bi . among all m roads, some subset of the roads has been repaired, but you do not know which one. the only information you could get from the city's road services is that you can get from any intersection to any other intersection by driving only on the roads that have been repaired. you are a young entrepreneur, and decided to organize a delivery service of fresh raw meat in the city "e" (in this city such meat is called "steaks", it is very popular among the locals). you have already recruited a staff of couriers, but the couriers are willing to travel only on repaired roads. now you have to find out which roads have already been repaired. the city administration has given you the city for a period of time, so you can make different queries of one of three types: block the road with the number x . in this case, movement on the road for couriers will be forbidden. initially all roads are unblocked. unblock the road with the number x . in this case, couriers will be able to move on the road x if it is repaired. try to deliver the order to the intersection with the number y . in this case, one of your couriers will start moving from intersection with number s you don't know and deliver the order to intersection with number y if there is a path on unblocked repaired roads from intersection s to intersection y . it is guaranteed that intersection s will be chosen beforehand. unfortunately, the city is placed at your complete disposal for a short period of time, so you can make no more than 100⋅m requests. input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. the description of test cases follows. the first line contains two integers n and m ( 2≤n≤2000 , n−1≤m≤2000 ) —the number of intersections and roads in the city "e". each of the following m lines describes one road. the i -th of these lines contains two integers ai and bi ( 1≤ai,bi≤n ) — the ends of the i -th road. it is guaranteed that no road connects the city to itself, while it is possible that there are several roads between a pair of different intersections. it is guaranteed that the sum of n and the sum of m over all test cases does not exceed 2000 . interaction once you have read the description of the test case, you can make queries. queries can be of three types: "- x " ( 1≤x≤m ). in this case the road with the number x is blocked if it has not already been blocked. "+ x " ( 1≤x≤m ). in this case the road with the number x is unblocked. note that road x must be blocked beforehand. all roads are initially unblocked. "? y " ( 1≤y≤n ). in this case the jury program chooses some city s . if you can get from town s to town y by unblocked repaired roads, the jury program will output 1 , otherwise the jury program will output 0 . note that city s will be selected before getting information about city y , but your previous requests may be taken into account when selecting city s . in total, you can make no more than 100⋅m queries for each set of input data. after you have found all repaired roads, output "! c1, c2, c3, …, cm ", where ci is 1 if road i is repaired, and 0 if road is not repaired. this output will not count in the total number of queries. the jury program will output 1 if your answer is correct, and 0 if the answer is not correct. if you received 0 , your program must terminate immediately to receive a wrong answer verdict. otherwise you can get any verdict, because the program will continue reading from the closed stream. if you read 1 , move on to the next test case, or terminate the program if there is none. note that you do not have to unblock all roads before outputting the answer. it is guaranteed that all repaired roads are fixed initially and will not be changed by the jury program depending on queries. after outputting a query or the answer do not forget to output the end of line and flush the output. otherwise, you will get idleness limit exceeded. to do this, use: fflush(stdout) or cout.flush() in c++; system.out.flush() in java; flush(output) in pascal; stdout.flush() in python; see the documentation for other languages. hacks you can't do hacks on this problem. example input copy 2 2 2 1 2 2 1 1 0 1 1 3 3 1 2 2 3 3 1 1 1 1 0 1 1 1 1 output copy - 1 ? 1 ? 2 - 2 + 1 ? 1 ! 1 0 - 1 ? 2 ? 1 - 2 ? 3 ? 3 + 1 ? 3 ? 2 ? 1 ! 1 1 1 note in the first test case, road 1 was repaired, while road 2 was not. for the first delivery request, intersection 1 was selected as s , and the path from intersection 1 to 1 exists. for the second delivery request, intersection 1 was selected as s . since the only repaired road was blocked, there was no path between intersections 1 and 2 . for the third delivery request, intersection 2 was selected as s , the path between intersections 2 and 1 exists along road 1 , which is repaired and unblocked. in the second test case, intersections 1 , 3 , 1 , 2 , 2 , 3 , 1 were selected as starting intersections for delivery requests.
restore the weather time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given an array a containing the weather forecast for berlandia for the last n days. that is, ai — is the estimated air temperature on day i ( 1≤i≤n ). you are also given an array b — the air temperature that was actually present on each of the days. however, all the values in array b are mixed up. determine which day was which temperature, if you know that the weather never differs from the forecast by more than k degrees. in other words, if on day i the real air temperature was c , then the equality |ai−c|≤k is always true. for example, let an array a = [ 1,3,5,3,9 ] of length n=5 and k=2 be given and an array b = [ 2,5,11,2,4 ]. then, so that the value of bi corresponds to the air temperature on day i , we can rearrange the elements of the array b so: [ 2,2,5,4,11 ]. indeed: on the 1 st day, |a1−b1|=|1−2|=1 , 1≤2=k is satisfied; on the 2 nd day |a2−b2|=|3−2|=1 , 1≤2=k is satisfied; on the 3 rd day, |a3−b3|=|5−5|=0 , 0≤2=k is satisfied; on the 4 th day, |a4−b4|=|3−4|=1 , 1≤2=k is satisfied; on the 5 th day, |a5−b5|=|9−11|=2 , 2≤2=k is satisfied. input the first line of input data contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of the test cases follows. the first line of each test case contains two integers n ( 1≤n≤105 ) and k ( 0≤k≤109 ) — the number of days and the maximum difference between the expected and actual air temperature on each day. the second line of each test case contains exactly n integers — elements of array a ( −109≤ai≤109 ). the third line of each test case contains exactly n integers — elements of array b ( −109≤bi≤109 ). it is guaranteed that the sum of n over all test cases does not exceed 105 , and that the elements of array b can always be rearranged so that the equality |ai−bi|≤k is true for all i . output on a separate line for each test case, output exactly n numbers — the values of air temperature on each of the days in the correct order. if there is more than one answer — output any of them. example input copy 3 5 2 1 3 5 3 9 2 5 11 2 4 6 1 -1 3 -2 0 -5 -1 -4 0 -1 4 0 0 3 3 7 7 7 9 4 8 output copy 2 2 5 4 11 0 4 -1 0 -4 0 8 4 9
tubetube feed time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output mushroom filippov cooked himself a meal and while having his lunch, he decided to watch a video on tubetube. he can not spend more than t seconds for lunch, so he asks you for help with the selection of video. the tubetube feed is a list of n videos, indexed from 1 to n . the i -th video lasts ai seconds and has an entertainment value bi . initially, the feed is opened on the first video, and mushroom can skip to the next video in 1 second (if the next video exists). mushroom can skip videos any number of times (including zero). help mushroom choose one video that he can open and watch in t seconds. if there are several of them, he wants to choose the most entertaining one. print the index of any appropriate video, or −1 if there is no such. input the first line of the input data contains a single integer q ( 1≤q≤1000 ) — the number of test cases in the test. the description of the test cases follows. the first line of a test case contains two integers n and t ( 1≤n≤50 , 1≤t≤200 ) — the number of videos in the feed and seconds for lunch, respectively. the second line of a test case contains n integers a1,a2,a3,…,an ( 1≤ai≤100 ) — durations of videos. the third line of a test case contains n integers b1,b2,b3,…,bn ( 1≤bi≤100 ) — entertainment values of videos. output output q integers, each of which is the answer to the corresponding test case. as an answer, output the index of the most entertaining video that mushroom will have time to watch. if there are several answers, you are allowed to output any of them. output −1 , if there is no video he can watch during his lunch break. example input copy 5 5 9 1 5 7 6 6 3 4 7 1 9 4 4 4 3 3 2 1 2 3 4 5 7 5 5 5 5 5 2 1 3 9 7 4 33 54 71 69 96 42 24 99 1 2 179 55 66 77 88 output copy 3 2 3 -1 2
flipper time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given a permutation p of length n . a permutation is an array consisting of n distinct integers from 1 to n in any order. for example, {2,3,1,5,4} is a permutation, while {1,2,2} is not (since 2 appears twice), and {1,3,4} is also not a permutation (as n=3 , but the array contains 4 ). to the permutation p , you need to apply the following operation exactly once: first you choose a segment [l,r] ( 1≤l≤r≤n , a segment is a continuous sequence of numbers {pl,pl+1,…,pr−1,pr} ) and reverse it. reversing a segment means swapping pairs of numbers (pl,pr) , (pl+1,pr−1) , ..., (pl+i,pr−i) (where l+i≤r−i ). then you swap the prefix and suffix: [r+1,n] and [1,l−1] (note that these segments may be empty). for example, given n=5,p={2,3,1,5,4} , if you choose the segment [l=2,r=3] , after reversing the segment p={2,1,3,5,4} , then you swap the segments [4,5] and [1,1] . thus, p={5,4,1,3,2} . it can be shown that this is the maximum possible result for the given permutation. you need to output the lexicographically maximum permutation that can be obtained by applying the operation described exactly once. a permutation a is lexicographically greater than permutation b if there exists an i ( 1≤i≤n ) such that aj=bj for 1≤j<i and ai>bi . input the first line of the input contains a single integer t ( 1≤t≤1000 ) — the number of test cases. then the descriptions of the test cases follow. the first line of each test case contains a single integer n ( 1≤n≤2000 ) — the size of the permutation. the second line of each test case contains n integers: p1,p2,…,pn ( 1≤pi≤n ) — the permutation p itself. it is guaranteed that the sum of n over all test cases does not exceed 2000 . output for each test case, output in a separate line the lexicographically maximum permutation of length n that can be obtained from p by applying the operation described in the problem exactly once. example input copy 9 5 2 3 1 5 4 9 4 1 6 7 2 8 5 3 9 4 4 3 2 1 2 2 1 6 3 2 4 1 5 6 7 3 2 1 5 7 6 4 10 10 2 5 6 1 9 3 8 4 7 4 4 2 1 3 1 1 output copy 5 4 1 3 2 9 4 1 6 7 2 8 5 3 3 2 1 4 1 2 6 5 3 2 4 1 7 6 4 5 3 2 1 9 3 8 4 7 1 10 2 5 6 3 4 2 1 1 note the first example is explained in the problem statement. in the second example, the segment [l=9,r=9] should be chosen. in the third example, the segment [l=1,r=1] should be chosen. in the fourth example, the segment [l=1,r=2] should be chosen. in the fifth example, the segment [l=5,r=6] should be chosen. in the sixth example, the segment [l=4,r=4] should be chosen. in the seventh example, the segment [l=5,r=5] should be chosen.
half-sum time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output you're given a multiset of non-negative integers {a1,a2,…,an} . in one step you take two elements x and y of the multiset, remove them and insert their mean value x+y 2 back into the multiset. you repeat the step described above until you are left with only two numbers a and b . what is the maximum possible value of their absolute difference |a−b| ? since the answer is not an integer number, output it modulo 109+7 . input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤100 ). description of the test cases follows. the first line of each test case contains a single integer n ( 2≤n≤106 ) — the size of the multiset. the second line contains n integers a1,a2,…,an ( 0≤ai≤109 ) — the elements of the multiset. it is guaranteed that the sum of n over all test cases does not exceed 106 . output for each test case, output a single integer, the answer to the problem modulo 109+7 . formally, let m=109+7 . it can be shown that the answer can be expressed as an irreducible fraction p q , where p and q are integers and q≢0(modm) . output the integer equal to p⋅q−1modm . in other words, output an integer x such that 0≤x<m and x⋅q≡p(modm) . example input copy 5 2 7 3 4 1 2 10 11 3 1 2 3 6 64 32 64 16 64 0 4 1 1 1 1 output copy 4 9 500000005 59 0 note in the first case, you can't do any operations, so the answer is |7−3|=4 . in the second case, one of the optimal sequence of operations: substitute 1 and 2 with 1.5 ; substitute 10 and 11 with 10.5 ; the difference between 1.5 and 10.5 is 9 . in the third case, the exact answer is 3 2 , and 500000005⋅2≡3(mod109+7) .
random walk time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are given a tree consisting of n vertices and n−1 edges, and each vertex v has a counter c(v) assigned to it. initially, there is a chip placed at vertex s and all counters, except c(s) , are set to 0 ; c(s) is set to 1 . your goal is to place the chip at vertex t . you can achieve it by a series of moves. suppose right now the chip is placed at the vertex v . in one move, you do the following: choose one of neighbors to of vertex v uniformly at random ( to is neighbor of v if and only if there is an edge {v,to} in the tree); move the chip to vertex to and increase c(to) by 1 ; you'll repeat the move above until you reach the vertex t . for each vertex v calculate the expected value of c(v) modulo 998244353 . input the first line contains three integers n , s and t ( 2≤n≤2⋅105 ; 1≤s,t≤n ; s≠t ) — number of vertices in the tree and the starting and finishing vertices. next n−1 lines contain edges of the tree: one edge per line. the i -th line contains two integers ui and vi ( 1≤ui,vi≤n ; ui≠vi ), denoting the edge between the nodes ui and vi . it's guaranteed that the given edges form a tree. output print n numbers: expected values of c(v) modulo 998244353 for each v from 1 to n . formally, let m=998244353 . it can be shown that the answer can be expressed as an irreducible fraction p q , where p and q are integers and q≢0(modm) . output the integer equal to p⋅q−1modm . in other words, output such an integer x that 0 \le x < m and x \cdot q \equiv p \pmod{m} . examples input copy 3 1 3 1 2 2 3 output copy 2 2 1 input copy 4 1 3 1 2 2 3 1 4 output copy 4 2 1 2 input copy 8 2 6 6 4 6 2 5 4 3 1 2 3 7 4 8 2 output copy 1 3 2 0 0 1 0 1 note the tree from the first example is shown below: let's calculate expected value e[c(1)] : p(c(1) = 0) = 0 , since c(1) is set to 1 from the start. p(c(1) = 1) = \frac{1}{2} , since there is the only one series of moves that leads c(1) = 1 . it's 1 \rightarrow 2 \rightarrow 3 with probability 1 \cdot \frac{1}{2} . p(c(1) = 2) = \frac{1}{4} : the only path is 1 \rightarrow_{1} 2 \rightarrow_{0.5} 1 \rightarrow_{1} 2 \rightarrow_{0.5} 3 . p(c(1) = 3) = \frac{1}{8} : the only path is 1 \rightarrow_{1} 2 \rightarrow_{0.5} 1 \rightarrow_{1} 2 \rightarrow_{0.5} 1 \rightarrow_{1} 2 \rightarrow_{0.5} 3 . p(c(1) = i) = \frac{1}{2^i} in general case. as a result, e[c(1)] = \sum\limits_{i=1}^{\infty}{i \frac{1}{2^i}} = 2 . image of tree in second test image of tree in third test
the third grace time limit per test5 seconds memory limit per test1024 megabytes inputstandard input outputstandard output you are given n intervals and m points on the number line. the i -th intervals covers coordinates [li,ri] and the i -th point is on coordinate i and has coefficient pi . initially, all points are not activated. you should choose a subset of the m points to activate. for each of n interval, we define its cost as: 0 , if there are no activated points in the interval; the coefficient of the activated point with the largest coordinate within it, otherwise. your task is to maximize the sum of the costs of all intervals by choosing which points to activate. input each test contains multiple test cases. the first line of input contains a single integer t ( 1≤t≤105 ) — the number of test cases. the description of test cases follows. the first line of each test case contains two integers n and m ( 1≤n≤106,1≤m≤106 ) — the number of intervals and the number of points. the following n lines of each test case contains two integers li and ri ( 1≤li≤ri≤m ) — the endpoints of the i -th interval. the following line of each test case contains m integers p1,p2,…,pm ( 0≤pi≤109 ) — the coefficients of the points. it is guaranteed that the sum of n does not exceed 106 and the sum of m does not exceed 106 . output output the maximum possible sum of costs of all intervals. example input copy 2 2 8 1 5 3 8 78 0 50 0 0 0 0 30 1 6 1 5 0 0 0 0 0 100 output copy 108 0 note in the first sample, we can activate points 1 and 8 . the sum of costs of all intervals will be 78+30=108 . in the second sample, we will activate no points. the sum of costs of all intervals will be 0 .
misha and apples time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output schoolboy misha got tired of doing sports programming, so he decided to quit everything and go to the magical forest to sell magic apples. his friend danya came to the magical forest to visit misha. what was his surprise when he found out that misha found a lot of friends there, the same former sports programmers. and all of them, like misha, have their own shop where they sell magic apples. to support his friends, who have changed their lives so drastically, he decided to buy up their entire assortment. the buying process works as follows: in total there are n stalls, numbered with integers from 1 to n , and m kinds of magic apples, numbered with integers from 1 to m . each shop sells some number of kinds of apples. danya visits all the shops in order of increasing number, starting with the first one. upon entering the shop he buys one magic apple of each kind sold in that shop and puts them in his backpack. however, magical apples wouldn't be magical if they were all right. the point is that when two apples of the same type end up together in the backpack, all of the apples in it magically disappear. importantly, the disappearance happens after danya has put the apples in the backpack and left the shop. upon returning home, danya realized that somewhere in the forest he had managed to lose his backpack. unfortunately, for some shops danya had forgotten what assortment of apples there was. remembering only for some shops, what kinds of magical apples were sold in them, he wants to know what is the maximum number of apples he could have in his backpack after all his purchases at best. input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤2⋅105 ) —the number of test cases. the description of test cases follows. the first line contains two integers n and m ( 1≤n,m≤2⋅105 ) —the number of stalls and kinds of apples. each of the following n lines describes the assortment of the next stall in the format described below. each line starts with an integer ki ( 0≤ki≤2⋅105 ). this is followed by ki of different integers aij ( 1≤aij≤m ) —the kinds of apples sold in the i -th stall. if ki=0 , then danya does not remember what assortment was in that shop, and the set of apple kinds can be anything (including empty). it is guaranteed that the sum of all ki over all test cases does not exceed 2⋅105 and the sum of n over all test cases does not exceed 2⋅105 output for each test case, output a single integer — the maximum number of apples that could be in dani's backpack after visiting all the shops at best. example input copy 4 3 4 2 1 2 2 4 1 2 1 2 4 4 2 1 2 2 3 4 0 1 1 2 5 0 0 5 3 0 3 1 2 3 2 3 1 0 1 3 output copy 2 1 5 3 note in the first test case, danya remembers all the shops, so the process will be deterministic. he will take two apples at the first shop and two more at the second, but after he puts them in his backpack, they will disappear. so at the end there will only be 2 apples left, which he will take at the third shop. in the second test case, if the third shop is empty, then after visiting the fourth shop all the apples will disappear. in any other case the apples will disappear after the third shop, and in the fourth shop dan can take one apple, so the answer is 1 . in the third test case, the first shop may sell all kinds of apples, and the second shop may sell nothing. then all 5 apples will be left at the end.
indivisible time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you're given a positive integer n . find a permutation a1,a2,…,an such that for any 1≤l<r≤n , the sum al+al+1+⋯+ar is not divisible by r−l+1 . a permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. for example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation ( 2 appears twice in the array), and [1,3,4] is also not a permutation ( n=3 but there is 4 in the array). input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤100 ). description of the test cases follows. the first line of each test case contain a single integer n ( 1≤n≤100 ) — the size of the desired permutation. output for each test case, if there is no such permutation print −1 . otherwise, print n distinct integers p1,p2,…,pn ( 1≤pi≤n ) — a permutation satisfying the condition described in the statement. if there are multiple solutions, print any. example input copy 3 1 2 3 output copy 1 1 2 -1 note in the first example, there are no valid pairs of l<r , meaning that the condition is true for all such pairs. in the second example, the only valid pair is l=1 and r=2 , for which a1+a2=1+2=3 is not divisible by r−l+1=2 . in the third example, for l=1 and r=3 the sum a1+a2+a3 is always 6 , which is divisible by 3 .
fading into fog time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output this is an interactive problem. there are n distinct hidden points with real coordinates on a two-dimensional euclidean plane. in one query, you can ask some line ax+by+c=0 and get the projections of all n points to this line in some order. the given projections are not exact, please read the interaction section for more clarity. using the minimum number of queries, guess all n points and output them in some order. here minimality means the minimum number of queries required to solve any possible test case with n points. the hidden points are fixed in advance and do not change throughout the interaction. in other words, the interactor is not adaptive. a projection of point a to line ax+by+c=0 is the point on the line closest to a . input the first line contains a single integer t ( 1≤t≤50 ) — the number of test cases. the description of the test cases follows. the first line of each test case contains a single integer n ( 2≤n≤25 ) — the number of hidden points. for each test case, it is guaranteed that for any pair of hidden points, their x coordinates differ by at least 1 . analogously, y coordinates of any pair also differ by at least 1 . coordinates x and y of all hidden points do not exceed 100 by absolute value. interaction to query a line ax+by+c=0 you should print "? a b c" where all a, b and c are real numbers up to 100 by absolute value. for less precision issues numbers a and b must satisfy the condition |a|+|b|≥0.1 , where |a| is the absolute value of a . as an answer to the query you will get n points in the form "x_1 y_1 ... x_n y_n", where points (xi,yi) are projections to the line ax+by+c=0 . it is guaranteed that each printed point is no more than 10−4 away from the real projection point. every coordinate is printed with at most 9 decimal places. see the interaction example for more clarity. if you ask too many queries, you will get wrong answer. to output an answer you should print "! x_1 y_1 ... x_n y_n", where (xi,yi) are coordinates of the hidden points. you could output the hidden points in any order. the answer would be considered correct if each of the printed points is no more than 10−3 away from the corresponding hidden point. printing the answer doesn't count as a query. after printing a query or the answer, do not forget to output end of line and flush the output. otherwise, you will get idleness limit exceeded. to do this, use: fflush(stdout) or cout.flush() in c++; system.out.flush() in java; flush(output) in pascal; stdout.flush() in python; see the documentation for other languages hacks to make a hack, use the following test format. in the first line output a single integer t ( 1≤t≤50 ) — the number of test cases. the description of the test cases follows. in the first line of each test case output a single integer n ( 2≤n≤25 ). in the next n lines output two rational numbers each. the numbers in line i should correspond to xi and yi respectively. printed points must comply with all constraints from the input section. example input copy 1 2 1 1 2.5 1 1.500000001 1.500000000 2 2 output copy ? 0 1 -1 ? 0.2 -0.2 0 ! 1 3 2.5 0.500000001 note in the sample the hidden points are (1,3) and (2.5,0.5) a picture, which describes the first query: a picture, which describes the second query:
blank space time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given a binary array a of n elements, a binary array is an array consisting only of 0 s and 1 s. a blank space is a segment of consecutive elements consisting of only 0 s. your task is to find the length of the longest blank space. input the first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. the first line of each test case contains a single integer n ( 1≤n≤100 ) — the length of the array. the second line of each test case contains n space-separated integers ai ( 0≤ai≤1 ) — the elements of the array. output for each test case, output a single integer — the length of the longest blank space. example input copy 5 5 1 0 0 1 0 4 0 1 1 1 1 0 3 1 1 1 9 1 0 0 0 1 0 0 0 1 output copy 2 1 1 0 3
palindrome partition time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output a substring is a continuous and non-empty segment of letters from a given string, without any reorders. an even palindrome is a string that reads the same backward as forward and has an even length. for example, strings "zz", "abba", "abccba" are even palindromes, but strings "codeforces", "reality", "aba", "c" are not. a beautiful string is an even palindrome or a string that can be partitioned into some smaller even palindromes. you are given a string s , consisting of n lowercase latin letters. count the number of beautiful substrings of s . input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains a single integer n ( 1≤n≤5⋅105 ). the second line of each test case contains a string s . string s consists of only lowercase latin letters and has a length of n . it is guaranteed that the sum of n over all test cases does not exceed 5⋅105 . output for each test case print the number of beautiful substrings. example input copy 6 6 abaaba 1 a 2 aa 6 abcdef 12 accabccbacca 6 abbaaa output copy 3 0 1 0 14 6 note in the first test case, the beautiful substrings are "abaaba", "baab", "aa". in the last test case, the beautiful substrings are "aa" (counted twice), "abba", "bb", "bbaa", "abbaaa".
combinatorics problem time limit per test4 seconds memory limit per test1024 megabytes inputstandard input outputstandard output recall that the binomial coefficient ( x y ) is calculated as follows ( x and y are non-negative integers): if x<y , then ( x y )=0 ; otherwise, ( x y )= x! y!⋅(x−y)! . you are given an array a1,a2,…,an and an integer k . you have to calculate a new array b1,b2,…,bn , where b1=(( 1 k )⋅a1)mod998244353 ; b2=(( 2 k )⋅a1+( 1 k )⋅a2)mod998244353 ; b3=(( 3 k )⋅a1+( 2 k )⋅a2+( 1 k )⋅a3)mod998244353 , and so on. formally, bi=( i ∑ j=1 ( i−j+1 k )⋅aj)mod998244353 . note that the array is given in a modified way, and you have to output it in a modified way as well. input the only line of the input contains six integers n , a1 , x , y , m and k ( 1≤n≤107 ; 0≤a1,x,y<m ; 2≤m≤998244353 ; 1≤k≤5 ). the array [a1,a2,…,an] is generated as follows: a1 is given in the input; for 2≤i≤n , ai=(ai−1⋅x+y)modm . output since outputting up to 107 integers might be too slow, you have to do the following: let ci=bi⋅i (without taking modulo 998244353 after the multiplication). print the integer c1⊕c2⊕⋯⊕cn , where ⊕ denotes the bitwise xor operator. example input copy 5 8 2 3 100 2 output copy 1283
luotianyi and the table time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output luotianyi gave an array b of n⋅m integers. she asks you to construct a table a of size n×m , filled with these n⋅m numbers, and each element of the array must be used exactly once. also she asked you to maximize the following value: n ∑ i=1 m ∑ j=1 ( max 1≤x≤i,1≤y≤j ax,y− min 1≤x≤i,1≤y≤j ax,y) this means that we consider n⋅m subtables with the upper left corner in (1,1) and the bottom right corner in (i,j) ( 1≤i≤n , 1≤j≤m ), for each such subtable calculate the difference of the maximum and minimum elements in it, then sum up all these differences. you should maximize the resulting sum. help her find the maximal possible value, you don't need to reconstruct the table itself. input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤200 ) — the number of test cases. the description of test cases follows. the first line of each test case contains two integers n and m ( 2≤n,m≤100 ) — the number of rows and columns of the table. the second line of each test case contains n⋅m integers b1,b2,…,bn⋅m ( −105≤bi≤105 ) — the numbers you can put in the table. note, that integers in the array b can be negative. it is guaranteed that the sum of n⋅m over all test cases doesn't exceed 2⋅105 . output for each test case, output a single integer — the maximal value, that can be obtained. example input copy 5 2 2 1 3 1 4 2 2 -1 -1 -1 -1 2 3 7 8 9 -3 10 8 3 2 4 8 -3 0 -7 1 4 3 -32030 59554 16854 -85927 68060 -64460 -79547 90932 85063 82703 -12001 38762 output copy 9 0 64 71 1933711 note in the first test case, the table is follows: 4 1 1 3 in the subtable with the bottom right corner in (1,1) , the difference of the maximal and minimal elements is 4−4=0 . in the subtable with the bottom right corner in (1,2) , the difference of the maximal and minimal elements is 4−1=3 . in the subtable with the bottom right corner in (2,1) , the difference of the maximal and minimal elements is 4−1=3 . in the subtable with the bottom right corner in (2,2) , the difference of the maximal and minimal elements is 4−1=3 . then the maximum possible value is 0+3+3+3=9 . in the second test case, all elements are equal, so all differences are 0 , and the answer is 0 .
hits different time limit per test2.5 seconds memory limit per test256 megabytes inputstandard input outputstandard output in a carnival game, there is a huge pyramid of cans with 2023 rows, numbered in a regular pattern as shown. if can 92 is hit initially, then all cans colored red in the picture above would fall. you throw a ball at the pyramid, and it hits a single can with number n2 . this causes all cans that are stacked on top of this can to fall (that is, can n2 falls, then the cans directly above n2 fall, then the cans directly above those cans, and so on). for example, the picture above shows the cans that would fall if can 92 is hit. what is the sum of the numbers on all cans that fall? recall that n2=n×n . input the first line contains an integer t ( 1≤t≤1000 ) — the number of test cases. the only line of each test case contains a single integer n ( 1≤n≤106 ) — it means that the can you hit has label n2 . output for each test case, output a single integer — the sum of the numbers on all cans that fall. please note, that the answer for some test cases won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like long long for c++). for all valid inputs, the answer will always fit into 64-bit integer type. example input copy 10 9 1 2 3 4 5 6 10 1434 1000000 output copy 156 1 5 10 21 39 46 146 63145186 58116199242129511 note the first test case is pictured in the statement. the sum of the numbers that fall is 12+22+32+52+62+92=1+4+9+25+36+81=156. in the second test case, only the can labeled 12 falls, so the answer is 12=1 . in the third test case, the cans labeled 12 and 22 fall, so the answer is 12+22=1+4=5 . in the fourth test case, the cans labeled 12 and 32 fall, so the answer is 12+32=1+9=10 . in the fifth test case, the cans labeled 12 , 22 , and 42 fall, so the answer is 12+22+42=1+4+16=21 .
the lakes time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are given an n×m grid a of non-negative integers. the value ai,j represents the depth of water at the i -th row and j -th column. a lake is a set of cells such that: each cell in the set has ai,j>0 , and there exists a path between any pair of cells in the lake by going up, down, left, or right a number of times and without stepping on a cell with ai,j=0 . the volume of a lake is the sum of depths of all the cells in the lake. find the largest volume of a lake in the grid. input the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the first line of each test case contains two integers n,m ( 1≤n,m≤1000 ) — the number of rows and columns of the grid, respectively. then n lines follow each with m integers ai,j ( 0≤ai,j≤1000 ) — the depth of the water at each cell. it is guaranteed that the sum of n⋅m over all test cases does not exceed 106 . output for each test case, output a single integer — the largest volume of a lake in the grid. example input copy 5 3 3 1 2 0 3 4 0 0 0 5 1 1 0 3 3 0 1 1 1 0 1 1 1 1 5 5 1 1 1 1 1 1 0 0 0 1 1 0 5 0 1 1 0 0 0 1 1 1 1 1 1 5 5 1 1 1 1 1 1 0 0 0 1 1 1 4 0 1 1 0 0 0 1 1 1 1 1 1 output copy 10 0 7 16 21
magic triples (hard version) time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output this is the hard version of the problem. the only difference is that in this version, ai≤109 . for a given sequence of n integers a , a triple (i,j,k) is called magic if: 1≤i,j,k≤n . i , j , k are pairwise distinct. there exists a positive integer b such that ai⋅b=aj and aj⋅b=ak . kolya received a sequence of integers a as a gift and now wants to count the number of magic triples for it. help him with this task! note that there are no constraints on the order of integers i , j and k . input the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of the test cases follows. the first line of the test case contains a single integer n ( 3≤n≤2⋅105 ) — the length of the sequence. the second line of the test contains n integers a1,a2,a3,…,an ( 1≤ai≤109 ) — the elements of the sequence a . the sum of n over all test cases does not exceed 2⋅105 . output for each test case, output a single integer — the number of magic triples for the sequence a . example input copy 7 5 1 7 7 2 7 3 6 2 18 9 1 2 3 4 5 6 7 8 9 4 1000 993 986 179 7 1 10 100 1000 10000 100000 1000000 8 1 1 2 2 4 4 8 8 9 1 1 1 2 2 2 4 4 4 output copy 6 1 3 0 9 16 45 note in the first example, there are 6 magic triples for the sequence a — (2,3,5) , (2,5,3) , (3,2,5) , (3,5,2) , (5,2,3) , (5,3,2) . in the second example, there is a single magic triple for the sequence a — (2,1,3) .
flipper time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given a permutation p of length n . a permutation is an array consisting of n distinct integers from 1 to n in any order. for example, {2,3,1,5,4} is a permutation, while {1,2,2} is not (since 2 appears twice), and {1,3,4} is also not a permutation (as n=3 , but the array contains 4 ). to the permutation p , you need to apply the following operation exactly once: first you choose a segment [l,r] ( 1≤l≤r≤n , a segment is a continuous sequence of numbers {pl,pl+1,…,pr−1,pr} ) and reverse it. reversing a segment means swapping pairs of numbers (pl,pr) , (pl+1,pr−1) , ..., (pl+i,pr−i) (where l+i≤r−i ). then you swap the prefix and suffix: [r+1,n] and [1,l−1] (note that these segments may be empty). for example, given n=5,p={2,3,1,5,4} , if you choose the segment [l=2,r=3] , after reversing the segment p={2,1,3,5,4} , then you swap the segments [4,5] and [1,1] . thus, p={5,4,1,3,2} . it can be shown that this is the maximum possible result for the given permutation. you need to output the lexicographically maximum permutation that can be obtained by applying the operation described exactly once. a permutation a is lexicographically greater than permutation b if there exists an i ( 1≤i≤n ) such that aj=bj for 1≤j<i and ai>bi . input the first line of the input contains a single integer t ( 1≤t≤1000 ) — the number of test cases. then the descriptions of the test cases follow. the first line of each test case contains a single integer n ( 1≤n≤2000 ) — the size of the permutation. the second line of each test case contains n integers: p1,p2,…,pn ( 1≤pi≤n ) — the permutation p itself. it is guaranteed that the sum of n over all test cases does not exceed 2000 . output for each test case, output in a separate line the lexicographically maximum permutation of length n that can be obtained from p by applying the operation described in the problem exactly once. example input copy 9 5 2 3 1 5 4 9 4 1 6 7 2 8 5 3 9 4 4 3 2 1 2 2 1 6 3 2 4 1 5 6 7 3 2 1 5 7 6 4 10 10 2 5 6 1 9 3 8 4 7 4 4 2 1 3 1 1 output copy 5 4 1 3 2 9 4 1 6 7 2 8 5 3 3 2 1 4 1 2 6 5 3 2 4 1 7 6 4 5 3 2 1 9 3 8 4 7 1 10 2 5 6 3 4 2 1 1 note the first example is explained in the problem statement. in the second example, the segment [l=9,r=9] should be chosen. in the third example, the segment [l=1,r=1] should be chosen. in the fourth example, the segment [l=1,r=2] should be chosen. in the fifth example, the segment [l=5,r=6] should be chosen. in the sixth example, the segment [l=4,r=4] should be chosen. in the seventh example, the segment [l=5,r=5] should be chosen.
gold rush time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output initially you have a single pile with n gold nuggets. in an operation you can do the following: take any pile and split it into two piles, so that one of the resulting piles has exactly twice as many gold nuggets as the other. (all piles should have an integer number of nuggets.) one possible move is to take a pile of size 6 and split it into piles of sizes 2 and 4 , which is valid since 4 is twice as large as 2 . can you make a pile with exactly m gold nuggets using zero or more operations? input the first line contains an integer t ( 1≤t≤1000 ) — the number of test cases. the only line of each test case contains two integers n and m ( 1≤n,m≤107 ) — the starting and target pile sizes, respectively. output for each test case, output "yes" if you can make a pile of size exactly m , and "no" otherwise. you can output the answer in any case (for example, the strings "yes", "yes", "yes" and "yes" will be recognized as a positive answer). example input copy 11 6 4 9 4 4 2 18 27 27 4 27 2 27 10 1 1 3 1 5 1 746001 2984004 output copy yes yes no no yes yes no yes yes no no note the first test case is pictured in the statement. we can make a pile of size 4 . in the second test case, we can perform the following operations: {9}→{6,3}→{4,2,3} . the pile that is split apart is colored red before each operation. in the third test case, we can't perform a single operation. in the fourth test case, we can't end up with a larger pile than we started with.
lunatic never content time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output you have an array a of n non-negative integers. let's define f(a,x)=[a1modx,a2modx,…,anmodx] for some positive integer x . find the biggest x , such that f(a,x) is a palindrome. here, amodx is the remainder of the integer division of a by x . an array is a palindrome if it reads the same backward as forward. more formally, an array a of length n is a palindrome if for every i ( 1≤i≤n ) ai=an−i+1 . input the first line contains a single integer t ( 1≤t≤105 ) — the number of test cases. the first line of each test case contains a single integer n ( 1≤n≤105 ). the second line of each test case contains n integers ai ( 0≤ai≤109 ). it's guaranteed that the sum of all n does not exceed 105 . output for each test case output the biggest x , such that f(a,x) is a palindrome. if x can be infinitely large, output 0 instead. example input copy 4 2 1 2 8 3 0 1 2 0 3 2 1 1 0 3 100 1 1000000000 output copy 1 2 0 999999900 note in the first example, f(a,x=1)=[0,0] which is a palindrome. in the second example, f(a,x=2)=[1,0,1,0,0,1,0,1] which is a palindrome. it can be proven that in the first two examples, no larger x satisfies the condition. in the third example, f(a,x)=[0] for any x , so we can choose it infinitely large, so the answer is 0 .
ira and flamenco time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output ira loves spanish flamenco dance very much. she decided to start her own dance studio and found n students, i th of whom has level ai . ira can choose several of her students and set a dance with them. so she can set a huge number of dances, but she is only interested in magnificent dances. the dance is called magnificent if the following is true: exactly m students participate in the dance; levels of all dancers are pairwise distinct; levels of every two dancers have an absolute difference strictly less than m . for example, if m=3 and a=[4,2,2,3,6] , the following dances are magnificent (students participating in the dance are highlighted in red): [4,2,2,3,6] , [4,2,2,3,6] . at the same time dances [4,2,2,3,6] , [4,2,2,3,6] , [4,2,2,3,6] are not magnificent. in the dance [4,2,2,3,6] only 2 students participate, although m=3 . the dance [4,2,2,3,6] involves students with levels 2 and 2 , although levels of all dancers must be pairwise distinct. in the dance [4,2,2,3,6] students with levels 3 and 6 participate, but |3−6|=3 , although m=3 . help ira count the number of magnificent dances that she can set. since this number can be very large, count it modulo 109+7 . two dances are considered different if the sets of students participating in them are different. input the first line contains a single integer t ( 1≤t≤104 ) — number of testcases. the first line of each testcase contains integers n and m ( 1≤m≤n≤2⋅105 ) — the number of ira students and the number of dancers in the magnificent dance. the second line of each testcase contains n integers a1,a2,…,an ( 1≤ai≤109 ) — levels of students. it is guaranteed that the sum of n over all testcases does not exceed 2⋅105 . output for each testcase, print a single integer — the number of magnificent dances. since this number can be very large, print it modulo 109+7 . example input copy 9 7 4 8 10 10 9 6 11 7 5 3 4 2 2 3 6 8 2 1 5 2 2 3 1 3 3 3 3 3 3 3 5 1 3 4 3 10 7 12 3 5 2 1 1 4 3 5 5 5 2 7 5 1 1 1 3 2 1 2 3 2 2 1 2 output copy 5 2 10 0 5 11 1 2 1 note in the first testcase, ira can set such magnificent dances: [8,10,10,9,6,11,7] , [8,10,10,9,6,11,7] , [8,10,10,9,6,11,7] , [8,10,10,9,6,11,7] , [8,10,10,9,6,11,7] . the second testcase is explained in the statements.
oh no1 (-2-3-4) time limit per test4 seconds memory limit per test512 megabytes inputstandard input outputstandard output you are given an undirected graph with n vertices and 3m edges. the graph may contain multi-edges, but does not contain self-loops. the graph satisfies the following property: the given edges can be divided into m groups of 3 , such that each group is a triangle. a triangle is defined as three edges (a,b) , (b,c) and (c,a) for some three distinct vertices a,b,c ( 1≤a,b,c≤n ). initially, each vertex v has a non-negative integer weight av . for every edge (u,v) in the graph, you should perform the following operation exactly once: choose an integer x between 1 and 4 . then increase both au and av by x . after performing all operations, the following requirement should be satisfied: if u and v are connected by an edge, then au≠av . it can be proven this is always possible under the constraints of the task. output a way to do so, by outputting the choice of x for each edge. it is easy to see that the order of operations does not matter. if there are multiple valid answers, output any. input the first line contains a single integer t ( 1≤t≤105 ) — the number of test cases. the description of test cases follows. the first line of each test case contains two integers n and m ( 3≤n≤106 , 1≤m≤4⋅105 ) — denoting the graph have n vertices and 3m edges. the second line of each test case contains n integers a1,a2,…,an ( 0≤ai≤106 ) — the initial weights of each vertex. then m lines follow. the i -th line contains three integers ai , bi , ci ( 1≤ai<bi<ci≤n ) — denotes that three edges (ai,bi) , (bi,ci) and (ci,ai) . note that the graph may contain multi-edges: a pair (x,y) may appear in multiple triangles. it is guaranteed that the sum of n over all test cases does not exceed 106 and the sum of m over all test cases does not exceed 4⋅105 . output for each test case, output m lines of 3 integers each. the i -th line should contains three integers eab,ebc,eca ( 1≤eab,ebc,eca≤4 ), denoting the choice of value x for edges (ai,bi) , (bi,ci) and (ci,ai) respectively. example input copy 4 4 1 0 0 0 0 1 2 3 5 2 0 0 0 0 0 1 2 3 1 4 5 4 4 3 4 5 6 1 2 3 1 2 4 1 3 4 2 3 4 5 4 0 1000000 412 412 412 1 2 3 1 4 5 2 4 5 3 4 5 output copy 2 1 3 2 3 3 4 3 3 3 1 2 2 2 3 2 3 4 3 1 1 2 3 4 1 2 4 4 4 3 4 1 1 note in the first test case, the initial weights are [0,0,0,0] . we have added values as follows: added 2 to vertices 1 and 2 added 1 to vertices 2 and 3 added 3 to vertices 3 and 1 the final weights are [5,3,4,0] . the output is valid because a1≠a2 , a1≠a3 , a2≠a3 , and that all chosen values are between 1 and 4 . in the second test case, the initial weights are [0,0,0,0,0] . the weights after the operations are [12,5,6,7,6] . the output is valid because a1≠a2 , a1≠a3 , a2≠a3 , and that a1≠a4 , a1≠a5 , a4≠a5 , and that all chosen values are between 1 and 4 . in the third test case, the initial weights are [3,4,5,6] . the weights after the operations are [19,16,17,20] , and all final weights are distinct, which means no two adjacent vertices have the same weight.
half-sum time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output you're given a multiset of non-negative integers {a1,a2,…,an} . in one step you take two elements x and y of the multiset, remove them and insert their mean value x+y 2 back into the multiset. you repeat the step described above until you are left with only two numbers a and b . what is the maximum possible value of their absolute difference |a−b| ? since the answer is not an integer number, output it modulo 109+7 . input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤100 ). description of the test cases follows. the first line of each test case contains a single integer n ( 2≤n≤106 ) — the size of the multiset. the second line contains n integers a1,a2,…,an ( 0≤ai≤109 ) — the elements of the multiset. it is guaranteed that the sum of n over all test cases does not exceed 106 . output for each test case, output a single integer, the answer to the problem modulo 109+7 . formally, let m=109+7 . it can be shown that the answer can be expressed as an irreducible fraction p q , where p and q are integers and q≢0(modm) . output the integer equal to p⋅q−1modm . in other words, output an integer x such that 0≤x<m and x⋅q≡p(modm) . example input copy 5 2 7 3 4 1 2 10 11 3 1 2 3 6 64 32 64 16 64 0 4 1 1 1 1 output copy 4 9 500000005 59 0 note in the first case, you can't do any operations, so the answer is |7−3|=4 . in the second case, one of the optimal sequence of operations: substitute 1 and 2 with 1.5 ; substitute 10 and 11 with 10.5 ; the difference between 1.5 and 10.5 is 9 . in the third case, the exact answer is 3 2 , and 500000005⋅2≡3(mod109+7) .
fading into fog time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output this is an interactive problem. there are n distinct hidden points with real coordinates on a two-dimensional euclidean plane. in one query, you can ask some line ax+by+c=0 and get the projections of all n points to this line in some order. the given projections are not exact, please read the interaction section for more clarity. using the minimum number of queries, guess all n points and output them in some order. here minimality means the minimum number of queries required to solve any possible test case with n points. the hidden points are fixed in advance and do not change throughout the interaction. in other words, the interactor is not adaptive. a projection of point a to line ax+by+c=0 is the point on the line closest to a . input the first line contains a single integer t ( 1≤t≤50 ) — the number of test cases. the description of the test cases follows. the first line of each test case contains a single integer n ( 2≤n≤25 ) — the number of hidden points. for each test case, it is guaranteed that for any pair of hidden points, their x coordinates differ by at least 1 . analogously, y coordinates of any pair also differ by at least 1 . coordinates x and y of all hidden points do not exceed 100 by absolute value. interaction to query a line ax+by+c=0 you should print "? a b c" where all a, b and c are real numbers up to 100 by absolute value. for less precision issues numbers a and b must satisfy the condition |a|+|b|≥0.1 , where |a| is the absolute value of a . as an answer to the query you will get n points in the form "x_1 y_1 ... x_n y_n", where points (xi,yi) are projections to the line ax+by+c=0 . it is guaranteed that each printed point is no more than 10−4 away from the real projection point. every coordinate is printed with at most 9 decimal places. see the interaction example for more clarity. if you ask too many queries, you will get wrong answer. to output an answer you should print "! x_1 y_1 ... x_n y_n", where (xi,yi) are coordinates of the hidden points. you could output the hidden points in any order. the answer would be considered correct if each of the printed points is no more than 10−3 away from the corresponding hidden point. printing the answer doesn't count as a query. after printing a query or the answer, do not forget to output end of line and flush the output. otherwise, you will get idleness limit exceeded. to do this, use: fflush(stdout) or cout.flush() in c++; system.out.flush() in java; flush(output) in pascal; stdout.flush() in python; see the documentation for other languages hacks to make a hack, use the following test format. in the first line output a single integer t ( 1≤t≤50 ) — the number of test cases. the description of the test cases follows. in the first line of each test case output a single integer n ( 2≤n≤25 ). in the next n lines output two rational numbers each. the numbers in line i should correspond to xi and yi respectively. printed points must comply with all constraints from the input section. example input copy 1 2 1 1 2.5 1 1.500000001 1.500000000 2 2 output copy ? 0 1 -1 ? 0.2 -0.2 0 ! 1 3 2.5 0.500000001 note in the sample the hidden points are (1,3) and (2.5,0.5) a picture, which describes the first query: a picture, which describes the second query:
the lakes time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are given an n×m grid a of non-negative integers. the value ai,j represents the depth of water at the i -th row and j -th column. a lake is a set of cells such that: each cell in the set has ai,j>0 , and there exists a path between any pair of cells in the lake by going up, down, left, or right a number of times and without stepping on a cell with ai,j=0 . the volume of a lake is the sum of depths of all the cells in the lake. find the largest volume of a lake in the grid. input the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the first line of each test case contains two integers n,m ( 1≤n,m≤1000 ) — the number of rows and columns of the grid, respectively. then n lines follow each with m integers ai,j ( 0≤ai,j≤1000 ) — the depth of the water at each cell. it is guaranteed that the sum of n⋅m over all test cases does not exceed 106 . output for each test case, output a single integer — the largest volume of a lake in the grid. example input copy 5 3 3 1 2 0 3 4 0 0 0 5 1 1 0 3 3 0 1 1 1 0 1 1 1 1 5 5 1 1 1 1 1 1 0 0 0 1 1 0 5 0 1 1 0 0 0 1 1 1 1 1 1 5 5 1 1 1 1 1 1 0 0 0 1 1 1 4 0 1 1 0 0 0 1 1 1 1 1 1 output copy 10 0 7 16 21
luotianyi and the floating islands (hard version) time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output this is the hard version of the problem. the only difference is that in this version k≤n . you can make hacks only if both versions of the problem are solved. chtholly and the floating islands. luotianyi now lives in a world with n floating islands. the floating islands are connected by n−1 undirected air routes, and any two of them can reach each other by passing the routes. that means, the n floating islands form a tree. one day, luotianyi wants to meet her friends: chtholly, nephren, william, .... totally, she wants to meet k people. she doesn't know the exact positions of them, but she knows that they are in pairwise distinct islands. she define an island is good if and only if the sum of the distances † from it to the islands with k people is the minimal among all the n islands. now, luotianyi wants to know that, if the k people are randomly set in k distinct of the n islands, then what is the expect number of the good islands? you just need to tell her the expect number modulo 109+7 . † the distance between two islands is the minimum number of air routes you need to take to get from one island to the other. input the first line contains two integers n and k ( 1≤k≤n≤2⋅105 ) — the number of the islands and people respectively. next n−1 lines describe the air routes. the i -th of them contains two integers ui and vi ( 1≤ui,vi≤n,ui≠vi ) — the islands connected by the i -th air route. output print a single integer — the expect number of the good islands modulo 109+7 . formally, let m=109+7 . it can be shown that the answer can be expressed as an irreducible fraction p q , where p and q are integers and q≢0 ( modm ). output the integer equal to p⋅q−1 modm . in other words, output such an integer x that 0≤x<m and x⋅q≡p ( modm ). examples input copy 4 2 1 2 2 3 3 4 output copy 666666674 input copy 5 5 1 2 2 3 3 4 3 5 output copy 1 note in the first example the air routes form the following tree: if the people are in the islands 1 and 2 , then islands 1 and 2 will be good. the sum of the distances from island 1 or 2 to all the people is 1+0=1 , which is the minimal. while the sum of the distances from island 3 to all the people is 2+1=3 , which is greater than 1 . like this, when the people are in island 1 and 3 , then islands 1,2 and 3 will be good. when the people are in islands 1 and 4 , then islands 1,2,3 and 4 will be good. when the people are in islands 2 and 3 , then islands 2 and 3 will be good. when the people are in islands 2 and 4 , then islands 2,3 and 4 will be good. when the people are in islands 3 and 4 , then islands 3 and 4 will be good. so the expect of the number of the good islands is 16 6 , which equals to 666666674 modulo 109+7 . in the second example the air routes form the following tree: we can see that there is one person in each island, and only the island 3 is good. so the expect number is 1 .
array merging time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given two arrays a and b both of length n . you will merge † these arrays forming another array c of length 2⋅n . you have to find the maximum length of a subarray consisting of equal values across all arrays c that could be obtained. † a merge of two arrays results in an array c composed by successively taking the first element of either array (as long as that array is nonempty) and removing it. after this step, the element is appended to the back of c . we repeat this operation as long as we can (i.e. at least one array is nonempty). input each test contains multiple test cases. the first line of input contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of test cases follows. the first line of each test case contains a single integer n ( 1≤n≤2⋅105 ) — the length of the array a and b . the second line of each test case contains n integers a1,a2,…,an ( 1≤ai≤2⋅n ) — the elements of array a . the third line of each test case contains n integers b1,b2,…,bn ( 1≤bi≤2⋅n ) — the elements of array b . it is guaranteed that the sum of n across all test cases does not exceed 2⋅105 . output for each test case, output the maximum length of a subarray consisting of equal values across all merges. example input copy 4 1 2 2 3 1 2 3 4 5 6 2 1 2 2 1 5 1 2 2 2 2 2 1 1 1 1 output copy 2 1 2 5 note in the first test case, we can only make c=[2,2] , thus the answer is 2 . in the second test case, since all values are distinct, the answer must be 1 . in the third test case, the arrays c we can make are [1,2,1,2] , [1,2,2,1] , [2,1,1,2] , [2,1,2,1] . we can see that the answer is 2 when we choose c=[1,2,2,1] .
gold rush time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output initially you have a single pile with n gold nuggets. in an operation you can do the following: take any pile and split it into two piles, so that one of the resulting piles has exactly twice as many gold nuggets as the other. (all piles should have an integer number of nuggets.) one possible move is to take a pile of size 6 and split it into piles of sizes 2 and 4 , which is valid since 4 is twice as large as 2 . can you make a pile with exactly m gold nuggets using zero or more operations? input the first line contains an integer t ( 1≤t≤1000 ) — the number of test cases. the only line of each test case contains two integers n and m ( 1≤n,m≤107 ) — the starting and target pile sizes, respectively. output for each test case, output "yes" if you can make a pile of size exactly m , and "no" otherwise. you can output the answer in any case (for example, the strings "yes", "yes", "yes" and "yes" will be recognized as a positive answer). example input copy 11 6 4 9 4 4 2 18 27 27 4 27 2 27 10 1 1 3 1 5 1 746001 2984004 output copy yes yes no no yes yes no yes yes no no note the first test case is pictured in the statement. we can make a pile of size 4 . in the second test case, we can perform the following operations: {9}→{6,3}→{4,2,3} . the pile that is split apart is colored red before each operation. in the third test case, we can't perform a single operation. in the fourth test case, we can't end up with a larger pile than we started with.
luotianyi and the show time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output there are n people taking part in a show about vocaloid. they will sit in the row of seats, numbered 1 to m from left to right. the n people come and sit in order. each person occupies a seat in one of three ways: sit in the seat next to the left of the leftmost person who is already sitting, or if seat 1 is taken, then leave the show. if there is no one currently sitting, sit in seat m . sit in the seat next to the right of the rightmost person who is already sitting, or if seat m is taken, then leave the show. if there is no one currently sitting, sit in seat 1 . sit in the seat numbered xi . if this seat is taken, then leave the show. now you want to know what is the maximum number of people that can take a seat, if you can let people into the show in any order? input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of test cases follows. the first line of each test case contains two integers n and m ( 1≤n,m≤105 ) — the number of people and the number of seats. the second line of each test case contains n integers x1,x2,…,xn ( −2≤xi≤m , xi≠0 ), the i -th of which describes the way in which the i -th person occupies a seat: if xi=−1 , then i -th person takes the seat in the first way. if xi=−2 , then i -th person takes the seat in the second way. if xi>0 , then the i -th person takes a seat in the third way, i.e. he wants to sit in the seat with the number xi or leave the show if it is occupied.. it is guaranteed that sum of n and the sum of m over all test cases don't exceed 105 . output for each test case output a single integer — the maximum number of people who can occupy a seat. example input copy 10 3 10 5 5 5 4 6 1 -2 -2 1 5 7 -1 -1 4 -2 -2 6 7 5 -2 -2 -2 -2 -2 6 6 -1 1 4 5 -1 4 6 8 -1 -1 -1 3 -1 -2 6 7 5 -1 -2 -2 -2 -2 3 1 -2 -2 1 2 5 5 -2 1 2 -1 output copy 1 3 5 6 5 5 5 1 2 1 note in the first test case, all the people want to occupy the 5 seat, so only 1 people can occupy the seat. in the second test case, we can let people in order 1,2,3,4 , then all but the last person can take a seat. in the third test case, we can let people into the show in that order: let the third person in: – – – 3 – – – let the fourth person in: – – – 3 4 – – let the fifth person in: – – – 3 4 5 – let the first person in: – – 1 3 4 5 – let the second person in: – 2 1 3 4 5 – thus, all 5 people took seats. in the fifth test case, we can let people into the show in this order: let the fourth person in: – – – – 4 – let the third person in: – – – 3 4 – let the sixth person in, he'll leave the show because he takes the third seat the third way and has to sit in the 4 seat, but it's already taken: – – – 3 4 – let the fifth person in: – – 5 3 4 – let the first person in: – 1 5 3 4 – let the second person in: 2 1 5 3 4 – thus, 5 of people took seats. in the seventh test case, we can let people into the show in this order: let the third person in: 3 – – – – – – let the fourth person in: 3 4 – – – – – let the fifth person in: 3 4 5 – – – – let the sixth person in: 3 4 5 6 – – – let the first person in: 3 4 5 6 1 – – let the second person in, he will leave the show because he occupies the first way, but the 1 seat is taken: 3 4 5 6 1 – – thus, 5 people took seats.
super-permutation time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output a permutation is a sequence n integers, where each integer from 1 to n appears exactly once. for example, [1] , [3,5,2,1,4] , [1,3,2] are permutations, while [2,3,2] , [4,3,1] , [0] are not. given a permutation a , we construct an array b , where bi=(a1+a2+ … +ai)modn . a permutation of numbers [a1,a2,…,an] is called a super-permutation if [b1+1,b2+1,…,bn+1] is also a permutation of length n . grisha became interested whether a super-permutation of length n exists. help him solve this non-trivial problem. output any super-permutation of length n , if it exists. otherwise, output −1 . input the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of the test cases follows. each test case consists of a single line containing one integer n ( 1≤n≤2⋅105 ) — the length of the desired permutation. the sum of n over all test cases does not exceed 2⋅105 . output for each test case, output in a separate line: n integers — a super-permutation of length n , if it exists. −1 , otherwise. if there are several suitable permutations, output any of them. example input copy 4 1 2 3 6 output copy 1 2 1 -1 6 5 2 3 4 1
permutation swap time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given an unsorted permutation p1,p2,…,pn . to sort the permutation, you choose a constant k ( k≥1 ) and do some operations on the permutation. in one operation, you can choose two integers i , j ( 1≤j<i≤n ) such that i−j=k , then swap pi and pj . what is the maximum value of k that you can choose to sort the given permutation? a permutation is an array consisting of n distinct integers from 1 to n in arbitrary order. for example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation ( 2 appears twice in the array) and [1,3,4] is also not a permutation ( n=3 but there is 4 in the array). an unsorted permutation p is a permutation such that there is at least one position i that satisfies pi≠i . input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains a single integer n ( 2≤n≤105 ) — the length of the permutation p . the second line of each test case contains n distinct integers p1,p2,…,pn ( 1≤pi≤n ) — the permutation p . it is guaranteed that the given numbers form a permutation of length n and the given permutation is unsorted. it is guaranteed that the sum of n over all test cases does not exceed 2⋅105 . output for each test case, output the maximum value of k that you can choose to sort the given permutation. we can show that an answer always exists. example input copy 7 3 3 1 2 4 3 4 1 2 7 4 2 6 7 5 3 1 9 1 6 7 4 9 2 3 8 5 6 1 5 3 4 2 6 10 3 10 5 2 9 6 7 8 1 4 11 1 11 6 4 8 3 7 5 9 10 2 output copy 1 2 3 4 3 2 3 note in the first test case, the maximum value of k you can choose is 1 . the operations used to sort the permutation are: swap p2 and p1 ( 2−1=1 ) → p=[1,3,2] swap p2 and p3 ( 3−2=1 ) → p=[1,2,3] in the second test case, the maximum value of k you can choose is 2 . the operations used to sort the permutation are: swap p3 and p1 ( 3−1=2 ) → p=[1,4,3,2] swap p4 and p2 ( 4−2=2 ) → p=[1,2,3,4]
willy-nilly, crack, into release! time limit per test3 seconds memory limit per test1024 megabytes inputstandard input outputstandard output you have long dreamed of working in a large it company and finally got a job there. you have studied all existing modern technologies for a long time and are ready to apply all your knowledge in practice. but then you sit down at your desk and see a sheet of paper with the company's motto printed in large letters: abcdabcdabcdabcd.... the company's motto contains four main principles— a (willi), b (nilli), c (crack), d (release). therefore, you consider strings of length n consisting of these four latin letters. unordered pairs of letters "ab", "bc", "cd", and "da" in this motto are adjacent, so we will call such pairs of symbols good. so, if you are given a string s of length n , and it is known that the unordered pair of symbols {x,y} is good, then you can perform one of the following operations on the string: if sn=x , then you are allowed to replace this symbol with y , if there exists 1≤i<n such that si=x and si+1=…=sn=y , then you are allowed to replace the i -th symbol of the string with y , and all subsequent symbols with x . for example, the string bacdd can be replaced with one of the strings bacda, bacdc, or badcc, and the string aac can be replaced with aab or aad. a non-empty sequence of operations for the string s will be called correct if the following two conditions are met: after performing all operations, the string becomes s again, no string, except for s , will occur more than once during the operations. at the same time, the string s can occur exactly twice - before the start of the operations and after performing all operations. now we are ready to move on to the problem statement! you have a set of strings that is initially empty. then, each of q queries adds another string ti to the set, or removes the string ti from the set. after each query, you need to output the minimum and maximum size of a correct sequence of operations in which each word occurs at least once. the choice of the initial string s is up to you. input the first line contains two integers n and q ( 1≤n≤20 , 1≤q≤100000 ) — the length of the strings under consideration and the number of queries to modify the set of strings. each of the next q lines contains a string ti ( |ti|=n ). all strings consist of characters "a", "b", "c" and "d". if the string ti was not in the set before the query, it is added to the set, otherwise it is removed from the set. output for each of the q queries, output two integers: the minimum and maximum size of a correct sequence of operations in which each word from the set appears at least once. if there is no sequence of operations that satisfies the condition of the problem, output a single number −1 . examples input copy 2 4 aa ac dd ac output copy 2 12 4 4 -1 12 12 input copy 3 2 acc bdd output copy 2 44 28 44 note let's consider the first test example. after the first query, the set of important words is equal to { aa } , the minimum sequence of actions has the following form: aa, ab, aa. the maximum sequence of actions that fits is aa, ab, ba, bb, bc, cb, cc, cd, dc, dd, da, ad, aa. after the second query, the set of important words is equal to { aa, ac } . the minimum and maximum sequences of actions are: aa, ab, ac, ad, aa. after the third query, the set of important words is equal to { aa, ac, dd } . there is no sequence of actions that fits the condition, so −1 should be outputted. after the fourth query, the set of important words is equal to { aa, dd } . the minimum and maximum sequences of actions are as follows: aa, ab, ba, bb, bc, cb, cc, cd, dc, dd, da, ad, aa.
maximum sum time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are given an array a1,a2,…,an , where all elements are different. you have to perform exactly k operations with it. during each operation, you do exactly one of the following two actions (you choose which to do yourself): find two minimum elements in the array, and delete them; find the maximum element in the array, and delete it. you have to calculate the maximum possible sum of elements in the resulting array. input the first line contains one integer t ( 1≤t≤104 ) — the number of test cases. each test case consists of two lines: the first line contains two integers n and k ( 3≤n≤2⋅105 ; 1≤k≤99999 ; 2k<n ) — the number of elements and operations, respectively. the second line contains n integers a1,a2,…,an ( 1≤ai≤109 ; all ai are different) — the elements of the array. additional constraint on the input: the sum of n does not exceed 2⋅105 . output for each test case, print one integer — the maximum possible sum of elements in the resulting array. example input copy 6 5 1 2 5 1 10 6 5 2 2 5 1 10 6 3 1 1 2 3 6 1 15 22 12 10 13 11 6 2 15 22 12 10 13 11 5 1 999999996 999999999 999999997 999999998 999999995 output copy 21 11 3 62 46 3999999986 note in the first testcase, applying the first operation produces the following outcome: two minimums are 1 and 2 ; removing them leaves the array as [5,10,6] , with sum 21 ; a maximum is 10 ; removing it leaves the array as [2,5,1,6] , with sum 14 . 21 is the best answer. in the second testcase, it's optimal to first erase two minimums, then a maximum.
range sorting (hard version) time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output the only difference between this problem and the easy version is the constraints on t and n . you are given an array a , consisting of n distinct integers a1,a2,…,an . define the beauty of an array p1,p2,…pk as the minimum amount of time needed to sort this array using an arbitrary number of range-sort operations. in each range-sort operation, you will do the following: choose two integers l and r ( 1≤l<r≤k ). sort the subarray pl,pl+1,…,pr in r−l seconds. please calculate the sum of beauty over all subarrays of array a . a subarray of an array is defined as a sequence of consecutive elements of the array. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains a single integer n ( 1≤n≤3⋅105 ) — the length of the array a . the second line of each test case consists of n integers a1,a2,…,an ( 1≤ai≤109 ). it is guaranteed that all elements of a are pairwise distinct. it is guaranteed that the sum of n over all test cases does not exceed 3⋅105 . output for each test case, output the sum of beauty over all subarrays of array a . example input copy 5 2 6 4 3 3 10 6 4 4 8 7 2 5 9 8 2 4 6 12 2 6 13 3 15 5 10 8 16 9 11 18 output copy 1 2 8 16 232 note in the first test case: the subarray [6] is already sorted, so its beauty is 0 . the subarray [4] is already sorted, so its beauty is 0 . you can sort the subarray [6,4] in one operation by choosing l=1 and r=2 . its beauty is equal to 1 . the sum of beauty over all subarrays of the given array is equal to 0+0+1=1 . in the second test case: the subarray [3] is already sorted, so its beauty is 0 . the subarray [10] is already sorted, so its beauty is 0 . the subarray [6] is already sorted, so its beauty is 0 . the subarray [3,10] is already sorted, so its beauty is 0 . you can sort the subarray [10,6] in one operation by choosing l=1 and r=2 . its beauty is equal to 2−1=1 . you can sort the subarray [3,10,6] in one operation by choosing l=2 and r=3 . its beauty is equal to 3−2=1 . the sum of beauty over all subarrays of the given array is equal to 0+0+0+0+1+1=2 .
the butcher time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output anton plays his favorite game "defense of the ancients 2" for his favorite hero — the butcher. now he wants to make his own dinner. to do this he will take a rectangle of height h and width w , then make a vertical or horizontal cut so that both resulting parts have integer sides. after that, he will put one of the parts in the box and cut the other again, and so on. more formally, a rectangle of size h×w can be cut into two parts of sizes x×w and (h−x)×w , where x is an integer from 1 to (h−1) , or into two parts of sizes h×y and h×(w−y) , where y is an integer from 1 to (w−1) . he will repeat this operation n−1 times, and then put the remaining rectangle into the box too. thus, the box will contain n rectangles, of which n−1 rectangles were put in the box as a result of the cuts, and the n -th rectangle is the one that the butcher has left after all n−1 cuts. unfortunately, butcher forgot the numbers h and w , but he still has n rectangles mixed in random order. note that butcher didn't rotate the rectangles, but only shuffled them. now he wants to know all possible pairs (h,w) from which this set of rectangles can be obtained. and you have to help him do it! it is guaranteed that there exists at least one pair (h,w) from which this set of rectangles can be obtained. input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of test cases follows. the first line of each test case contains a single integer n ( 1≤n≤2⋅105 ) — the number of rectangles obtained. the i -th of the next n lines contains two integers ai and bi ( 1≤ai,bi≤106 ) — the height and width of the i -th rectangle. it is guaranteed that the sum of n over all test cases does not exceed 2⋅105 . output for each test case, on the first line output a single integer m — the number of pairs (h,w) denoting the sizes of rectangles from which the given rectangles can be obtained. two rectangles are considered different if they have different heights or widths. on each of the following m lines print output integers hi and wi — the height and width of the rectangle from which the given rectangles can be obtained. you can output the rectangles in any order. example input copy 4 3 1 2 3 5 1 3 3 1 1 1 1 1 1 1 10 10 4 3 2 5 5 2 2 8 7 output copy 1 4 5 2 1 3 3 1 1 10 10 1 13 7 note in the first test case, butcher could only have a rectangle of size 4×5 . then the cuts could look like this (first the green cut was made, then the red one): in the second test case, butcher could have either a rectangle of 1×3 or 3×1 . the cuts would have looked like this (first the green cut was made, then the red cut): in the third test case, butcher did not make any cuts, so the rectangle is 10×10 .
bosco and particle time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output bosco is studying the behaviour of particles. he decided to investigate on the peculiar behaviour of the so-called "four-one-two" particle. he does the following: there is a line of length n+1 , where the topmost point is position 0 and bottommost is position n+1 . the particle is initially (at time t=0 ) at position 0 and heading downwards. the particle moves at the speed of 1 unit per second. there are n oscillators at positions 1,2,…,n . each oscillator can be described by a binary string. the initial state of each oscillator is the first character of its binary string. when the particle hits with an oscillator, the particle reverses its direction if its current state is 1 and continues to move at the same direction if its current state is 0 , and that oscillator moves on to the next state (the next state of the last state is defined as the first state). additionally, the particle always reverses its direction when it is at position 0 or n+1 at time t>0 . bosco would like to know the cycle length of the movement of particle. the cycle length is defined as the minimum value of c such that for any time t≥0 , the position of the particle at time t is same as the position of the particle at time t+c . it can be proved that such value c always exists. as he realises the answer might be too large, he asks you to output your answer modulo 998244353 . input the first line contains an integer n ( 1≤n≤106 ) — the number of oscillators. the i -th of the next n line contains a binary string si ( 1≤|si|≤106 ) — the binary string, that contains only characters 0 and 1 , describing the oscillator at position i . it is guaranteed that the sum of all |si| does not exceed 106 . output output a single integer integer — the cycle length of the movement of the particle, modulo 998244353 . examples input copy 1 00 output copy 4 input copy 2 01 010 output copy 16 input copy 4 0101 000 1 01 output copy 12 input copy 4 01010 0001 11 0001 output copy 120 note in the first sample, the only oscillator at position 1 always has state 0 . at time moments 0,1,2,3 positions the particle are 0,1,2,1 respectively. then the same positions will be repeated, so c=4 . animation for the second sample: here or a smoother animation.
similar polynomials time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output a polynomial a(x) of degree d is an expression of the form a(x)=a0+a1x+a2x2+⋯+adxd , where ai are integers, and ad≠0 . two polynomials a(x) and b(x) are called similar if there is an integer s such that for any integer x it holds that b(x)≡a(x+s)(mod109+7). for two similar polynomials a(x) and b(x) of degree d , you're given their values in the points x=0,1,…,d modulo 109+7 . find a value s such that b(x)≡a(x+s)(mod109+7) for all integers x . input the first line contains a single integer d ( 1≤d≤2500000 ). the second line contains d+1 integers a(0),a(1),…,a(d) ( 0≤a(i)<109+7 ) — the values of the polynomial a(x) . the third line contains d+1 integers b(0),b(1),…,b(d) ( 0≤b(i)<109+7 ) — the values of the polynomial b(x) . it is guaranteed that a(x) and b(x) are similar and that the leading coefficients (i.e., the coefficients in front of xd ) of a(x) and b(x) are not divisible by 109+7 . output print a single integer s ( 0≤s<109+7 ) such that b(x)≡a(x+s)(mod109+7) for all integers x . if there are multiple solutions, print any. examples input copy 1 1000000006 0 2 3 output copy 3 input copy 2 1 4 9 100 121 144 output copy 9 note in the first example, a(x)≡x−1(mod109+7) and b(x)≡x+2(mod109+7) . they're similar because b(x)≡a(x+3)(mod109+7). in the second example, a(x)≡(x+1)2(mod109+7) and b(x)≡(x+10)2(mod109+7) , hence b(x)≡a(x+9)(mod109+7).
comparison string time limit per test2 seconds memory limit per test512 megabytes inputstandard input outputstandard output you are given a string s of length n , where each character is either < or >. an array a consisting of n+1 elements is compatible with the string s if, for every i from 1 to n , the character si represents the result of comparing ai and ai+1 , i. e.: si is < if and only if ai<ai+1 ; si is > if and only if ai>ai+1 . for example, the array [1,2,5,4,2] is compatible with the string <<>>. there are other arrays with are compatible with that string, for example, [13,37,42,37,13] . the cost of the array is the number of different elements in it. for example, the cost of [1,2,5,4,2] is 4 ; the cost of [13,37,42,37,13] is 3 . you have to calculate the minimum cost among all arrays which are compatible with the given string s . input the first line contains one integer t ( 1≤t≤500 ) — the number of test cases. each test case consists of two lines: the first line contains one integer n ( 1≤n≤100 ); the second line contains the string s , consisting of n characters. each character of s is either < or >. output for each test case, print one integer — the minimum cost among all arrays which are compatible with the given string s . example input copy 4 4 <<>> 4 >><< 5 >>>>> 7 <><><>< output copy 3 3 6 2 note in the first test case of the example, the array can be [13,37,42,37,13] . in the second test case of the example, the array can be [42,37,13,37,42] .
love story time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output timur loves codeforces. that's why he has a string s having length 10 made containing only lowercase latin letters. timur wants to know how many indices string s differs from the string "codeforces". for example string s= "coolforsez" differs from "codeforces" in 4 indices, shown in bold. help timur by finding the number of indices where string s differs from "codeforces". note that you can't reorder the characters in the string s . input the first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. each test case is one line and contains the string s , consisting of exactly 10 lowercase latin characters. output for each test case, output a single integer — the number of indices where string s differs. example input copy 5 coolforsez cadafurcie codeforces paiuforces forcescode output copy 4 5 0 4 9
editorial for two time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output berland intercollegiate contest has just finished. monocarp and polycarp, as the jury, are going to conduct an editorial. unfortunately, the time is limited, since they have to finish before the closing ceremony. there were n problems in the contest. the problems are numbered from 1 to n . the editorial for the i -th problem takes ai minutes. monocarp and polycarp are going to conduct an editorial for exactly k of the problems. the editorial goes as follows. they have a full problemset of n problems before them, in order. they remove n−k problems without changing the order of the remaining k problems. then, monocarp takes some prefix of these k problems (possibly, an empty one or all problems). polycarp takes the remaining suffix of them. after that, they go to different rooms and conduct editorials for their problems in parallel. so, the editorial takes as much time as the longer of these two does. please, help monocarp and polycarp to choose the problems and the split in such a way that the editorial finishes as early as possible. print the duration of the editorial. input the first line contains a single integer t ( 1≤t≤104 ) — the number of testcases. the first line of each testcase contains two integers n and k ( 1≤k≤n≤3⋅105 ) — the number of problems in the full problemset and the number of problems monocarp and polycarp are going to conduct an editorial for. the second line contains n integers a1,a2,…,an ( 1≤ai≤109 ) — the time each editorial takes. the sum of n over all testcases doesn't exceed 3⋅105 . output for each testcase, print a single integer — the smallest amount of time the editorial takes, if monocarp and polycarp can choose which k of n problems to conduct an editorial for and how to split them among themselves. example input copy 6 5 4 1 10 1 1 1 5 3 1 20 5 15 3 5 3 1 20 3 15 5 10 6 10 8 20 14 3 8 6 4 16 11 10 5 9 9 2 13 15 19 4 9 13 12 1 1 1 output copy 2 6 5 21 18 1
palindrome partition time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output a substring is a continuous and non-empty segment of letters from a given string, without any reorders. an even palindrome is a string that reads the same backward as forward and has an even length. for example, strings "zz", "abba", "abccba" are even palindromes, but strings "codeforces", "reality", "aba", "c" are not. a beautiful string is an even palindrome or a string that can be partitioned into some smaller even palindromes. you are given a string s , consisting of n lowercase latin letters. count the number of beautiful substrings of s . input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains a single integer n ( 1≤n≤5⋅105 ). the second line of each test case contains a string s . string s consists of only lowercase latin letters and has a length of n . it is guaranteed that the sum of n over all test cases does not exceed 5⋅105 . output for each test case print the number of beautiful substrings. example input copy 6 6 abaaba 1 a 2 aa 6 abcdef 12 accabccbacca 6 abbaaa output copy 3 0 1 0 14 6 note in the first test case, the beautiful substrings are "abaaba", "baab", "aa". in the last test case, the beautiful substrings are "aa" (counted twice), "abba", "bb", "bbaa", "abbaaa".
politics time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output in a debate club with n members, including yourself (member 1 ), there are k opinions to be discussed in sequence. during each discussion, members express their agreement or disagreement with the opinion. let's define y as the number of members who agree and n as the number of members who disagree. after each discussion, members leave the club based on the following criteria: if more members agree than disagree ( y>n ), all members who disagreed leave the club. if more members disagree than agree ( y<n ), all members who agreed leave the club. if there is a tie ( y=n ), all members leave the club. as the club president, your goal is to stay in the club and maximize the number of members remaining after the meeting. you have access to each member's stance on all k opinions before the meeting starts, and you can expel any number of members (excluding yourself) before the meeting begins. determine the maximum number of members, including yourself, who can remain in the club after the meeting. you don't need to provide the specific expulsion strategy but only the maximum number of members that can stay. ensure that you remain in the club after the meeting as well. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤1000 ). description of the test cases follows. the first line of each test case contains two positive integers n and k ( 1≤n,k≤100 ) — the number of members and the number of discussions. the i -th of the following n lines contains a string ti of length k . the j -th character in the string ti indicates whether the i -th member agrees or disagrees with the j -th opinion if they are present during that discussion. a "+" symbol means the member agrees, while a "-" symbol means the member disagrees. it is guaranteed that the sum of n⋅k over all test cases does not exceed 5⋅104 . output for each test case, output the maximum number of members, including yourself, who can remain in the club after the meeting. example input copy 5 2 2 ++ +- 1 3 +-+ 4 1 + - - + 5 4 ++++ +--+ ++-+ +-++ ++++ 4 2 ++ -- -- -+ output copy 1 1 2 2 1 note for convenience, we will analyze the examples based on who actually attended the meeting (i. e. was not expelled) rather than who was expelled. example 1: only the first member could have attended the meeting, otherwise both members would have left after the second opinion is discussed. example 2: there is only a single member that attends the meeting and stays till the end. example 3: the club has 4 members and only one opinion will be discussed during the meeting. let's analyze the possible outcomes based on the participants in the meeting: if only the first member attends, they'll be the only one left after the meeting. if the first member attends with the second or third member, they will be a tie in the discussion, making them both leave. if the first member attends with the second and third members, the first member will be in the minority and will leave after the discussion, which contradicts the statement. if the first and fourth members attend, they will agree during the discussion and both remain till the end. if the first, second, and fourth members attend, the second member will be in the minority during the discussion, and only the first and fourth members will remain at the end. the same happens if the second member is replaced by the third member. if all four members attend, there will be a tie during the discussion, making everyone leave. the maximum number of members remaining after the meeting is 2 . example 4: the club has 5 members and 4 opinions will be discussed during the meeting. one way to achieve the maximum number of members is if only the first, third, and fifth members attend the meeting. in this case, they all agree during the first two discussions, after which the third member is in the minority during the third discussion. then, the first and fifth members agree in the last discussion, and those two members stay till the end of the meeting. example 5: the club has 4 members and 2 opinions will be discussed. if the first three members attend the meeting, the first member will be in the minority during the first discussion and will leave the club. after that, the second and third members will both disagree with the second opinion, and they both will stay till the end of the meeting. in this way, there will be 2 members left after the meeting, but it is an invalid outcome, as it forces the first member to leave. therefore, the maximum number of 1 member is achieved if only the first member attends the meeting.
karina and array time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output karina has an array of n integers a1,a2,a3,…,an . she loves multiplying numbers, so she decided that the beauty of a pair of numbers is their product. and the beauty of an array is the maximum beauty of a pair of adjacent elements in the array. for example, for n=4 , a=[3,5,7,4] , the beauty of the array is max ( 3⋅5 , 5⋅7 , 7⋅4 ) = max ( 15 , 35 , 28 ) = 35 . karina wants her array to be as beautiful as possible. in order to achieve her goal, she can remove some elements (possibly zero) from the array. after karina removes all elements she wants to, the array must contain at least two elements. unfortunately, karina doesn't have enough time to do all her tasks, so she asks you to calculate the maximum beauty of the array that she can get by removing any number of elements (possibly zero). input the first line of the input contains an integer t ( 1≤t≤104 ) — the number of test cases. the description of the test cases follows. the first line of a test case contains an integer n ( 2≤n≤2⋅105 ) — the length of the array a . the second line of a test case contains n integers a1,a2,a3,…,an ( −109≤ai≤109 ) — the elements of the array a . the sum of all values of n across all test cases does not exceed 2⋅105 . output output t integers, each of which is the answer to the corresponding test case — the maximum beauty of the array that karina can get. example input copy 7 4 5 0 2 1 3 -1 1 0 5 2 0 -1 -4 0 6 -8 4 3 7 1 -9 6 0 3 -2 5 -4 -4 2 1000000000 910000000 7 -1 -7 -2 -5 -4 -6 -3 output copy 10 0 4 72 16 910000000000000000 42 note in the first test case of the example, to get the maximum beauty, you need to remove the 2 -nd element. in the second and third test cases of the example, there is no need to remove any elements to achieve maximum beauty. in the fourth test case of the example, you need to leave only the first and last elements.
almost increasing subsequence time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output a sequence is almost-increasing if it does not contain three consecutive elements x,y,z such that x≥y≥z . you are given an array a1,a2,…,an and q queries. each query consists of two integers 1≤l≤r≤n . for each query, find the length of the longest almost-increasing subsequence of the subarray al,al+1,…,ar . a subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements. input the first line of input contains two integers, n and q ( 1≤n,q≤200000 ) — the length of the array a and the number of queries. the second line contains n integers a1,a2,…,an ( 1≤ai≤109 ) — the values of the array a . each of the next q lines contains the description of a query. each line contains two integers l and r ( 1≤l≤r≤n ) — the query is about the subarray al,al+1,…,ar . output for each of the q queries, print a line containing the length of the longest almost-increasing subsequence of the subarray al,al+1,…,ar . example input copy 9 8 1 2 4 3 3 5 6 2 1 1 3 1 4 2 5 6 6 3 7 7 8 1 8 8 8 output copy 3 4 3 1 4 2 7 1 note in the first query, the subarray is a1,a2,a3=[1,2,4] . the whole subarray is almost-increasing, so the answer is 3 . in the second query, the subarray is a1,a2,a3,a4=[1,2,4,3] . the whole subarray is a almost-increasing, because there are no three consecutive elements such that x≥y≥z . so the answer is 4 . in the third query, the subarray is a2,a3,a4,a5=[2,4,3,3] . the whole subarray is not almost-increasing, because the last three elements satisfy 4≥3≥3 . an almost-increasing subsequence of length 3 can be found (for example taking a2,a3,a5=[2,4,3] ). so the answer is 3 .
walk the runway time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output a fashion tour consists of m identical runway shows in different cities. there are n models willing to participate in the tour, numbered from 1 to n . people in different cities have different views on the fashion industry, so they rate each model differently. in particular, people in city i rate model j with rating ri,j . you are to choose some number of k models, and their order, let the chosen models have indices j1,j2,…,jk in the chosen order. in each city, these k models will walk the runway one after another in this order. to make the show exciting, in each city, the ratings of models should be strictly increasing in the order of their performance. more formally, for any city i and index t ( 2≤t≤k ), the ratings must satisfy ri,jt−1<ri,jt . after all, the fashion industry is all about money, so choosing model j to participate in the tour profits you pj money. compute the maximum total profit you can make by choosing the models and their order while satisfying all the requirements. input the first line contains two integers m and n ( 1≤m≤500 , 1≤n≤5000 ) — the number of shows and the number of models willing to participate respectively. the second line contains n integers pj ( 1≤pj≤109 ) — the profit you get inviting the j -th model to the tour. the next m lines each contain n integers. line number i contains n integers ri,j ( 1≤ri,j≤n ) — the ratings of models in city i . output output a single integer — the largest total amount of money you can get. examples input copy 3 5 10 10 10 10 10 1 2 3 4 5 1 5 2 3 4 2 3 4 5 1 output copy 30 input copy 3 5 10 10 10 10 50 1 2 3 4 5 1 5 2 3 4 2 3 4 5 1 output copy 50 input copy 1 1 1000000000 1 output copy 1000000000 input copy 5 5 1000000000 1000000000 1000000000 1000000000 1000000000 5 4 3 2 1 5 4 3 2 1 5 4 3 2 1 5 4 3 2 1 5 4 3 2 1 output copy 5000000000 input copy 1 3 1 2 3 3 3 3 output copy 3 note in the first example, there are 3 invited models. the show consists of models in the order [1,3,4] . then, the corresponding ratings in the cities are as follows: city 1 — [1,3,4] . city 2 — [1,2,3] . city 3 — [2,4,5] . you can see that the ratings are increasing. so the total profit is 10+10+10=30 . it can be proven that we can't achieve a bigger profit. in the second example, we can invite the fifth model to the tour, which would result in a total profit of 50 . it can be proven that we can't achieve a bigger profit. in the third example, we invite the single model to the tour, which results in a total profit of 1000000000 . in the fourth test case, we can invite all the models and make the show in the order [5,4,3,2,1] . the total profit is 5⋅1000000000=5000000000 .
tubetube feed time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output mushroom filippov cooked himself a meal and while having his lunch, he decided to watch a video on tubetube. he can not spend more than t seconds for lunch, so he asks you for help with the selection of video. the tubetube feed is a list of n videos, indexed from 1 to n . the i -th video lasts ai seconds and has an entertainment value bi . initially, the feed is opened on the first video, and mushroom can skip to the next video in 1 second (if the next video exists). mushroom can skip videos any number of times (including zero). help mushroom choose one video that he can open and watch in t seconds. if there are several of them, he wants to choose the most entertaining one. print the index of any appropriate video, or −1 if there is no such. input the first line of the input data contains a single integer q ( 1≤q≤1000 ) — the number of test cases in the test. the description of the test cases follows. the first line of a test case contains two integers n and t ( 1≤n≤50 , 1≤t≤200 ) — the number of videos in the feed and seconds for lunch, respectively. the second line of a test case contains n integers a1,a2,a3,…,an ( 1≤ai≤100 ) — durations of videos. the third line of a test case contains n integers b1,b2,b3,…,bn ( 1≤bi≤100 ) — entertainment values of videos. output output q integers, each of which is the answer to the corresponding test case. as an answer, output the index of the most entertaining video that mushroom will have time to watch. if there are several answers, you are allowed to output any of them. output −1 , if there is no video he can watch during his lunch break. example input copy 5 5 9 1 5 7 6 6 3 4 7 1 9 4 4 4 3 3 2 1 2 3 4 5 7 5 5 5 5 5 2 1 3 9 7 4 33 54 71 69 96 42 24 99 1 2 179 55 66 77 88 output copy 3 2 3 -1 2
hyperregular bracket strings time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are given an integer n and k intervals. the i -th interval is [li,ri] where 1≤li≤ri≤n . let us call a regular bracket sequence †,‡ of length n hyperregular if for each i such that 1≤i≤k , the substring ¯ slisli+1…sri is also a regular bracket sequence. your task is to count the number of hyperregular bracket sequences. since this number can be really large, you are only required to find it modulo 998244353 . † a bracket sequence is a string containing only the characters "(" and ")". ‡ a bracket sequence is called regular if one can turn it into a valid math expression by adding characters + and 1. for example, sequences (())(), (), (()(())) and the empty string are regular, while )(, ((), and (()))( are not. input each test contains multiple test cases. the first line of input contains a single integer t ( 1≤t≤105 ) — the number of test cases. the description of test cases follows. the first line of each test case contains two integers n and k ( 1≤n≤3⋅105 , 0≤k≤3⋅105 ) — the length of the hyperregular bracket sequences and the number of intervals respectively. the following k lines of each test case contains two integers li and ri ( 1≤l≤r≤n ). it is guaranteed that the sum of n across all test cases does not exceed 3⋅105 and the sum of k across all test cases does not exceed 3⋅105 . output for each test case, output the number of hyperregular bracket sequences modulo 998244353 . example input copy 7 6 0 5 0 8 1 1 3 10 2 3 4 6 9 1000 3 100 701 200 801 300 901 28 5 1 12 3 20 11 14 4 9 18 19 4 3 1 4 1 4 1 4 output copy 5 0 0 4 839415253 140 2 note for the first testcase, the 5 hyperregular bracket strings of length 6 are: ((())), (()()), (())(), ()(()) and ()()(). for the second testcase, there are no regular bracket strings of length 5 , and consequently, there are no hyperregular bracket strings of length 5 . for the third testcase, there are no hyperregular bracket strings of length 8 for which the substring [1…3] is a regular bracket string. for the fourth testcase, there 4 hyperregular bracket strings are: ((())(())), ((())()()), ()()((())) and ()()(()())
blank space time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given a binary array a of n elements, a binary array is an array consisting only of 0 s and 1 s. a blank space is a segment of consecutive elements consisting of only 0 s. your task is to find the length of the longest blank space. input the first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. the first line of each test case contains a single integer n ( 1≤n≤100 ) — the length of the array. the second line of each test case contains n space-separated integers ai ( 0≤ai≤1 ) — the elements of the array. output for each test case, output a single integer — the length of the longest blank space. example input copy 5 5 1 0 0 1 0 4 0 1 1 1 1 0 3 1 1 1 9 1 0 0 0 1 0 0 0 1 output copy 2 1 1 0 3
restore the weather time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given an array a containing the weather forecast for berlandia for the last n days. that is, ai — is the estimated air temperature on day i ( 1≤i≤n ). you are also given an array b — the air temperature that was actually present on each of the days. however, all the values in array b are mixed up. determine which day was which temperature, if you know that the weather never differs from the forecast by more than k degrees. in other words, if on day i the real air temperature was c , then the equality |ai−c|≤k is always true. for example, let an array a = [ 1,3,5,3,9 ] of length n=5 and k=2 be given and an array b = [ 2,5,11,2,4 ]. then, so that the value of bi corresponds to the air temperature on day i , we can rearrange the elements of the array b so: [ 2,2,5,4,11 ]. indeed: on the 1 st day, |a1−b1|=|1−2|=1 , 1≤2=k is satisfied; on the 2 nd day |a2−b2|=|3−2|=1 , 1≤2=k is satisfied; on the 3 rd day, |a3−b3|=|5−5|=0 , 0≤2=k is satisfied; on the 4 th day, |a4−b4|=|3−4|=1 , 1≤2=k is satisfied; on the 5 th day, |a5−b5|=|9−11|=2 , 2≤2=k is satisfied. input the first line of input data contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of the test cases follows. the first line of each test case contains two integers n ( 1≤n≤105 ) and k ( 0≤k≤109 ) — the number of days and the maximum difference between the expected and actual air temperature on each day. the second line of each test case contains exactly n integers — elements of array a ( −109≤ai≤109 ). the third line of each test case contains exactly n integers — elements of array b ( −109≤bi≤109 ). it is guaranteed that the sum of n over all test cases does not exceed 105 , and that the elements of array b can always be rearranged so that the equality |ai−bi|≤k is true for all i . output on a separate line for each test case, output exactly n numbers — the values of air temperature on each of the days in the correct order. if there is more than one answer — output any of them. example input copy 3 5 2 1 3 5 3 9 2 5 11 2 4 6 1 -1 3 -2 0 -5 -1 -4 0 -1 4 0 0 3 3 7 7 7 9 4 8 output copy 2 2 5 4 11 0 4 -1 0 -4 0 8 4 9
hits different time limit per test2.5 seconds memory limit per test256 megabytes inputstandard input outputstandard output in a carnival game, there is a huge pyramid of cans with 2023 rows, numbered in a regular pattern as shown. if can 92 is hit initially, then all cans colored red in the picture above would fall. you throw a ball at the pyramid, and it hits a single can with number n2 . this causes all cans that are stacked on top of this can to fall (that is, can n2 falls, then the cans directly above n2 fall, then the cans directly above those cans, and so on). for example, the picture above shows the cans that would fall if can 92 is hit. what is the sum of the numbers on all cans that fall? recall that n2=n×n . input the first line contains an integer t ( 1≤t≤1000 ) — the number of test cases. the only line of each test case contains a single integer n ( 1≤n≤106 ) — it means that the can you hit has label n2 . output for each test case, output a single integer — the sum of the numbers on all cans that fall. please note, that the answer for some test cases won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like long long for c++). for all valid inputs, the answer will always fit into 64-bit integer type. example input copy 10 9 1 2 3 4 5 6 10 1434 1000000 output copy 156 1 5 10 21 39 46 146 63145186 58116199242129511 note the first test case is pictured in the statement. the sum of the numbers that fall is 12+22+32+52+62+92=1+4+9+25+36+81=156. in the second test case, only the can labeled 12 falls, so the answer is 12=1 . in the third test case, the cans labeled 12 and 22 fall, so the answer is 12+22=1+4=5 . in the fourth test case, the cans labeled 12 and 32 fall, so the answer is 12+32=1+9=10 . in the fifth test case, the cans labeled 12 , 22 , and 42 fall, so the answer is 12+22+42=1+4+16=21 .
playoff fixing time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output 2k teams participate in a playoff tournament. the teams are numbered from 1 to 2k , in order of decreasing strength. so, team 1 is the strongest one, team 2k is the weakest one. a team with a smaller number always defeats a team with a larger number. first of all, the teams are arranged in some order during a procedure called seeding. each team is assigned another unique value from 1 to 2k , called a seed, that represents its starting position in the playoff. the tournament consists of 2k−1 games. they are held as follows: the teams are split into pairs: team with seed 1 plays against team with seed 2 , team with seed 3 plays against team with seed 4 (exactly in this order), and so on (so, 2k−1 games are played in that phase). when a team loses a game, it is eliminated. after that, only 2k−1 teams remain. if only one team remains, it is declared the champion; otherwise, 2k−2 games are played: in the first one of them, the winner of the game "seed 1 vs seed 2 " plays against the winner of the game "seed 3 vs seed 4 ", then the winner of the game "seed 5 vs seed 6 " plays against the winner of the game "seed 7 vs seed 8 ", and so on. this process repeats until only one team remains. after the tournament ends, the teams are assigned places according to the tournament phase when they were eliminated. in particular: the winner of the tournament gets place 1 ; the team eliminated in the finals gets place 2 ; both teams eliminated in the semifinals get place 3 ; all teams eliminated in the quarterfinals get place 5 ; all teams eliminated in the 1/8 finals get place 9 , and so on. now that we established the rules, we do a little rigging. in particular, we want: team 1 (not team with seed 1 ) to take place 1 ; team 2 to take place 2 ; teams 3 and 4 to take place 3 ; teams from 5 to 8 to take place 5 , and so on. for example, this picture describes one of the possible ways the tournament can go with k=3 , and the resulting places of the teams: some seeds are already reserved for some teams (we are not the only ones rigging the tournament, apparently). we have to fill the rest of the seeds with the remaining teams to achieve the desired placements. how many ways are there to do that? since that value might be large, print it modulo 998244353 . input the first line contains a single integer k ( 0≤k≤19 ) — there are 2k teams. the second line contains 2k integers a1,a2,…,a2k ( ai=−1 or 1≤ai≤2k ). if ai≠−1 , then team ai has seed i . otherwise, the seed i is not reserved for any team. all values, that are not −1 , are distinct. output print a single integer — the number of ways to fill the non-reserved seeds so that the tournament goes as planned, modulo 998244353 . examples input copy 2 1 2 3 4 output copy 0 input copy 2 1 3 4 2 output copy 1 input copy 1 -1 -1 output copy 2 input copy 2 -1 -1 -1 -1 output copy 16 input copy 3 -1 -1 -1 -1 2 -1 -1 -1 output copy 768 input copy 0 1 output copy 1
luotianyi and xor-tree time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output luotianyi gives you a tree with values in its vertices, and the root of the tree is vertex 1 . in one operation, you can change the value in one vertex to any non-negative integer. now you need to find the minimum number of operations you need to perform to make each path from the root to leaf † has a bitwise xor value of zero. † a leaf in a rooted tree is a vertex that has exactly one neighbor and is not a root. input the first line contains a single integer n ( 2≤n≤105 ) — the number of vertices in the tree. the second line contains n integers a1,a2,…,an ( 1≤ai≤109 ), the i -th number represents the value in the i -th vertex. next n−1 lines describe the edges of the tree. the i -th line contains two integers ui and vi ( 1≤ui,vi≤n,ui≠vi ) — the vertices connected by an edge of the tree. it's guaranteed that the given edges form a tree. output print a single integer — the minimum number of operations. examples input copy 6 3 5 7 5 8 4 1 2 1 3 1 4 3 5 4 6 output copy 3 input copy 8 7 10 7 16 19 9 16 11 1 5 4 2 6 5 5 2 7 2 2 3 3 8 output copy 3 input copy 4 1 2 1 2 1 2 2 3 4 3 output copy 0 input copy 9 4 3 6 1 5 5 5 2 7 1 2 2 3 4 1 4 5 4 6 4 7 8 1 8 9 output copy 2 note the tree in the first example: if we change the value in the vertex 2 to 3 , the value in the vertex 5 to 4 , and the value in the vertex 6 to 6 , then the tree will be ok. the bitwise xor from the root to the leaf 2 will be 3⊕3=0 . the bitwise xor from the root to the leaf 5 will be 4⊕7⊕3=0 . the bitwise xor from the root to the leaf 6 will be 6⊕5⊕3=0 . the tree in the second example: if we change the value in the vertex 2 to 4 , the value in the vertex 3 to 27 , and the value in the vertex 6 to 20 , then the tree will be ok. the bitwise xor from the root to the leaf 6 will be 20⊕19⊕7=0 . the bitwise xor from the root to the leaf 8 will be 11⊕27⊕4⊕19⊕7=0 . the bitwise xor from the root to the leaf 4 will be 16⊕4⊕19⊕7=0 . the bitwise xor from the root to the leaf 7 will be 16⊕4⊕19⊕7=0 . in the third example, the only leaf is the vertex 4 and the bitwise xor on the path to it is 1⊕2⊕1⊕2=0 , so we don't need to change values. in the fourth example, we can change the value in the vertex 1 to 5 , and the value in the vertex 4 to 0 . here ⊕ denotes the bitwise xor operation.
running miles time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output there is a street with n sights, with sight number i being i miles from the beginning of the street. sight number i has beauty bi . you want to start your morning jog l miles and end it r miles from the beginning of the street. by the time you run, you will see sights you run by (including sights at l and r miles from the start). you are interested in the 3 most beautiful sights along your jog, but every mile you run, you get more and more tired. so choose l and r , such that there are at least 3 sights you run by, and the sum of beauties of the 3 most beautiful sights minus the distance in miles you have to run is maximized. more formally, choose l and r , such that bi1+bi2+bi3−(r−l) is maximum possible, where i1,i2,i3 are the indices of the three maximum elements in range [l,r] . input the first line contains a single integer t ( 1≤t≤105 ) — the number of test cases. the first line of each test case contains a single integer n ( 3≤n≤105 ). the second line of each test case contains n integers bi ( 1≤bi≤108 ) — beauties of sights i miles from the beginning of the street. it's guaranteed that the sum of all n does not exceed 105 . output for each test case output a single integer equal to the maximum value bi1+bi2+bi3−(r−l) for some running range [l,r] . example input copy 4 5 5 1 4 2 3 4 1 1 1 1 6 9 8 7 6 5 4 7 100000000 1 100000000 1 100000000 1 100000000 output copy 8 1 22 299999996 note in the first example, we can choose l and r to be 1 and 5 . so we visit all the sights and the three sights with the maximum beauty are the sights with indices 1 , 3 , and 5 with beauties 5 , 4 , and 3 , respectively. so the total value is 5+4+3−(5−1)=8 . in the second example, the range [l,r] can be [1,3] or [2,4] , the total value is 1+1+1−(3−1)=1 .
the fox and the complete tree traversal time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output the fox yae climbed the tree of the sacred sakura. a tree is a connected undirected graph that does not contain cycles. the fox uses her magical powers to move around the tree. yae can jump from vertex v to another vertex u if and only if the distance between these vertices does not exceed 2 . in other words, in one jump yae can jump from vertex v to vertex u if vertices v and u are connected by an edge, or if there exists such vertex w that vertices v and w are connected by an edge, and also vertices u and w are connected by an edge. after yae was able to get the sakura petal, she wondered if there was a cyclic route in the tree v1,v2,…,vn such that: the fox can jump from vertex vi to vertex vi+1 , the fox can jump from vertex vn to vertex v1 , all vi are pairwise distinct. help the fox determine if the required traversal exists. input the first line contains one integer n ( 2≤n≤2⋅105 ) —the number of vertices of the tree. each of the following n−1 lines contains two integers u and v ( 1≤u,v≤n , u≠v ) — vertices connected by an edge. it is guaranteed that these edges form a tree. output on the first line, print "yes" (without quotes) if the required route of the tree exists, or "no" (without quotes) otherwise. if the required tree traversal exists, on the second line print n integers of different integers v1,v2,…,vn ( 1≤vi≤n ) — the vertices of the tree in traversal order. if there are several correct traversals, output any of them. examples input copy 5 1 2 1 3 3 4 3 5 output copy yes 4 5 1 2 3 input copy 3 1 2 1 3 output copy yes 1 2 3 input copy 15 1 2 1 3 2 4 2 5 3 6 3 7 4 8 4 9 5 10 5 11 6 12 6 13 7 14 7 15 output copy no note the tree from the first example is shown below. the bold arrows indicate the fox's route. in the second example, any sequence of three different vertices is a correct route, because the fox can jump from any vertex to any vertex. the tree from the third example is shown below. it can be shown that there is no required route for it.
forever winter time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output a snowflake graph is generated from two integers x and y , both greater than 1 , as follows: start with one central vertex. connect x new vertices to this central vertex. connect y new vertices to each of these x vertices. for example, below is a snowflake graph for x=5 and y=3 . the snowflake graph above has a central vertex 15 , then x=5 vertices attached to it ( 3 , 6 , 7 , 8 , and 20 ), and then y=3 vertices attached to each of those. given a snowflake graph, determine the values of x and y . input the first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. the first line of each test case contains two integers n and m ( 2≤n≤200 ; 1≤m≤min(1000, n(n−1) 2 ) ) — the number of vertices and edges in the graph, respectively. the next m lines each contain two integers each u and v ( 1≤u,v≤n , u≠v ) — the numbers of vertices connected by an edge. the graph does not contain multiple edges and self-loops. it is guaranteed that this graph is a snowflake graph for some integers x and y both greater than 1 . output for each test case, on a separate line output the values of x and y , in that order, separated by a space. example input copy 3 21 20 21 20 5 20 13 20 1 3 11 3 10 3 4 8 19 8 14 8 9 7 12 7 17 7 18 6 16 6 2 6 6 15 7 15 8 15 20 15 3 15 7 6 1 2 1 3 2 4 2 5 3 6 3 7 9 8 9 3 3 6 6 2 2 1 5 2 2 7 4 3 3 8 output copy 5 3 2 2 2 3 note the first test case is pictured in the statement. note that the output 3 5 is incorrect, since x should be output before y .
tear it apart time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are given a string s , consisting of lowercase latin letters. in one operation, you can select several (one or more) positions in it such that no two selected positions are adjacent to each other. then you remove the letters on the selected positions from the string. the resulting parts are concatenated without changing their order. what is the smallest number of operations required to make all the letters in s the same? input the first line contains a single integer t ( 1≤t≤104 ) — the number of testcases. the only line of each testcase contains a string s , consisting of lowercase latin letters. its length is from 1 to 2⋅105 . the total length of the strings over all testcases doesn't exceed 2⋅105 . output for each testcase, print a single integer — the smallest number of operations required to make all the letters in the given string s the same. example input copy 5 abacaba codeforces oooooooo abcdef mewheniseearulhiiarul output copy 1 3 0 2 4 note in the first testcase, you can select positions 2,4 and 6 and remove the corresponding letters 'b', 'c' and 'b'. in the third testcase, the letters in the string are already the same, so you don't have to make any operations. in the fourth testcase, one of the possible solutions in 2 operations is the following. you can select positions 1,4,6 first. the string becomes "bce". then select positions 1 and 3 . the string becomes "c". all letters in it are the same, since it's just one letter.
sort the subarray time limit per test2 seconds memory limit per test512 megabytes inputstandard input outputstandard output monocarp had an array a consisting of n integers. he has decided to choose two integers l and r such that 1≤l≤r≤n , and then sort the subarray a[l..r] (the subarray a[l..r] is the part of the array a containing the elements al,al+1,al+2,…,ar−1,ar ) in non-descending order. after sorting the subarray, monocarp has obtained a new array, which we denote as a′ . for example, if a=[6,7,3,4,4,6,5] , and monocarp has chosen l=2,r=5 , then a′=[6,3,4,4,7,6,5] . you are given the arrays a and a′ . find the integers l and r that monocarp could have chosen. if there are multiple pairs of values (l,r) , find the one which corresponds to the longest subarray. input the first line contains one integer t ( 1≤t≤104 ) — the number of test cases. each test case consists of three lines: the first line contains one integer n ( 2≤n≤2⋅105 ); the second line contains n integers a1,a2,…,an ( 1≤ai≤n ); the third line contains n integers a ′ 1 ,a ′ 2 ,…,a ′ n ( 1≤a ′ i ≤n ). additional constraints on the input: the sum of n over all test cases does not exceed 2⋅105 ; it is possible to obtain the array a′ by sorting one subarray of a ; a′≠a (there exists at least one position in which these two arrays are different). output for each test case, print two integers — the values of l and r ( 1≤l≤r≤n ). if there are multiple answers, print the values that correspond to the longest subarray. if there are still multiple answers, print any of them. example input copy 3 7 6 7 3 4 4 6 5 6 3 4 4 7 6 5 3 1 2 1 1 1 2 3 2 2 1 2 1 2 output copy 2 5 1 3 2 3
copil copac draws trees time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output copil copac is given a list of n−1 edges describing a tree of n vertices. he decides to draw it using the following algorithm: step 0 : draws the first vertex (vertex 1 ). go to step 1 . step 1 : for every edge in the input, in order: if the edge connects an already drawn vertex u to an undrawn vertex v , he will draw the undrawn vertex v and the edge. after checking every edge, go to step 2 . step 2 : if all the vertices are drawn, terminate the algorithm. else, go to step 1 . the number of readings is defined as the number of times copil copac performs step 1 . find the number of readings needed by copil copac to draw the tree. input each test contains multiple test cases. the first line of input contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of test cases follows. the first line of each test case contains a single integer n ( 2≤n≤2⋅105 ) — the number of vertices of the tree. the following n−1 lines of each test case contain two integers ui and vi ( 1≤ui,vi≤n , ui≠vi ) — indicating that (ui,vi) is the i -th edge in the list. it is guaranteed that the given edges form a tree. it is guaranteed that the sum of n over all test cases does not exceed 2⋅105 . output for each test case, output the number of readings copil copac needs to draw the tree. example input copy 2 6 4 5 1 3 1 2 3 4 1 6 7 5 6 2 4 2 7 1 3 1 2 4 5 output copy 2 3 note in the first test case: after the first reading, the tree will look like this: after the second reading: therefore, copil copac needs 2 readings to draw the tree.
bun lover time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output tema loves cinnabon rolls — buns with cinnabon and chocolate in the shape of a "snail". cinnabon rolls come in different sizes and are square when viewed from above. the most delicious part of a roll is the chocolate, which is poured in a thin layer over the cinnabon roll in the form of a spiral and around the bun, as in the following picture: cinnabon rolls of sizes 4, 5, 6 for a cinnabon roll of size n , the length of the outer side of the square is n , and the length of the shortest vertical chocolate segment in the central part is one. formally, the bun consists of two dough spirals separated by chocolate. a cinnabon roll of size n+1 is obtained from a cinnabon roll of size n by wrapping each of the dough spirals around the cinnabon roll for another layer. it is important that a cinnabon roll of size n is defined in a unique way. tema is interested in how much chocolate is in his cinnabon roll of size n . since tema has long stopped buying small cinnabon rolls, it is guaranteed that n≥4 . answer this non-obvious question by calculating the total length of the chocolate layer. input the first line of the input contains a single integer t ( 1≤t≤105 ) — the number of test cases. the following t lines describe the test cases. each test case is described by a single integer n ( 4≤n≤109 ) — the size of the cinnabon roll. output output t integers. the i -th of them should be equal to the total length of the chocolate layer in the i -th test case. example input copy 4 4 5 6 179179179 output copy 26 37 50 32105178545472401
grasshopper on a line time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are given two integers x and k . grasshopper starts in a point 0 on an ox axis. in one move, it can jump some integer distance, that is not divisible by k , to the left or to the right. what's the smallest number of moves it takes the grasshopper to reach point x ? what are these moves? if there are multiple answers, print any of them. input the first line contains a single integer t ( 1≤t≤1000 ) — the number of testcases. the only line of each testcase contains two integers x and k ( 1≤x≤100 ; 2≤k≤100 ) — the endpoint and the constraint on the jumps, respectively. output for each testcase, in the first line, print a single integer n — the smallest number of moves it takes the grasshopper to reach point x . in the second line, print n integers, each of them not divisible by k . a positive integer would mean jumping to the right, a negative integer would mean jumping to the left. the endpoint after the jumps should be exactly x . each jump distance should be from −109 to 109 . in can be shown that, for any solution with the smallest number of jumps, there exists a solution with the same number of jumps such that each jump is from −109 to 109 . it can be shown that the answer always exists under the given constraints. if there are multiple answers, print any of them. example input copy 3 10 2 10 3 3 4 output copy 2 7 3 1 10 1 3
bracket coloring time limit per test2 seconds memory limit per test512 megabytes inputstandard input outputstandard output a regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters "1" and "+" between the original characters of the sequence. for example: the bracket sequences "()()" and "(())" are regular (the resulting expressions are: "(1)+(1)" and "((1+1)+1)"); the bracket sequences ")(", "(" and ")" are not. a bracket sequence is called beautiful if one of the following conditions is satisfied: it is a regular bracket sequence; if the order of the characters in this sequence is reversed, it becomes a regular bracket sequence. for example, the bracket sequences "()()", "(())", ")))(((", "))()((" are beautiful. you are given a bracket sequence s . you have to color it in such a way that: every bracket is colored into one color; for every color, there is at least one bracket colored into that color; for every color, if you write down the sequence of brackets having that color in the order they appear, you will get a beautiful bracket sequence. color the given bracket sequence s into the minimum number of colors according to these constraints, or report that it is impossible. input the first line contains one integer t ( 1≤t≤104 ) — the number of test cases. each test case consists of two lines. the first line contains one integer n ( 2≤n≤2⋅105 ) — the number of characters in s . the second line contains s — a string of n characters, where each character is either "(" or ")". additional constraint on the input: the sum of n over all test cases does not exceed 2⋅105 . output for each test case, print the answer as follows: if it is impossible to color the brackets according to the problem statement, print −1 ; otherwise, print two lines. in the first line, print one integer k ( 1≤k≤n ) — the minimum number of colors. in the second line, print n integers c1,c2,…,cn ( 1≤ci≤k ), where ci is the color of the i -th bracket. if there are multiple answers, print any of them. example input copy 4 8 ((())))( 4 (()) 4 ))(( 3 (() output copy 2 2 2 2 1 2 2 2 1 1 1 1 1 1 1 1 1 1 1 -1
toy machine time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output there is a toy machine with toys arranged in two rows of n cells each ( n is odd). initial state for n=9 . initially, n−2 toys are placed in the non-corner cells of the top row. the bottom row is initially empty, and its leftmost, rightmost, and central cells are blocked. there are 4 buttons to control the toy machine: left, right, up, and down marked by the letters l, r, u, and d correspondingly. when pressing l, r, u, or d, all the toys will be moved simultaneously in the corresponding direction and will only stop if they push into another toy, the wall or a blocked cell. your goal is to move the k -th toy into the leftmost cell of the top row. the toys are numbered from 1 to n−2 from left to right. given n and k , find a solution that uses at most 1000000 button presses. to test out the toy machine, a web page is available that lets you play the game in real time. input the first and only line contains two integers, n and k ( 5≤n≤100000 , n is odd, 1≤k≤n−2 ) — the number of cells in a row, and the index of the toy that has to be moved to the leftmost cell of the top row. output on a single line, output a description of the button presses as a string of at most 1000000 characters. the string should only contain the characters l, r, u, and d. the i -th character in the string is the i -th button that is pressed. after all the button presses are performed, the k -th toy should be in the leftmost cell of the top row. if there are multiple solutions, print any. the number of button presses does not have to be minimized. examples input copy 5 1 output copy rdl input copy 7 2 output copy rdl note in the first example, there will be 5−2=3 toys. the first toy needs to end up in the leftmost cell of the top row. the moves rdl will achieve this, see the picture for a better understanding. another possible solution would be to do one button press l. visualization of the moves for the first example.
unique palindromes time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output a palindrome is a string that reads the same backwards as forwards. for example, the string abcba is palindrome, while the string abca is not. let p(t) be the number of unique palindromic substrings of string t , i. e. the number of substrings t[l…r] that are palindromes themselves. even if some substring occurs in t several times, it's counted exactly once. (the whole string t is also counted as a substring of t ). for example, string t = abcbbcabcb has p(t)=6 unique palindromic substrings: a, b, c, bb, bcb and cbbc. now, let's define p(s,m)=p(t) where t=s[1…m] . in other words, p(s,m) is the number of palindromic substrings in the prefix of s of length m . for example, p( abcbbcabcb ,5) = p( abcbb )=5 . you are given an integer n and k "conditions" ( k≤20 ). let's say that string s , consisting of n lowercase latin letters, is good if all k conditions are satisfied at the same time. a condition is a pair (xi,ci) and have the following meaning: p(s,xi)=ci , i. e. a prefix of s of length xi contains exactly ci unique palindromic substrings. find a good string s or report that such s doesn't exist. look in notes if you need further clarifications. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains two integers n and k ( 3≤n≤2⋅105 ; 1≤k≤20 ) — length of good string s and number of conditions. the second line of each test case contains k integers x1,x2,…,xk ( 3≤x1<x2<⋯<xk=n ) where xi is the length of the prefix in the i -th condition. the third line of each test case contains k integers c1,c2,…,ck ( 3≤c1≤c2≤⋯≤ck≤min(109, (n+1)n 2 ) ) where ci is the number of palindromic substrings in the i -th condition. it is guaranteed that the sum of n over all test cases does not exceed 2⋅105 . output for each test case, if there is no good string s of length n that satisfies all conditions, print no. otherwise, print yes and a string s of length n , consisting of lowercase latin letters, that satisfies all conditions. if there are multiple answers, print any of them. example input copy 7 10 2 5 10 5 6 3 1 3 3 4 2 3 4 3 3 4 2 3 4 3 4 4 1 4 5 10 3 4 6 10 4 5 8 10 4 4 6 7 10 4 5 7 8 output copy yes abcbbcabcb yes foo yes ayda yes wada no yes abcbcacbab no note in the first test case, string s = abcbbcabcb satisfies k=2 conditions: p(s,x1)=p(s,5)= p( abcbb )=5=s1 . palindromic substrings are a, b, c, bb and bcb. p(s,x2)=p(s,10)= p( abcbbcabcb )=6=s2 . palindromic substrings are the same as above, and one extra substring cbbc. in the second test case, string foo satisfies k=1 condition: p( foo )=3 . palindromic substrings are f, o and oo. there are other possible answers. in the third test case, string ayda satisfies k=2 conditions: p( ayd )=3 . palindromic substrings are a, y and d. p( ayda )=3 . palindromic substrings are the same. in the fourth test case, string wada satisfies k=2 conditions: p( wad )=3 . palindromic substrings are w, a and d. p( wada )=4 . palindromic substrings are the same, and one extra substring ada. in the fifth test case, it can be proven that there is no string of length 4 which has 5 palindromic substrings. in the sixth test case, string abcbcacbab satisfies k=3 conditions: p( abcb )=4 . palindromic substrings are a, b, c and bcb. p( abcbca )=5 . palindromic substrings are the same, and one extra substring cbc. p( abcbcacbab )=8 . palindromic substrings are the same, and three extra substrings cac, bab and bcacb.
magic triples (easy version) time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output this is the easy version of the problem. the only difference is that in this version, ai≤106 . for a given sequence of n integers a , a triple (i,j,k) is called magic if: 1≤i,j,k≤n . i , j , k are pairwise distinct. there exists a positive integer b such that ai⋅b=aj and aj⋅b=ak . kolya received a sequence of integers a as a gift and now wants to count the number of magic triples for it. help him with this task! note that there are no constraints on the order of integers i , j and k . input the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of the test cases follows. the first line of the test case contains a single integer n ( 3≤n≤2⋅105 ) — the length of the sequence. the second line of the test contains n integers a1,a2,a3,…,an ( 1≤ai≤106 ) — the elements of the sequence a . the sum of n over all test cases does not exceed 2⋅105 . output for each test case, output a single integer — the number of magic triples for the sequence a . example input copy 7 5 1 7 7 2 7 3 6 2 18 9 1 2 3 4 5 6 7 8 9 4 1000 993 986 179 7 1 10 100 1000 10000 100000 1000000 8 1 1 2 2 4 4 8 8 9 1 1 1 2 2 2 4 4 4 output copy 6 1 3 0 9 16 45 note in the first example, there are 6 magic triples for the sequence a — (2,3,5) , (2,5,3) , (3,2,5) , (3,5,2) , (5,2,3) , (5,3,2) . in the second example, there is a single magic triple for the sequence a — (2,1,3) .
constructive problem time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output as you know, any problem that does not require the use of complex data structures is considered constructive. you are offered to solve one of such problems. you are given an array a of n non-negative integers. you are allowed to perform the following operation exactly once: choose some non-empty subsegment al,al+1,…,ar of the array a and a non-negative integer k , and assign value k to all elements of the array on the chosen subsegment. the task is to find out whether mex(a) can be increased by exactly one by performing such an operation. in other words, if before the operation mex(a)=m held, then after the operation it must hold that mex(a)=m+1 . recall that mex of a set of integers c1,c2,…,ck is defined as the smallest non-negative integer x which does not occur in the set c . input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤50000 ) — the number of test cases. the description of the test cases follows. the first line of each test case contains a single integer n ( 1≤n≤200000 ) — the number of elements of array a . the second line of each test case contains n integers a1,a2,…,an ( 0≤ai≤109 ) — elements of array a . it is guaranteed that the sum n over all test cases does not exceed 200000 . output for each test case, print "yes" if you can increase mex(a) by exactly one by performing the operation from the statement exactly once, otherwise print "no". you can output the answer in any case (upper or lower). for example, the strings "yes", "yes", "yes", and "yes" will be recognized as positive responses. example input copy 4 3 1 2 1 4 0 2 2 0 4 3 2 0 2 1 0 output copy yes yes no no note in the first test case, mex(a)=0 . if you set all elements of a to 0 , then mex of the resulting array will be 1 , and thus will increase by one. in the second test case, mex(a)=1 . if we assign a value of 1 to the elements of a on a subsegment from 2 to 3 , we get an array [0,1,1,0] for which mex is 2 , and thus is increased by one compared to the original. it can be shown that in the third and fourth test cases it is impossible to perform an operation so that the value of mex(a) increases by exactly one.
round dance time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output n people came to the festival and decided to dance a few round dances. there are at least 2 people in the round dance and each person has exactly two neighbors. if there are 2 people in the round dance then they have the same neighbor on each side. you decided to find out exactly how many dances there were. but each participant of the holiday remembered exactly one neighbor. your task is to determine what the minimum and maximum number of round dances could be. for example, if there were 6 people at the holiday, and the numbers of the neighbors they remembered are equal [2,1,4,3,6,5] , then the minimum number of round dances is 1 : 1−2−3−4−5−6−1 and the maximum is 3 : 1−2−1 3−4−3 5−6−5 input the first line contains a positive number t ( 1≤t≤104 ) — the number of test cases. the following is a description of the test cases. the first line of the description of each test case contains a positive number n ( 2≤n≤2⋅105 ) — the number of people at the holiday. the second line of the description of each test case contains n integers ai ( 1≤ai≤n,ai≠i ) — the number of the neighbor that the i th person remembered. it is guaranteed that the test cases are correct and corresponds to at least one division of people into round dances. it is guaranteed that the sum of n for all test cases does not exceed 2⋅105 . output for each test case, output two integers — the minimum and maximum number of round dances that could be. example input copy 10 6 2 1 4 3 6 5 6 2 3 1 5 6 4 9 2 3 2 5 6 5 8 9 8 2 2 1 4 4 3 2 1 5 2 3 4 5 1 6 5 3 4 1 1 2 5 3 5 4 1 2 6 6 3 2 5 4 3 6 5 1 4 3 4 2 output copy 1 3 2 2 1 3 1 1 1 2 1 1 1 1 2 2 1 2 1 1
ian visits mary time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output ian and mary are frogs living on lattice points of the cartesian coordinate plane, with ian living on (0,0) and mary living on (a,b) . ian would like to visit mary by jumping around the cartesian coordinate plane. every second, he jumps from his current position (xp,yp) to another lattice point (xq,yq) , such that no lattice point other than (xp,yp) and (xq,yq) lies on the segment between point (xp,yp) and point (xq,yq) . as ian wants to meet mary as soon as possible, he wants to jump towards point (a,b) using at most 2 jumps. unfortunately, ian is not good at maths. can you help him? a lattice point is defined as a point with both the x -coordinate and y -coordinate being integers. input the first line contains a single integer t ( 1≤t≤500 ) — the number of test cases. the description of test cases follows. the first and only line of each test case contains two integers a and b ( 1≤a,b≤109 ) — the coordinates of the lattice point where mary lives. output for each test case, print an integer n ( 1≤n≤2 ) on the first line, denoting the number of jumps ian uses in order to meet mary. note that you do not need to minimize the number of jumps. on the i -th line of the next n lines, print two integers 0≤xi,yi≤109 separated by a space, denoting ian's location (xi,yi) after the i -th jump. xn=a , yn=b must hold. ian's initial location and his locations after each of the n jumps need not be distinct. if there are multiple solutions, output any. example input copy 8 3 4 4 4 3 6 2 2 1 1 7 3 2022 2023 1000000000 1000000000 output copy 1 3 4 2 3 2 4 4 2 5 3 3 6 2 1 0 2 2 1 1 1 1 7 3 1 2022 2023 2 69420420 469696969 1000000000 1000000000 note in the first test case: (0,0)→(3,4) in the second test case: (0,0)→(3,2)→(4,4) in the third test case: (0,0)→(5,3)→(3,6)
luotianyi and cartridge time limit per test3 seconds memory limit per test1024 megabytes inputstandard input outputstandard output luotianyi is watching the anime made in abyss. she finds that making a cartridge is interesting. to describe the process of making a cartridge more clearly, she abstracts the original problem and gives you the following problem. you are given a tree t consisting of n vertices. each vertex has values ai and bi and each edge has values cj and dj . now you are aim to build a tree t′ as follows: first, select p vertices from t ( p is a number chosen by yourself) as the vertex set s′ of t′ . next, select p−1 edges from t one by one (you cannot select one edge more than once). may you have chosen the j -th edge connects vertices xj and yj with values (cj,dj) , then you can choose two vertices u and v in s′ that satisfy the edge (xj,yj) is contained in the simple path from u to v in t , and link u and v in t′ by the edge with values (cj,dj) ( u and v shouldn't be contained in one connected component before in t′ ). a tree with three vertices, min(a,c)=1,b+d=7 , the cost is 7 . selected vertices 2 and 3 as s′ , used the edge (1,2) with cj=2 and dj=1 to link this vertices, now min(a,c)=2,b+d=4 , the cost is 8 . let a be the minimum of values ai in t′ and c be the minimum of values ci in t′ . let b be the sum of bi in t′ and d be the sum of values di in t′ . let min(a,c)⋅(b+d) be the cost of t′ . you need to find the maximum possible cost of t′ . input the first line contains one integer n ( 3≤n≤2⋅105 ) — the number of vertices in the tree t . the second line contains n integers a1,a2,…,an ( 1≤ai≤2⋅105 ), where the i -th integer represents the ai value of the i -th vertex. the third line contains n integers b1,b2,…,bn ( 1≤bi≤2⋅105 ), where the i -th integer represents the bi value of the i -th vertex. then n−1 lines follow, the j -th of them contains four integers xj,yj,cj,dj ( 1≤xj,yj≤n,1≤cj,dj≤2⋅105 ) representing the edge (xj,yj) and its values cj and dj respectively. it's guaranteed that edges form a tree. output print a single integer — the maximum possible cost of t′ . examples input copy 3 1 2 2 1 1 2 1 2 2 1 1 3 1 2 output copy 8 input copy 5 2 4 2 1 1 2 4 4 4 4 2 5 3 3 3 5 2 4 4 2 5 5 5 1 1 5 output copy 35 input copy 6 5 7 10 7 9 4 6 9 7 9 8 5 2 1 5 1 3 2 2 4 4 3 6 3 5 1 7 4 6 5 6 8 output copy 216 input copy 5 1000 1000 1 1000 1000 1000 1000 1 1000 1000 1 2 1 1 2 3 1000 1000 3 4 1000 1000 3 5 1000 1000 output copy 7000000 note the tree from the first example is shown in the statement. the tree from the second example is shown below: a=1,b=18,c=1,d=17 , so the cost is min(1,1)⋅(18+17)=35 .
best binary string time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are given a string s consisting of the characters 0, 1 and/or ?. let's call it a pattern. let's say that the binary string (a string where each character is either 0 or 1) matches the pattern if you can replace each character ? with 0 or 1 (for each character, the choice is independent) so that the strings become equal. for example, 0010 matches ?01?, but 010 doesn't match 1??, ??, or ????. let's define the cost of the binary string as the minimum number of operations of the form "reverse an arbitrary contiguous substring of the string" required to sort the string in non-descending order. you have to find a binary string with the minimum possible cost among those that match the given pattern. if there are multiple answers, print any of them. input the first line contains a single integer t ( 1≤t≤3⋅104 ) — the number of test cases. the first and only line of each test case contains the string s ( 1≤|s|≤3⋅105 ) consisting of characters 0, 1, and/or ?. the sum of the string lengths over all test cases does not exceed 3⋅105 . output for each test case, print a binary string with the minimum possible cost among those that match the given pattern. if there are multiple answers, print any of them. example input copy 4 ??01? 10100 1??10? 0?1?10?10 output copy 00011 10100 111101 011110010 note in the first test case of the example, the cost of the resulting string is 0 . in the second test case, the cost of the resulting string is 2 : we can reverse the substring from the 1 -st character to the 5 -th character, and we obtain the string 00101. then we reverse the substring from the 3 -rd to the 4 -th character, and we obtain the string 00011, which is sorted in non-descending order.
matching time limit per test2 seconds memory limit per test512 megabytes inputstandard input outputstandard output an integer template is a string consisting of digits and/or question marks. a positive (strictly greater than 0 ) integer matches the integer template if it is possible to replace every question mark in the template with a digit in such a way that we get the decimal representation of that integer without any leading zeroes. for example: 42 matches 4?; 1337 matches ????; 1337 matches 1?3?; 1337 matches 1337; 3 does not match ??; 8 does not match ???8; 1337 does not match 1?7. you are given an integer template consisting of at most 5 characters. calculate the number of positive (strictly greater than 0 ) integers that match it. input the first line contains one integer t ( 1≤t≤2⋅104 ) — the number of test cases. each test case consists of one line containing the string s ( 1≤|s|≤5 ) consisting of digits and/or question marks — the integer template for the corresponding test case. output for each test case, print one integer — the number of positive (strictly greater than 0 ) integers that match the template. example input copy 8 ?? ? 0 9 03 1??7 ?5? 9??99 output copy 90 9 0 1 0 100 90 100
making anti-palindromes time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given a string s , consisting of lowercase english letters. in one operation, you are allowed to swap any two characters of the string s . a string s of length n is called an anti-palindrome, if s[i]≠s[n−i+1] for every i ( 1≤i≤n ). for example, the strings "codeforces", "string" are anti-palindromes, but the strings "abacaba", "abc", "test" are not. determine the minimum number of operations required to make the string s an anti-palindrome, or output −1 , if this is not possible. input the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of the test cases follows. each test case consists of two lines. the first line contains a single integer n ( 1≤n≤2⋅105 ) — the length of the string s . the second line contains the string s , consisting of n lowercase english letters. the sum of n over all test cases does not exceed 2⋅105 . output for each test case, output a single integer — the minimum number of operations required to make the string s an anti-palindrome, or −1 if this is not possible. example input copy 10 10 codeforces 3 abc 10 taarrrataa 10 dcbdbdcccc 4 wwww 12 cabbaccabaac 10 aadaaaaddc 14 aacdaaaacadcdc 6 abccba 12 dcbcaebacccd output copy 0 -1 1 1 -1 3 -1 2 2 2 note in the first test case, the string "codeforces" is already an anti-palindrome, so the answer is 0 . in the second test case, it can be shown that the string "abc" cannot be transformed into an anti-palindrome by performing the allowed operations, so the answer is −1 . in the third test case, it is enough to swap the second and the fifth characters of the string "taarrrataa", and the new string "trararataa" will be an anti-palindrome, so the answer is 1 .
misha and apples time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output schoolboy misha got tired of doing sports programming, so he decided to quit everything and go to the magical forest to sell magic apples. his friend danya came to the magical forest to visit misha. what was his surprise when he found out that misha found a lot of friends there, the same former sports programmers. and all of them, like misha, have their own shop where they sell magic apples. to support his friends, who have changed their lives so drastically, he decided to buy up their entire assortment. the buying process works as follows: in total there are n stalls, numbered with integers from 1 to n , and m kinds of magic apples, numbered with integers from 1 to m . each shop sells some number of kinds of apples. danya visits all the shops in order of increasing number, starting with the first one. upon entering the shop he buys one magic apple of each kind sold in that shop and puts them in his backpack. however, magical apples wouldn't be magical if they were all right. the point is that when two apples of the same type end up together in the backpack, all of the apples in it magically disappear. importantly, the disappearance happens after danya has put the apples in the backpack and left the shop. upon returning home, danya realized that somewhere in the forest he had managed to lose his backpack. unfortunately, for some shops danya had forgotten what assortment of apples there was. remembering only for some shops, what kinds of magical apples were sold in them, he wants to know what is the maximum number of apples he could have in his backpack after all his purchases at best. input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤2⋅105 ) —the number of test cases. the description of test cases follows. the first line contains two integers n and m ( 1≤n,m≤2⋅105 ) —the number of stalls and kinds of apples. each of the following n lines describes the assortment of the next stall in the format described below. each line starts with an integer ki ( 0≤ki≤2⋅105 ). this is followed by ki of different integers aij ( 1≤aij≤m ) —the kinds of apples sold in the i -th stall. if ki=0 , then danya does not remember what assortment was in that shop, and the set of apple kinds can be anything (including empty). it is guaranteed that the sum of all ki over all test cases does not exceed 2⋅105 and the sum of n over all test cases does not exceed 2⋅105 output for each test case, output a single integer — the maximum number of apples that could be in dani's backpack after visiting all the shops at best. example input copy 4 3 4 2 1 2 2 4 1 2 1 2 4 4 2 1 2 2 3 4 0 1 1 2 5 0 0 5 3 0 3 1 2 3 2 3 1 0 1 3 output copy 2 1 5 3 note in the first test case, danya remembers all the shops, so the process will be deterministic. he will take two apples at the first shop and two more at the second, but after he puts them in his backpack, they will disappear. so at the end there will only be 2 apples left, which he will take at the third shop. in the second test case, if the third shop is empty, then after visiting the fourth shop all the apples will disappear. in any other case the apples will disappear after the third shop, and in the fourth shop dan can take one apple, so the answer is 1 . in the third test case, the first shop may sell all kinds of apples, and the second shop may sell nothing. then all 5 apples will be left at the end.
musical puzzle time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output vlad decided to compose a melody on his guitar. let's represent the melody as a sequence of notes corresponding to the characters 'a', 'b', 'c', 'd', 'e', 'f', and 'g'. however, vlad is not very experienced in playing the guitar and can only record exactly two notes at a time. vlad wants to obtain the melody s , and to do this, he can merge the recorded melodies together. in this case, the last sound of the first melody must match the first sound of the second melody. for example, if vlad recorded the melodies "ab" and "ba", he can merge them together and obtain the melody "aba", and then merge the result with "ab" to get "abab". help vlad determine the minimum number of melodies consisting of two notes that he needs to record in order to obtain the melody s . input the first line of input contains an integer t ( 1≤t≤104 ) — the number of test cases. following that are the descriptions of the test cases. the first line of each test case contains an integer n ( 2≤n≤50 ) — the length of the melody s . the second line of each test case contains a string s of length n , consisting of characters 'a', 'b', 'c', 'd', 'e', 'f', 'g'. output output t integers, each representing the answer for the corresponding test case. as the answer output minimum number of melodies consisting of two notes that vlad needs to record. example input copy 5 4 abab 7 abacaba 6 aaaaaa 7 abcdefg 5 babdd output copy 2 4 1 6 4 note in the first sample, you need to record the melodies "ab" and "ba", as described in the problem statement. in the second sample, you need to record the melodies "ab", "ba", "ac", and "ca". in the third sample, the only necessary melody is "aa".
mex tree time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are given a tree with n nodes. for each node, you either color it in 0 or 1 . the value of a path (u,v) is equal to the mex † of the colors of the nodes from the shortest path between u and v . the value of a coloring is equal to the sum of values of all paths (u,v) such that 1≤u≤v≤n . what is the maximum possible value of any coloring of the tree? † the mex (minimum excluded) of an array is the smallest non-negative integer that does not belong to the array. for instance: the mex of [2,2,1] is 0 , because 0 does not belong to the array. the mex of [3,1,0,1] is 2 , because 0 and 1 belong to the array, but 2 does not. the mex of [0,3,1,2] is 4 because 0 , 1 , 2 , and 3 belong to the array, but 4 does not. input each test contains multiple test cases. the first line of input contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of test cases follows. the first line of each test case contains a single integer n ( 1≤n≤2⋅105 ) — the number of nodes in the tree. the following n−1 lines of each test case contains 2 integers ai and bi ( 1≤ai,bi≤n,ai≠bi ) — indicating an edge between vertices ai and bi . it is guaranteed that the given edges form a tree. it is guaranteed that the sum of n across all test cases does not exceed 2⋅105 . output for each test case, print the maximum possible value of any coloring of the tree. example input copy 4 3 1 2 2 3 4 1 2 1 3 1 4 10 1 2 1 3 3 4 3 5 1 6 5 7 2 8 6 9 6 10 1 output copy 8 15 96 1 note in the first sample, we will color vertex 2 in 1 and vertices 1,3 in 0 . after this, we consider all paths: (1,1) with value 1 (1,2) with value 2 (1,3) with value 2 (2,2) with value 0 (2,3) with value 2 (3,3) with value 1 we notice the sum of values is 8 which is the maximum possible.
luotianyi and the floating islands (easy version) time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output this is the easy version of the problem. the only difference is that in this version k≤min(n,3) . you can make hacks only if both versions of the problem are solved. chtholly and the floating islands. luotianyi now lives in a world with n floating islands. the floating islands are connected by n−1 undirected air routes, and any two of them can reach each other by passing the routes. that means, the n floating islands form a tree. one day, luotianyi wants to meet her friends: chtholly, nephren, william, .... totally, she wants to meet k people. she doesn't know the exact positions of them, but she knows that they are in pairwise distinct islands. she define an island is good if and only if the sum of the distances † from it to the islands with k people is the minimal among all the n islands. now, luotianyi wants to know that, if the k people are randomly set in k distinct of the n islands, then what is the expect number of the good islands? you just need to tell her the expect number modulo 109+7 . † the distance between two islands is the minimum number of air routes you need to take to get from one island to the other. input the first line contains two integers n and k ( 1≤k≤min(n,3),1≤n≤2⋅105 ) — the number of the islands and people respectively. next n−1 lines describe the air routes. the i -th of them contains two integers ui and vi ( 1≤ui,vi≤n,ui≠vi ) — the islands connected by the i -th air route. output print a single integer — the expect number of the good islands modulo 109+7 . formally, let m=109+7 . it can be shown that the answer can be expressed as an irreducible fraction p q , where p and q are integers and q≢0 ( modm ). output the integer equal to p⋅q−1 modm . in other words, output such an integer x that 0≤x<m and x⋅q≡p ( modm ). examples input copy 4 2 1 2 2 3 3 4 output copy 666666674 input copy 5 1 1 2 2 3 3 4 3 5 output copy 1 note in the first example the air routes form the following tree: if the people are in the islands 1 and 2 , then islands 1 and 2 will be good. the sum of the distances from island 1 or 2 to all the people is 1+0=1 , which is the minimal. while the sum of the distances from island 3 to all the people is 2+1=3 , which is greater than 1 . like this, when the people are in island 1 and 3 , then islands 1,2 and 3 will be good. when the people are in islands 1 and 4 , then islands 1,2,3 and 4 will be good. when the people are in islands 2 and 3 , then islands 2 and 3 will be good. when the people are in islands 2 and 4 , then islands 2,3 and 4 will be good. when the people are in islands 3 and 4 , then islands 3 and 4 will be good. so the expect of the number of the good islands is 16 6 , which equals to 666666674 modulo 109+7 . in the second example the air routes form the following tree: there is always the only good island, so the expected number is 1 .
yura's new name time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output after holding one team contest, boy yura got very tired and wanted to change his life and move to japan. in honor of such a change, yura changed his name to something nice. fascinated by this idea he already thought up a name s consisting only of characters "_" and "^". but there's a problem — yura likes smiley faces "^_^" and "^^". therefore any character of the name must be a part of at least one such smiley. note that only the consecutive characters of the name can be a smiley face. more formally, consider all occurrences of the strings "^_^" and "^^" in the string s . then all such occurrences must cover the whole string s , possibly with intersections. for example, in the string "^^__^_^^__^" the characters at positions 3,4,9,10 and 11 are not contained inside any smileys, and the other characters at positions 1,2,5,6,7 and 8 are contained inside smileys. in one operation jura can insert one of the characters "_" and "^" into his name s (you can insert it at any position in the string). he asks you to tell him the minimum number of operations you need to do to make the name fit yura's criteria. input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤100 ) —the number of test cases. the description of test cases follows. the first and only line of each test case contains a single string s ( 1≤|s|≤100 ), consisting of characters "_" and "^", — the name to change. output for each test case, output a single integer — the minimum number of characters you need to add to the name to make it fit for yura. if you don't need to change anything in the name, print 0 . example input copy 7 ^______^ ___^_^^^_^___^ ^_ ^ ^_^^^^^_^_^^ ___^^ _ output copy 5 5 1 1 0 3 2 note in the first test case, you can get the following name by adding 5 characters: ^_^_^_^_^_^_^ in the third test case, we can add one character "^" to the end of the name, then we get the name: ^_^ in the fourth test case, we can add one character "^" to the end of the name, then we get the name: ^^ in the fifth test case, all of the characters are already contained in smiley faces, so the answer is 0 . in the seventh test case, you can add one character "^" at the beginning of the name and one character "^" at the end of the name, then you get the name: ^_^
xor counting time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output given two positive integers n and m . find the sum of all possible values of a1⨁a2⨁…⨁am , where a1,a2,…,am are non-negative integers such that a1+a2+…+am=n . note that all possible values a1⨁a2⨁…⨁am should be counted in the sum exactly once. as the answer may be too large, output your answer modulo 998244353 . here, ⨁ denotes the bitwise xor operation. input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of test cases follows. the first and only line of each test case contains two integers n and m ( 0≤n≤1018,1≤m≤105 ) — the sum and the number of integers in the set, respectively. output for each test case, output the sum of all possible values of a1⨁a2⨁…⨁am among all non-negative integers a1,a2,…,am with a1+a2+…+am=n . as the answer may be too large, output your answer modulo 998244353 . example input copy 7 69 1 5 2 0 10 420 69 12 26 73 34 1000000000000000000 10 output copy 69 6 0 44310 42 1369 216734648 note for the first test case, we must have a1=69 , so it's the only possible value of a1 , therefore our answer is 69 . for the second test case, (a1,a2) can be (0,5),(1,4),(2,3),(3,2),(4,1) or (5,0) , in which a1⨁a2 are 5,5,1,1,5,5 respectively. so a1⨁a2 can be 1 or 5 , therefore our answer is 1+5=6 . for the third test case, a1,a2,…,a10 must be all 0 , so a1⨁a2⨁…⨁a10=0 . therefore our answer is 0 .
red-blue operations (easy version) time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output the only difference between easy and hard versions is the maximum values of n and q . you are given an array, consisting of n integers. initially, all elements are red. you can apply the following operation to the array multiple times. during the i -th operation, you select an element of the array; then: if the element is red, it increases by i and becomes blue; if the element is blue, it decreases by i and becomes red. the operations are numbered from 1 , i. e. during the first operation some element is changed by 1 and so on. you are asked q queries of the following form: given an integer k , what can the largest minimum in the array be if you apply exactly k operations to it? note that the operations don't affect the array between queries, all queries are asked on the initial array a . input the first line contains two integers n and q ( 1≤n,q≤1000 ) — the number of elements in the array and the number of queries. the second line contains n integers a1,a2,…,an ( 1≤ai≤109 ). the third line contains q integers k1,k2,…,kq ( 1≤kj≤109 ). output for each query, print a single integer — the largest minimum that the array can have after you apply exactly k operations to it. examples input copy 4 10 5 2 8 4 1 2 3 4 5 6 7 8 9 10 output copy 3 4 5 6 7 8 8 10 8 12 input copy 5 10 5 2 8 4 4 1 2 3 4 5 6 7 8 9 10 output copy 3 4 5 6 7 8 9 8 11 8 input copy 2 5 2 3 10 6 8 1 3 output copy 10 7 8 3 3
copium permutation time limit per test2 seconds memory limit per test1024 megabytes inputstandard input outputstandard output you are given a permutation a1,a2,…,an of the first n positive integers. a subarray [l,r] is called copium if we can rearrange it so that it becomes a sequence of consecutive integers, or more formally, if max(al,al+1,…,ar)−min(al,al+1,…,ar)=r−l for each k in the range [0,n] , print out the maximum number of copium subarrays of a over all ways of rearranging the last n−k elements of a . input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains a single integer n ( 1≤n≤2⋅105 ). the second line of each test case contains n integers a1,a2,…,an ( 1≤ai≤n ). it is guaranteed that the given numbers form a permutation of length n . it is guaranteed that the sum of n over all test cases does not exceed 2⋅105 . output for each test case print n+1 integers as the answers for each k in the range [0,n] . example input copy 5 5 5 2 1 4 3 4 2 1 4 3 1 1 8 7 5 8 1 4 2 6 3 10 1 4 5 3 7 8 9 2 10 6 output copy 15 15 11 10 9 9 10 8 8 7 7 1 1 36 30 25 19 15 13 12 9 9 55 55 41 35 35 25 22 22 19 17 17 note in the first test case, the answer permutations for each k are [1,2,3,4,5] , [5,4,3,2,1] , [5,2,3,4,1] , [5,2,1,3,4] , [5,2,1,4,3] , [5,2,1,4,3] . in the second test case, the answer permutations for each k are [1,2,3,4] , [2,1,3,4] , [2,1,3,4] , [2,1,4,3] , [2,1,4,3] .
strongly composite time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output a prime number is an integer greater than 1 , which has exactly two divisors. for example, 7 is a prime, since it has two divisors {1,7} . a composite number is an integer greater than 1 , which has more than two different divisors. note that the integer 1 is neither prime nor composite. let's look at some composite number v . it has several divisors: some divisors are prime, others are composite themselves. if the number of prime divisors of v is less or equal to the number of composite divisors, let's name v as strongly composite. for example, number 12 has 6 divisors: {1,2,3,4,6,12} , two divisors 2 and 3 are prime, while three divisors 4 , 6 and 12 are composite. so, 12 is strongly composite. other examples of strongly composite numbers are 4 , 8 , 9 , 16 and so on. on the other side, divisors of 15 are {1,3,5,15} : 3 and 5 are prime, 15 is composite. so, 15 is not a strongly composite. other examples are: 2 , 3 , 5 , 6 , 7 , 10 and so on. you are given n integers a1,a2,…,an ( ai>1 ). you have to build an array b1,b2,…,bk such that following conditions are satisfied: product of all elements of array a is equal to product of all elements of array b : a1⋅a2⋅…⋅an=b1⋅b2⋅…⋅bk ; all elements of array b are integers greater than 1 and strongly composite; the size k of array b is the maximum possible. find the size k of array b , or report, that there is no array b satisfying the conditions. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤1000 ). the description of the test cases follows. the first line of each test case contains one integer n ( 1≤n≤1000 ) — the size of the array a . the second line of each test case contains n integer a1,a2,…an ( 2≤ai≤107 ) — the array a itself. it is guaranteed that the sum of n over all test cases does not exceed 1000 . output for each test case, print the size k of array b , or 0 , if there is no array b satisfying the conditions. example input copy 8 2 3 6 3 3 4 5 2 2 3 3 3 10 14 2 25 30 1 1080 9 3 3 3 5 5 5 7 7 7 20 12 15 2 2 2 2 2 3 3 3 17 21 21 21 30 6 6 33 31 39 output copy 1 1 0 2 2 3 4 15 note in the first test case, we can get array b=[18] : a1⋅a2=18=b1 ; 18 is strongly composite number. in the second test case, we can get array b=[60] : a1⋅a2⋅a3=60=b1 ; 60 is strongly composite number. in the third test case, there is no array b satisfying the conditions. in the fourth test case, we can get array b=[4,105] : a1⋅a2⋅a3=420=b1⋅b2 ; 4 and 105 are strongly composite numbers.
rearrange brackets time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output a regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters "1" and "+" between the original characters of the sequence. for example: bracket sequences "()()" and "(())" are regular (the resulting expressions are: "(1)+(1)" and "((1+1)+1)"); bracket sequences ")(", "(" and ")" are not. you are given a regular bracket sequence. in one move, you can remove a pair of adjacent brackets such that the left one is an opening bracket and the right one is a closing bracket. then concatenate the resulting parts without changing the order. the cost of this move is the number of brackets to the right of the right bracket of this pair. the cost of the regular bracket sequence is the smallest total cost of the moves required to make the sequence empty. actually, you are not removing any brackets. instead, you are given a regular bracket sequence and an integer k . you can perform the following operation at most k times: extract some bracket from the sequence and insert it back at any position (between any two brackets, at the start or at the end; possibly, at the same place it was before). after all operations are performed, the bracket sequence has to be regular. what is the smallest possible cost of the resulting regular bracket sequence? input the first line contains a single integer t ( 1≤t≤104 ) — the number of testcases. the first line of each testcase contains a single integer k ( 0≤k≤5 ) — the maximum number of operations you can perform. the second line contains a non-empty regular bracket sequence, it consists only of characters '(' and ')'. the total length of the regular bracket sequences over all testcases doesn't exceed 2⋅105 . output for each testcase, print a single integer — the smallest possible cost of the regular bracket sequence after you perform at most k operations on it. example input copy 7 0 () 0 (()) 1 (()) 5 () 1 (()()(())) 2 ((())()(()())((()))) 3 ((())()(()())((()))) output copy 0 1 0 0 1 4 2
counting orders time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given two arrays a and b each consisting of n integers. all elements of a are pairwise distinct. find the number of ways to reorder a such that ai>bi for all 1≤i≤n , modulo 109+7 . two ways of reordering are considered different if the resulting arrays are different. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains a single integer n ( 1≤n≤2⋅105 ) — the length of the array a and b . the second line of each test case contains n distinct integers a1 , a2 , … , an ( 1≤ai≤109 ) — the array a . it is guaranteed that all elements of a are pairwise distinct. the second line of each test case contains n integers b1 , b2 , … , bn ( 1≤bi≤109 ) — the array b . it is guaranteed that the sum of n over all test cases does not exceed 2⋅105 . output for each test case, output the number of ways to reorder array a such that ai>bi for all 1≤i≤n , modulo 109+7 . example input copy 5 6 9 6 8 4 5 2 4 1 5 6 3 1 3 4 3 2 3 4 9 1 2 1 3 2 3 4 1 3 3 12 2 3 7 10 23 28 29 50 69 135 420 1000 1 1 2 3 5 8 13 21 34 55 89 144 output copy 32 0 1 0 13824
the boss can count pairs time limit per test4 seconds memory limit per test512 megabytes inputstandard input outputstandard output you are given two arrays a and b , both of length n . your task is to count the number of pairs of integers (i,j) such that 1≤i<j≤n and ai⋅aj=bi+bj . input each test contains multiple test cases. the first line of input contains a single integer t ( 1≤t≤104 ) — the number of test cases. the description of test cases follows. the first line of each test case contains a single integer n ( 2≤n≤2⋅105 ) — the length of the arrays. the second line of each test case contains n integers a1,a2,…,an ( 1≤ai≤n ) — the elements of array a . the third line of each test case contains n integers b1,b2,…,bn ( 1≤bi≤n ) — the elements of array b . it is guaranteed that the sum of n across all test cases does not exceed 2⋅105 . output for each test case, output the number of good pairs. example input copy 3 3 2 3 2 3 3 1 8 4 2 8 2 1 2 7 5 3 5 8 8 1 1 6 5 8 4 4 8 8 8 8 8 8 8 8 8 8 8 8 8 8 output copy 2 7 1 note in the first sample, there are 2 good pairs: (1,2) , (1,3) . in the second sample, there are 7 good pairs: (1,2) , (1,5) , (2,8) , (3,4) , (4,7) , (5,6) , (5,7) .
dreaming of freedom time limit per test2.5 seconds memory limit per test256 megabytes inputstandard input outputstandard output because to take away a man's freedom of choice, even his freedom to make the wrong choice, is to manipulate him as though he were a puppet and not a person. — madeleine l'engle there are n programmers choosing their favorite algorithm amongst m different choice options. before the first round, all m options are available. in each round, every programmer makes a vote for one of the remaining algorithms. after the round, only the algorithms with the maximum number of votes remain. the voting process ends when there is only one option left. determine whether the voting process can continue indefinitely or no matter how people vote, they will eventually choose a single option after some finite amount of rounds? input the first line contains a single integer t ( 1≤t≤105 ) — the number of test cases. each test case consists of a single line containing two integers n and m ( 1≤n,m≤106 ) — the number of people and choice options respectively. output for each test case output "yes" if the programmers will eventually choose a single option, and "no" otherwise. you may print each letter in any case (for example, yes, yes, yes, yes will all be recognized as a positive answer). example input copy 5 3 2 4 2 5 3 1000000 1000000 1 1000000 output copy yes no yes no yes note in the first example, there are 8 ways people could vote: {1|1|1,1|1|2,1|2|1,1|2|2,2|1|1,2|1|2,2|2|1,2|2|2} . in cases 1 , 2 , 3 , and 5 , the programmers are left with the first algorithm, and in the remaining cases people are left with the second one, so the voting ends in one round in any case. in the second example, the programmers could always vote 1|1|2|2 . both algorithms have the maximum number of votes and remain for the next round, so the voting never ends.
twin permutations time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given a permutation † a of length n . find any permutation b of length n such that a1+b1≤a2+b2≤a3+b3≤…≤an+bn . it can be proven that a permutation b that satisfies the condition above always exists. † a permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. for example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation ( 2 appears twice in the array), and [1,3,4] is also not a permutation ( n=3 but there is 4 in the array). input each test contains multiple test cases. the first line of input contains a single integer t ( 1≤t≤2000 ) — the number of test cases. the description of test cases follows. the first line of each test case contains a single integer n ( 1≤n≤100 ) — the length of permutations a and b . the second line of each test case contains n distinct integers a1,a2,…,an ( 1≤ai≤n ) — the elements of permutation a . all elements of a are distinct. note that there is no bound on the sum of n over all test cases. output for each test case, output any permutation b which satisfies the constraints mentioned in the statement. it can be proven that a permutation b that satisfies the condition above always exists. example input copy 5 5 1 2 4 5 3 2 1 2 1 1 3 3 2 1 4 1 4 3 2 output copy 1 2 4 3 5 2 1 1 1 2 3 1 2 3 4 note in the first test case a=[1,2,4,5,3] . then the permutation b=[1,2,4,3,5] satisfies the condition because 1+1≤2+2≤4+4≤5+3≤3+5 .
contrast value time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output for an array of integers [a1,a2,…,an] , let's call the value |a1−a2|+|a2−a3|+⋯+|an−1−an| the contrast of the array. note that the contrast of an array of size 1 is equal to 0 . you are given an array of integers a . your task is to build an array of b in such a way that all the following conditions are met: b is not empty, i.e there is at least one element; b is a subsequence of a , i.e b can be produced by deleting some elements from a (maybe zero); the contrast of b is equal to the contrast of a . what is the minimum possible size of the array b ? input the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the first line of each test case contains a single integer n ( 1≤n≤3⋅105 ) — the size of the array a . the second line contains n integers a1,a2,⋅,an ( 0≤ai≤109 ) — elements of the array itself. the sum of n over all test cases doesn't exceed 3⋅105 . output for each test case, print a single integer — the minimum possible size of the array b . example input copy 4 5 1 3 3 3 7 2 4 2 4 1 1 1 1 7 5 4 2 1 0 0 4 output copy 2 2 1 3
sort with step time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output let's define a permutation of length n as an array p of length n , which contains every number from 1 to n exactly once. you are given a permutation p1,p2,…,pn and a number k . you need to sort this permutation in the ascending order. in order to do it, you can repeat the following operation any number of times (possibly, zero): pick two elements of the permutation pi and pj such that |i−j|=k , and swap them. unfortunately, some permutations can't be sorted with some fixed numbers k . for example, it's impossible to sort [2,4,3,1] with k=2 . that's why, before starting the sorting, you can make at most one preliminary exchange: choose any pair pi and pj and swap them. your task is to: check whether is it possible to sort the permutation without any preliminary exchanges, if it's not, check, whether is it possible to sort the permutation using exactly one preliminary exchange. for example, if k=2 and permutation is [2,4,3,1] , then you can make a preliminary exchange of p1 and p4 , which will produce permutation [1,4,3,2] , which is possible to sort with given k . input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains two integers n and k ( 2≤n≤2⋅105 ; 1≤k≤n−1 ) — length of the permutation, and a distance between elements that can be swapped. the second line of each test case contains n integers p1,p2,…,pn ( 1≤pi≤n ) — elements of the permutation p . it is guaranteed that the sum of n over all test cases does not exceed 2⋅105 . output for each test case print 0, if it is possible to sort the permutation without preliminary exchange; 1, if it is possible to sort the permutation with one preliminary exchange, but not possible without preliminary exchange; -1, if it is not possible to sort the permutation with at most one preliminary exchange. example input copy 6 4 1 3 1 2 4 4 2 3 4 1 2 4 2 3 1 4 2 10 3 4 5 9 1 8 6 10 2 3 7 10 3 4 6 9 1 8 5 10 2 3 7 10 3 4 6 9 1 8 5 10 3 2 7 output copy 0 0 1 0 1 -1 note in the first test case, there is no need in preliminary exchange, as it is possible to swap (p1,p2) and then (p2,p3) . in the second test case, there is no need in preliminary exchange, as it is possible to swap (p1,p3) and then (p2,p4) . in the third test case, you need to apply preliminary exchange to (p2,p3) . after that the permutation becomes [3,4,1,2] and can be sorted with k=2 .
vlad building beautiful array time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output vlad was given an array a of n positive integers. now he wants to build a beautiful array b of length n from it. vlad considers an array beautiful if all the numbers in it are positive and have the same parity. that is, all numbers in the beautiful array are greater than zero and are either all even or all odd. to build the array b , vlad can assign each bi either the value ai or ai−aj , where any j from 1 to n can be chosen. to avoid trying to do the impossible, vlad asks you to determine whether it is possible to build a beautiful array b of length n using his array a . input the first line of input contains an integer t ( 1≤t≤104 ) — the number of test cases. then follow the descriptions of the test cases. the first line of each case contains a single integer n ( 1≤n≤2⋅105 ) — the length of the array a . the second line of each case contains n positive integers a1,a2,…,an ( 1≤ai≤109 ) — the elements of the array a . it is guaranteed that the sum of n over all cases does not exceed 2⋅105 . output output t strings, each of which is the answer to the corresponding test case. as the answer, output "yes" if vlad can build a beautiful array b , and "no" otherwise. you can output the answer in any case (for example, the strings "yes", "yes", "yes" and "yes" will be recognized as a positive answer). example input copy 7 5 2 6 8 4 3 5 1 4 7 6 9 4 2 6 4 10 7 5 29 13 9 10000001 11 3 5 2 1 2 4 2 5 2 4 5 4 3 4 2 5 5 4 output copy no yes yes yes yes no no
entangled substrings time limit per test2 seconds memory limit per test256 mebibytes inputstandard input outputstandard output quantum entanglement is when two particles link together in a certain way no matter how far apart they are in space. you are given a string s . a pair of its non-empty substrings (a,b) is called entangled if there is a (possibly empty) link string c such that: every occurrence of a in s is immediately followed by cb ; every occurrence of b in s is immediately preceded by ac . in other words, a and b occur in s only as substrings of acb . compute the total number of entangled pairs of substrings of s . a string a is a substring of a string b if a can be obtained from b by the deletion of several (possibly zero or all) characters from the beginning and several (possibly zero or all) characters from the end. input the first and only line contains a string s of lowercase english letters ( 1≤|s|≤105 ) — the string for which you should count pairs of entangled substrings. output output a single integer, the number of entangled pairs of substrings of s . examples input copy abba output copy 1 input copy abacaba output copy 0 input copy abcabcabcabc output copy 5 input copy adamant output copy 82 note in the first example, the only entangled pair is (ab,ba). for this pair, the corresponding link string c is empty, as they only occur as substrings of the whole string abba, which doesn't have any characters between ab and ba. in the second example, there are no entangled pairs. in the third example, the entangled pairs are (a,b), (b,c), (a,c), (a,bc), and (ab,c). for most pairs, the corresponding link string c is empty, except for the pair (a,c), for which the link string c is b, as a and c only occur as substrings of the string abc.
trust nobody time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output there is a group of n people. some of them might be liars, who always tell lies. other people always tell the truth. the i -th person says "there are at least li liars amongst us". determine if what people are saying is contradictory, or if it is possible. if it is possible, output the number of liars in the group. if there are multiple possible answers, output any one of them. input the first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. the first line of each test case contains a single integer n ( 1≤n≤100 ). the second line of each test case contains n integers li ( 0≤li≤n ) — the number said by the i -th person. it's guaranteed that the sum of all n does not exceed 104 . output for each test case output a single integer. if what people are saying is contradictory, output −1 . otherwise, output the number of liars in the group. if there are multiple possible answers, output any one of them. example input copy 7 2 1 2 2 2 2 2 0 0 1 1 1 0 5 5 5 3 3 5 6 5 3 6 6 3 5 output copy 1 -1 0 -1 0 3 4 note in the first example, the only possible answer is that the second person is a liar, so the answer is 1 liar. in the second example, it can be proven that we can't choose the liars so that all the requirements are satisfied. in the third example, everybody tells the truth, so the answer is 0 liars.
divisible array time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you are given a positive integer n . please find an array a1,a2,…,an that is perfect. a perfect array a1,a2,…,an satisfies the following criteria: 1≤ai≤1000 for all 1≤i≤n . ai is divisible by i for all 1≤i≤n . a1+a2+…+an is divisible by n . input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤200 ). the description of the test cases follows. the only line of each test case contains a single positive integer n ( 1≤n≤200 ) — the length of the array a . output for each test case, output an array a1,a2,…,an that is perfect. we can show that an answer always exists. if there are multiple solutions, print any. example input copy 7 1 2 3 4 5 6 7 output copy 1 2 4 1 2 3 2 8 6 4 3 4 9 4 5 1 10 18 8 5 36 3 6 21 24 10 6 14 note in the third test case: a1=1 is divisible by 1 . a2=2 is divisible by 2 . a3=3 is divisible by 3 . a1+a2+a3=1+2+3=6 is divisible by 3 . in the fifth test case: a1=3 is divisible by 1 . a2=4 is divisible by 2 . a3=9 is divisible by 3 . a4=4 is divisible by 4 . a5=5 is divisible by 5 . a1+a2+a3+a4+a5=3+4+9+4+5=25 is divisible by 5 .
gardening friends time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output two friends, alisa and yuki, planted a tree with n vertices in their garden. a tree is an undirected graph without cycles, loops, or multiple edges. each edge in this tree has a length of k . initially, vertex 1 is the root of the tree. alisa and yuki are growing the tree not just for fun, they want to sell it. the cost of the tree is defined as the maximum distance from the root to a vertex among all vertices of the tree. the distance between two vertices u and v is the sum of the lengths of the edges on the path from u to v . the girls took a course in gardening, so they know how to modify the tree. alisa and yuki can spend c coins to shift the root of the tree to one of the neighbors of the current root. this operation can be performed any number of times (possibly zero). note that the structure of the tree is left unchanged; the only change is which vertex is the root. the friends want to sell the tree with the maximum profit. the profit is defined as the difference between the cost of the tree and the total cost of operations. the profit is cost of the tree minus the total cost of operations. help the girls and find the maximum profit they can get by applying operations to the tree any number of times (possibly zero). input the first line of the input contains one integer t ( 1≤t≤104 ) — the number of test cases. the description of the test cases follows. the first line of each test case contains integers n , k , c ( 2≤n≤2⋅105 ; 1≤k,c≤109 ) — the number of vertices in the tree, the length of each edge, and the cost of the operation. the next n−1 lines of the test case contain pairs of integers ui , vi ( 1≤ui,vi≤n ) — the edges of the graph. these edges form a tree. the sum of the values of n over all test cases does not exceed 2⋅105 . output for each test case, output a single integer — the maximum profit that yuki and alisa can get. example input copy 4 3 2 3 2 1 3 1 5 4 1 2 1 4 2 5 4 3 4 6 5 3 4 1 6 1 2 6 5 1 3 2 10 6 4 1 3 1 9 9 7 7 6 6 4 9 2 2 8 8 5 5 10 output copy 2 12 17 32
a-characteristic time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output consider an array a1,a2,…,an consisting of numbers 1 and −1 . define a -characteristic of this array as a number of pairs of indices 1≤i<j≤n , such that ai⋅aj=1 . find any array a with given length n with a -characteristic equal to the given value k . input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤100 ). the description of the test cases follows. the only line of each test case contains two integers n and k ( 2≤n≤100 ; 0≤k≤ (n−1)n 2 ) — the length of required array and required a -characteristic. output for each test case, if there is no array a with given a -characteristic k , print no. otherwise, print yes and n numbers 1 and −1 , which form the required array a . if there are multiple answers, print any of them. example input copy 7 2 0 2 1 3 1 3 2 3 3 5 4 5 5 output copy yes 1 -1 yes 1 1 yes 1 -1 1 no yes 1 1 1 yes -1 1 -1 1 1 no note in the first test case, there is only one pair of different elements in the array, and their product is a1⋅a2=−1≠1 , hence its a -characteristic is 0 . in the second test case, there is only one pair of different elements in the array, and their product is a1⋅a2=1 , hence its a -characteristic is 1 . in the third test case, there are three pairs of different elements in the array, and their product are: a1⋅a2=−1 , a1⋅a3=1 , a2⋅a3=−1 , hence its a -characteristic is 1 . in the fourth test case, we can show, that there is no array with length 3 , which a -characteristic is 2 .
two centroids time limit per test1.5 seconds memory limit per test1024 megabytes inputstandard input outputstandard output you are given a tree (an undirected connected acyclic graph) which initially only contains vertex 1 . there will be several queries to the given tree. in the i -th query, vertex i+1 will appear and be connected to vertex pi ( 1≤pi≤i ). after each query, please find out the least number of operations required to make the current tree has two centroids. in one operation, you can add one vertex and one edge to the tree such that it remains a tree. a vertex is called a centroid if its removal splits the tree into subtrees with at most ⌊ n 2 ⌋ vertices each, with n as the number of vertices of the tree. for example, the centroid of the following tree is 3 because the biggest subtree after removing the centroid has 2 vertices. in the next tree, vertex 1 and 2 are both centroids. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains a single integer n ( 2≤n≤5⋅105 ) — the number of nodes of the final tree. the second line of each test case contains n−1 integers p1,p2,…,pn−1 ( 1≤pi≤i ) — the index of the vertex that is connected to vertex i+1 . it is guaranteed that the sum of n over all test cases does not exceed 5⋅105 . output for each test case, output n−1 integers. the i -th integer is the answer to the i -th query — the least number of operations required to make the current tree have two centroids. we can show that an answer always exists. example input copy 5 2 1 3 1 1 4 1 2 3 7 1 2 3 2 5 2 10 1 2 2 4 5 5 7 8 9 output copy 0 0 1 0 1 0 0 1 0 1 2 3 0 1 2 1 0 1 0 1 2 note the illustrations below are of the fourth example test case. after the third query: the tree already has vertices 2 and 3 as centroids, so no operations are needed. after the fourth query: adding vertex x to the tree makes vertices 2 and 3 centroids. only one operation is needed. after the fifth query: adding vertex x and y to the tree makes vertices 5 and 2 centroids. two operations are needed. after the sixth query: adding vertex x , y , and z to the tree makes vertices 5 and 2 centroids. three operations are needed.
don't blame me time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output sadly, the problem setter couldn't think of an interesting story, thus he just asks you to solve the following problem. given an array a consisting of n positive integers, count the number of non-empty subsequences for which the bitwise and of the elements in the subsequence has exactly k set bits in its binary representation. the answer may be large, so output it modulo 109+7 . recall that the subsequence of an array a is a sequence that can be obtained from a by removing some (possibly, zero) elements. for example, [1,2,3] , [3] , [1,3] are subsequences of [1,2,3] , but [3,2] and [4,5,6] are not. note that and represents the bitwise and operation. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case consists of two integers n and k ( 1≤n≤2⋅105 , 0≤k≤6 ) — the length of the array and the number of set bits that the bitwise and the counted subsequences should have in their binary representation. the second line of each test case consists of n integers ai ( 0≤ai≤63 ) — the array a . it is guaranteed that the sum of n over all test cases doesn't exceed 2⋅105 . output for each test case, output a single integer — the number of subsequences that have exactly k set bits in their bitwise and value's binary representation. the answer may be large, so output it modulo 109+7 . example input copy 6 5 1 1 1 1 1 1 4 0 0 1 2 3 5 1 5 5 7 4 2 1 2 3 12 0 0 2 0 2 0 2 0 2 0 2 0 2 10 6 63 0 63 5 5 63 63 4 12 13 output copy 31 10 10 1 4032 15
ksyusha and chinchilla time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output ksyusha has a pet chinchilla, a tree on n vertices and huge scissors. a tree is a connected graph without cycles. during a boring physics lesson ksyusha thought about how to entertain her pet. chinchillas like to play with branches. a branch is a tree of 3 vertices. the branch looks like this. a cut is the removal of some (not yet cut) edge in the tree. ksyusha has plenty of free time, so she can afford to make enough cuts so that the tree splits into branches. in other words, after several (possibly zero) cuts, each vertex must belong to exactly one branch. help ksyusha choose the edges to be cut or tell that it is impossible. input the first line contains a single integer t ( 1≤t≤104 ) — number of testcases. the first line of each testcase contains a single integer n ( 2≤n≤2⋅105 ) — the number of vertices in the tree. the next n−1 rows of each testcase contain integers vi and ui ( 1≤vi,ui≤n ) — the numbers of vertices that the i -th edge connects. it is guaranteed that this set of edges forms a tree. it is also guaranteed that the sum of n over all testcases does not exceed 2⋅105 . output print the answer for each testcase. if the desired way to cut the tree does not exist, print −1 . otherwise, print an integer k — the number of edges to be cut. in the next line, print k different integers ei ( 1≤ei<n ) — numbers of the edges to be cut. if k=0 , print an empty string instead. if there are several solutions, you can print any. examples input copy 4 9 1 2 4 3 7 9 5 4 4 6 3 2 8 7 1 7 6 1 2 1 3 4 3 1 5 6 1 6 1 2 3 2 3 4 4 5 6 5 5 1 3 5 3 5 2 3 4 output copy 2 2 8 -1 1 3 -1 input copy 4 2 1 2 3 1 2 3 1 6 1 2 3 1 3 4 3 5 6 1 9 2 6 6 9 9 1 9 7 1 8 7 3 8 5 4 7 output copy -1 0 1 2 2 4 3 note the first testcase in first test.
luotianyi and the function time limit per test7 seconds memory limit per test1024 megabytes inputstandard input outputstandard output luotianyi gives you an array a of n integers and the index begins from 1 . define g(i,j) as follows: g(i,j) is the largest integer x that satisfies {ap:i≤p≤j}⊆{aq:x≤q≤j} while i≤j ; and g(i,j)=0 while i>j . there are q queries. for each query you are given four integers l,r,x,y , you need to calculate r ∑ i=l y ∑ j=x g(i,j) . input the first line contains two integers n and q ( 1≤n,q≤106 ) — the length of the array a and the number of queries. the second line contains n integers a1,a2,…,an ( 1≤ai≤n ) — the elements of the array a . next q lines describe a query. the i -th line contains four integers l,r,x,y ( 1≤l≤r≤n,1≤x≤y≤n ) — the integers in the i -th query. output print q lines where i -th line contains one integer — the answer for the i -th query. examples input copy 6 4 1 2 2 1 3 4 1 1 4 5 2 3 3 3 3 6 1 2 6 6 6 6 output copy 6 6 0 6 input copy 10 5 10 2 8 10 9 8 2 1 1 8 1 1 10 10 2 2 3 3 6 6 6 6 1 1 4 5 4 8 4 8 output copy 4 2 6 4 80 note in the first example: in the first query, the answer is g(1,4)+g(1,5)=3+3=6 . x=1,2,3 can satisfies {ap:1≤p≤4}⊆{aq:x≤q≤4} , 3 is the largest integer so g(1,4)=3 . in the second query, the answer is g(2,3)+g(3,3)=3+3=6 . in the third query, the answer is 0 , because all i>j and g(i,j)=0 . in the fourth query, the answer is g(6,6)=6 . in the second example: in the second query, the answer is g(2,3)=2 . in the fourth query, the answer is g(1,4)+g(1,5)=2+2=4 .
bully sort time limit per test10 seconds memory limit per test1024 megabytes inputstandard input outputstandard output on a permutation p of length n , we define a bully swap as follows: let i be the index of the largest element pi such that pi≠i . let j be the index of the smallest element pj such that i<j . swap pi and pj . we define f(p) as the number of bully swaps we need to perform until p becomes sorted. note that if p is the identity permutation, f(p)=0 . you are given n and a permutation p of length n . you need to process the following q updates. in each update, you are given two integers x and y . you will swap px and py and then find the value of f(p) . note that the updates are persistent. changes made to the permutation p will apply when processing future updates. input the first line of the input contains two integers n and q ( 2≤n≤5⋅105 , 1≤q≤5⋅104 ) — the length of the permutation and the number of updates. the second line of input contains n integer p1,p2,…,pn ( 1≤pi≤n ) — the permutation p . all elements of p are distinct. the i -th of the next q lines of input contains two integers xi and yi ( 1≤xi<yi≤n ) — describing the i -th update. output after each update, output f(p) . example input copy 8 5 6 2 1 5 3 4 7 8 1 8 2 3 4 7 7 8 3 6 output copy 5 6 9 8 7 note after the first update, we have f(p)=5 . the 5 bully swaps are illustrated below. [1,2,8,5,3,4,7,6] , [1,2,3,5,8,4,7,6] , [1,2,3,5,4,8,7,6] , [1,2,3,5,4,6,7,8] , [1,2,3,4,5,6,7,8] .
mr. perfectly fine time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output victor wants to become "mr. perfectly fine". for that, he needs to acquire a certain set of skills. more precisely, he has 2 skills he needs to acquire. victor has n books. reading book i takes him mi minutes and will give him some (possibly none) of the required two skills, represented by a binary string of length 2 . what is the minimum amount of time required so that victor acquires all of the two skills? input the input consists of multiple test cases. the first line contains an integer t ( 1≤t≤1000 ) — the number of test cases. the description of the test cases follows. the first line of each test case contains an integer n ( 1≤n≤2⋅105 ) — the number of books available. then n lines follow. line i contains a positive integer mi ( 1≤mi≤2⋅105 ) and a binary string of length 2 , where si1=1 if reading book i acquires victor skill 1 , and si1=0 otherwise, and si2=1 if reading book i acquires victor skill 2 , and si2=0 otherwise. it is guaranteed that the sum of n over all test cases doesn't exceed 2⋅105 . output for each test case, output a single integer denoting the minimum amount of minutes required for victor to obtain both needed skills and −1 in case it's impossible to obtain the two skills after reading any amount of books. example input copy 6 4 2 00 3 10 4 01 4 00 5 3 01 3 01 5 01 2 10 9 10 1 5 11 3 9 11 8 01 7 10 6 4 01 6 01 7 01 8 00 9 01 1 00 4 8 00 9 10 9 11 8 11 output copy 7 5 5 9 -1 8 note in the first test case, we can use books 2 and 3 , with a total amount of minutes spent equal to 3+4=7 . in the second test case, we can use the books 1 and 4 , with a total amount of minutes spent equal to 3+2=5 . in the third test case, we have only one option and that is reading book 1 for a total amount of minutes spent equal to 5 .
the third grace time limit per test5 seconds memory limit per test1024 megabytes inputstandard input outputstandard output you are given n intervals and m points on the number line. the i -th intervals covers coordinates [li,ri] and the i -th point is on coordinate i and has coefficient pi . initially, all points are not activated. you should choose a subset of the m points to activate. for each of n interval, we define its cost as: 0 , if there are no activated points in the interval; the coefficient of the activated point with the largest coordinate within it, otherwise. your task is to maximize the sum of the costs of all intervals by choosing which points to activate. input each test contains multiple test cases. the first line of input contains a single integer t ( 1≤t≤105 ) — the number of test cases. the description of test cases follows. the first line of each test case contains two integers n and m ( 1≤n≤106,1≤m≤106 ) — the number of intervals and the number of points. the following n lines of each test case contains two integers li and ri ( 1≤li≤ri≤m ) — the endpoints of the i -th interval. the following line of each test case contains m integers p1,p2,…,pm ( 0≤pi≤109 ) — the coefficients of the points. it is guaranteed that the sum of n does not exceed 106 and the sum of m does not exceed 106 . output output the maximum possible sum of costs of all intervals. example input copy 2 2 8 1 5 3 8 78 0 50 0 0 0 0 30 1 6 1 5 0 0 0 0 0 100 output copy 108 0 note in the first sample, we can activate points 1 and 8 . the sum of costs of all intervals will be 78+30=108 . in the second sample, we will activate no points. the sum of costs of all intervals will be 0 .
red-blue operations (hard version) time limit per test2 seconds memory limit per test256 megabytes inputstandard input outputstandard output the only difference between easy and hard versions is the maximum values of n and q . you are given an array, consisting of n integers. initially, all elements are red. you can apply the following operation to the array multiple times. during the i -th operation, you select an element of the array; then: if the element is red, it increases by i and becomes blue; if the element is blue, it decreases by i and becomes red. the operations are numbered from 1 , i. e. during the first operation some element is changed by 1 and so on. you are asked q queries of the following form: given an integer k , what can the largest minimum in the array be if you apply exactly k operations to it? note that the operations don't affect the array between queries, all queries are asked on the initial array a . input the first line contains two integers n and q ( 1≤n,q≤2⋅105 ) — the number of elements in the array and the number of queries. the second line contains n integers a1,a2,…,an ( 1≤ai≤109 ). the third line contains q integers k1,k2,…,kq ( 1≤kj≤109 ). output for each query, print a single integer — the largest minimum that the array can have after you apply exactly k operations to it. examples input copy 4 10 5 2 8 4 1 2 3 4 5 6 7 8 9 10 output copy 3 4 5 6 7 8 8 10 8 12 input copy 5 10 5 2 8 4 4 1 2 3 4 5 6 7 8 9 10 output copy 3 4 5 6 7 8 9 8 11 8 input copy 2 5 2 3 10 6 8 1 3 output copy 10 7 8 3 3
roads in e city time limit per test3 seconds memory limit per test256 megabytes inputstandard input outputstandard output this is an interactive problem. as is well known, the city "e" has never had its roads repaired in its a thousand and a half years old history. and only recently the city administration repaired some of them. it is known that in total in the city "e" there are n intersections and m roads, which can be used in both directions, numbered with integers from 1 to m . the i -th road connects intersections with numbers ai and bi . among all m roads, some subset of the roads has been repaired, but you do not know which one. the only information you could get from the city's road services is that you can get from any intersection to any other intersection by driving only on the roads that have been repaired. you are a young entrepreneur, and decided to organize a delivery service of fresh raw meat in the city "e" (in this city such meat is called "steaks", it is very popular among the locals). you have already recruited a staff of couriers, but the couriers are willing to travel only on repaired roads. now you have to find out which roads have already been repaired. the city administration has given you the city for a period of time, so you can make different queries of one of three types: block the road with the number x . in this case, movement on the road for couriers will be forbidden. initially all roads are unblocked. unblock the road with the number x . in this case, couriers will be able to move on the road x if it is repaired. try to deliver the order to the intersection with the number y . in this case, one of your couriers will start moving from intersection with number s you don't know and deliver the order to intersection with number y if there is a path on unblocked repaired roads from intersection s to intersection y . it is guaranteed that intersection s will be chosen beforehand. unfortunately, the city is placed at your complete disposal for a short period of time, so you can make no more than 100⋅m requests. input each test consists of multiple test cases. the first line contains a single integer t ( 1≤t≤1000 ) — the number of test cases. the description of test cases follows. the first line contains two integers n and m ( 2≤n≤2000 , n−1≤m≤2000 ) —the number of intersections and roads in the city "e". each of the following m lines describes one road. the i -th of these lines contains two integers ai and bi ( 1≤ai,bi≤n ) — the ends of the i -th road. it is guaranteed that no road connects the city to itself, while it is possible that there are several roads between a pair of different intersections. it is guaranteed that the sum of n and the sum of m over all test cases does not exceed 2000 . interaction once you have read the description of the test case, you can make queries. queries can be of three types: "- x " ( 1≤x≤m ). in this case the road with the number x is blocked if it has not already been blocked. "+ x " ( 1≤x≤m ). in this case the road with the number x is unblocked. note that road x must be blocked beforehand. all roads are initially unblocked. "? y " ( 1≤y≤n ). in this case the jury program chooses some city s . if you can get from town s to town y by unblocked repaired roads, the jury program will output 1 , otherwise the jury program will output 0 . note that city s will be selected before getting information about city y , but your previous requests may be taken into account when selecting city s . in total, you can make no more than 100⋅m queries for each set of input data. after you have found all repaired roads, output "! c1, c2, c3, …, cm ", where ci is 1 if road i is repaired, and 0 if road is not repaired. this output will not count in the total number of queries. the jury program will output 1 if your answer is correct, and 0 if the answer is not correct. if you received 0 , your program must terminate immediately to receive a wrong answer verdict. otherwise you can get any verdict, because the program will continue reading from the closed stream. if you read 1 , move on to the next test case, or terminate the program if there is none. note that you do not have to unblock all roads before outputting the answer. it is guaranteed that all repaired roads are fixed initially and will not be changed by the jury program depending on queries. after outputting a query or the answer do not forget to output the end of line and flush the output. otherwise, you will get idleness limit exceeded. to do this, use: fflush(stdout) or cout.flush() in c++; system.out.flush() in java; flush(output) in pascal; stdout.flush() in python; see the documentation for other languages. hacks you can't do hacks on this problem. example input copy 2 2 2 1 2 2 1 1 0 1 1 3 3 1 2 2 3 3 1 1 1 1 0 1 1 1 1 output copy - 1 ? 1 ? 2 - 2 + 1 ? 1 ! 1 0 - 1 ? 2 ? 1 - 2 ? 3 ? 3 + 1 ? 3 ? 2 ? 1 ! 1 1 1 note in the first test case, road 1 was repaired, while road 2 was not. for the first delivery request, intersection 1 was selected as s , and the path from intersection 1 to 1 exists. for the second delivery request, intersection 1 was selected as s . since the only repaired road was blocked, there was no path between intersections 1 and 2 . for the third delivery request, intersection 2 was selected as s , the path between intersections 2 and 1 exists along road 1 , which is repaired and unblocked. in the second test case, intersections 1 , 3 , 1 , 2 , 2 , 3 , 1 were selected as starting intersections for delivery requests.
bus routes time limit per test2.5 seconds memory limit per test1024 megabytes inputstandard input outputstandard output there is a country consisting of n cities and n−1 bidirectional roads connecting them such that we can travel between any two cities using these roads. in other words, these cities and roads form a tree. there are m bus routes connecting the cities together. a bus route between city x and city y allows you to travel between any two cities in the simple path between x and y with this route. determine if for every pair of cities u and v , you can travel from u to v using at most two bus routes. input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤104 ). the description of the test cases follows. the first line of each test case contains two integers n and m ( 2≤n≤5⋅105,0≤m≤5⋅105 ) — the number of cities and the number of bus routes. then n−1 lines follow. each line contains two integers u and v denoting a road connecting city u and city v ( 1≤u,v≤n,u≠v ). it is guaranteed that these cities and roads form a tree. then m lines follow. each line contains two integers x and y denoting a bus route between city x and city y ( 1≤x,y≤n ). it is guaranteed that the sum of n over all test cases does not exceed 5⋅105 and the sum of m over all test cases does not exceed 5⋅105 . output for each test case, output "yes" if you can travel between any pair of cities using at most two bus routes. otherwise, output "no". in the next line, output two cities x and y ( 1≤x,y≤n ) such that it is impossible to reach city y from city x using at most two bus routes. you can output the answer in any case (upper or lower). for example, the strings "yes", "yes", "yes", and "yes" will be recognized as positive responses. example input copy 4 5 2 1 2 2 3 3 4 2 5 1 4 5 2 5 1 1 2 2 3 3 4 2 5 1 5 2 0 1 2 6 3 1 2 2 3 3 4 4 5 5 6 1 3 2 5 4 6 output copy yes no 1 3 no 1 2 no 1 6 note here are the graphs of test case 1 , 2 , and 4 : sample 1 sample 2 sample 4
black cells time limit per test4 seconds memory limit per test256 megabytes inputstandard input outputstandard output you are playing with a really long strip consisting of 1018 white cells, numbered from left to right as 0 , 1 , 2 and so on. you are controlling a special pointer that is initially in cell 0 . also, you have a "shift" button you can press and hold. in one move, you can do one of three actions: move the pointer to the right (from cell x to cell x+1 ); press and hold the "shift" button; release the "shift" button: the moment you release "shift", all cells that were visited while "shift" was pressed are colored in black. (of course, you can't press shift if you already hold it. similarly, you can't release shift if you haven't pressed it.) your goal is to color at least k cells, but there is a restriction: you are given n segments [li,ri] — you can color cells only inside these segments, i. e. you can color the cell x if and only if li≤x≤ri for some i . what is the minimum number of moves you need to make in order to color at least k cells black? input the first line contains a single integer t ( 1≤t≤104 ) — the number of test cases. the first line of each test case contains two integers n and k ( 1≤n≤2⋅105 ; 1≤k≤109 ) — the number of segments and the desired number of black cells, respectively. the second line contains n integers l1,l2,…,ln ( 1≤l1<l2<⋯<ln≤109 ), where li is the left border of the i -th segment. the third line contains n integers r1,r2,…,rn ( 1≤ri≤109 ; li≤ri<li+1−1 ), where ri is the right border of the i -th segment. additional constraints on the input: every cell belongs to at most one segment; the sum of n doesn't exceed 2⋅105 . output for each test case, print the minimum number of moves to color at least k cells black, or −1 if it's impossible. example input copy 4 2 3 1 3 1 4 4 20 10 13 16 19 11 14 17 20 2 3 1 3 1 10 2 4 99 999999999 100 1000000000 output copy 8 -1 7 1000000004 note in the first test case, one of the optimal sequences of operations is the following: move right: pointer is moving into cell 1 ; press shift; release shift: cell 1 is colored black; move right: pointer is moving into cell 2 ; move right: pointer is moving into cell 3 ; press shift; move right: pointer is moving into cell 4 ; release shift: cells 3 and 4 are colored in black. we've colored 3 cells in 8 moves. in the second test case, we can color at most 8 cells, while we need 20 cell to color. in the third test case, one of the optimal sequences of operations is the following: move right: pointer is moving into cell 1 ; move right: pointer is moving into cell 2 ; move right: pointer is moving into cell 3 ; press shift; move right: pointer is moving into cell 4 ; move right: pointer is moving into cell 5 ; release shift: cells 3 , 4 and 5 are colored in black. we've colored 3 cells in 7 moves.
indivisible time limit per test1 second memory limit per test256 megabytes inputstandard input outputstandard output you're given a positive integer n . find a permutation a1,a2,…,an such that for any 1≤l<r≤n , the sum al+al+1+⋯+ar is not divisible by r−l+1 . a permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. for example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation ( 2 appears twice in the array), and [1,3,4] is also not a permutation ( n=3 but there is 4 in the array). input each test contains multiple test cases. the first line contains the number of test cases t ( 1≤t≤100 ). description of the test cases follows. the first line of each test case contain a single integer n ( 1≤n≤100 ) — the size of the desired permutation. output for each test case, if there is no such permutation print −1 . otherwise, print n distinct integers p1,p2,…,pn ( 1≤pi≤n ) — a permutation satisfying the condition described in the statement. if there are multiple solutions, print any. example input copy 3 1 2 3 output copy 1 1 2 -1 note in the first example, there are no valid pairs of l<r , meaning that the condition is true for all such pairs. in the second example, the only valid pair is l=1 and r=2 , for which a1+a2=1+2=3 is not divisible by r−l+1=2 . in the third example, for l=1 and r=3 the sum a1+a2+a3 is always 6 , which is divisible by 3 .
