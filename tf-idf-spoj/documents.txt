- shamans mmind - the game of master-mind decorate - decorate the wall wpuzzles - word puzzles kpmaze - maze bsheep - build the fence ofbeat - officers on the beat dance - the gordian dance alicebob - alice and bob aggrcow - aggressive cows cylinder - cylinder tcount3 - counting triangles iii delcomm - del command palace - accomodate the palace arctan - use of function arctan eqdiv - equidivisions lemon - lemon tree in the moonlight fraction - sort fractions div15 - divisibility by 15 cover - k-path cover mincount - move to invert palin - the next palindrome multiply - fast multiplication again sudoku - sudoku dice1 - dice contest empty - empty cuboids game - game schedule required pstring - remove the string roman - converting number formats cltz - collatz import1 - the importance jride - jill rides again crypto2 - the bytelandian cryptographer (act ii) sumfour - 4 values whose sum is 0 nsystem - numeral system hknap - huge knap sack holiday1 - getting rid of the holidays (act i) eights - triple fat ladies jasiek - jasiek tripart - triangle partitioning book - booklets mland - land for motorways comcb - complete chess boards aprime - anti-prime sequences pon - prime or not fpolice - fool the police palsec - choosing a palindromic sequence hangover - hangover empodia - empodia rnumber - random number bulk - the bulk! menu - menu mtwalk - mountain walking coins - bytelandian gold coins ufast - unite fast exchng - exchanges commedia - commedia dell arte tour - fake tournament tomjerry - tom and jerry rent - rent your airplane and make money shop - shopping hashit - hash it! trank - team rankings service - mobile service phdisp - the philosophical dispute ctrick - card trick store - store-keeper cistfill - fill the cisterns pt07h - search in xml repeats - repeats archplg - the archipelago cubert - cube root sqrroot - square root crscntry - cross-country babtwr - tower of babylon high - highways billiard - billiard seqpar - partition the sequence treasury - royal treasury robot - robot number m solit - solitaire chris - on the way to find chris kppoly - projections of a polygon poker - poker rectng1 - rectangles liar - truth or not seq1 - 01 sequence hike - hike on a graph vfmul - very fast multiplication equ2 - yet another equation en - entrapment harefox - hares and foxes tperml - permutation generator fashion - fashion shows pt07a - play with a tree prlgame - a game of pearls toandfro - to and fro cmpls - complete the sequence! seq2 - another sequence problem rockets - rockets transp - transposing is fun loner - the loner necklace - necklace lostct - the secret of a lost city transmit - transmitters cz_prob1 - summing to a square prime optm - optimal marks dragon - greedy hydra split - split windows painttmp - paint templates stead - steady cow assignment assign - assignments cake - birthday cake binstirl - binary stirling numbers edit3 - editor ii qtree - query on a tree upsub - up subsequence pt07z - longest path in a tree propkey - the proper key abwords - ab-words pt07b - the easiest problem tfsets - triple-free sets firm - goods lifts - lifts blueeq3 - help blue mary please! (act iii) rain2 - outside it is now raining ftour - free tour sorting - sorting is easy spin - spin shaman - shamans mmind - the game of master-mind decorate - decorate the wall wpuzzles - word puzzles

the far bare land there lives a mysterious tribe. they suffer from drought every year but they stick to their faith in god that they will never leave their home land. to counter the dry weather the shamans in the tribe must pray during the hard time and hope the blessed rain will aid their production of food. there are 4 chief shamans in the tribe and each of them will choose a summit in the territory to proceed with his praying. the area in which the shamans' spells take effect will be the quadrangle they form, each of them being one of its vertices (which the god will see when he looks down from the high heavens). the land is quite full of pinch and punch and the tribe has selected quite a few peaks for the shamans to pray on. of course the area of the quadrangle is expected to be as large as possible so before the shamans actually go out, they will have to choose the 4 peaks that best suit their purpose. input one integer in the first line, stating the number of test cases, followed by a blank line. there will be not more than 80 tests. for each test case, the first line is an integer n (4 <= n <= 2000) stating the number of peaks. then n lines follow, each presenting the position of a peak, with two integers x, y (-20000 <= x, y <= 20000). the test cases will be separated by a single blank line. output a floating point number with exactly 1 digit precision: the maximum area the shamans can cover. example input: 2 4 0 0 1 0 1 1 0 1 4 0 0 0 1 1 1 1 0 output: 1.0 1.0
john has built a new long barn, with n (2 <= n <= 100,000) stalls. the stalls are located along a straight line at positions x1 ... xn (0 <= xi <= 1,000,000,000). his c (2 <= c <= n) cows don't like this barn layout and become aggressive towards each other once put into a stall. to prevent the cows from hurting each other, fj wants to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. what is the largest minimum distance? input t â€“ the number of test cases, then t test cases follows. * line 1: two space-separated integers: n and c * lines 2..n+1: line i+1 contains an integer stall location, xi output for each test case output one integer: the largest minimum distance. example input: 1 5 3 1 2 8 4 9 output: 3 output details: fj can put his 3 cows in the stalls at positions 1, 4 and 8, resulting in a minimum distance of 3.
are two separate, n-element sets of points of a two dimensional map: r and w. none triple of points from the set ruw is collinear. rockets earth-to-earth are located on points from the set r. enemy objects, which should be destroyed, are located on points from the set w. the rockets may fly only in the straight line and their trajectories cannot intersect. we are about to find for each rocket a target to destroy. task write a program which: reads from the standard input coordinates of the points from the sets r and w, finds the set of n pairwise not-intersecting segments, so that one end of each segment belongs to the set r, while the other belongs to the set w, writes the result into the standard output. input the number of test cases t is in the first line of input, then t test cases follow separated by an empty line. in the first line of each test case there is written one integer n, 1<=n<=10000, equal to the number of elements of the sets r and w. in each of the following 2n lines of the input one pair of integer numbers from the interval [-10000, 10000] is written. numbers in each pair are separated by a single space. they are coordinates of the point on a map (first coordinate x, then y). the first n lines comprise coordinates of the points from the set r, the last n lines comprise the points from the set w. in the (i+1)-th line there are coordinates of the point ri, in the (i+n+1)-th line there are coordinates of the point wi, 1<= i<= n. output the output for each test case should consist of n lines. in the i-th line there should be one integer k(i), such that the segment ri wk(i) belongs to the set of segments which your program found. (this means that the rocket from the point ri destroys an object in the point wk(i)). example sample input: 1 4 0 0 1 5 4 2 2 6 1 2 5 4 4 5 3 1 sample output: 2 1 4 3 warning: large input/output data, be careful with certain languages
you are given a 2a x 2b array. it is stored sequentially in memory in the usual way, first values in the first row, then values in the second one and so on. you would like to transpose it, but you don't have any additional memory. the only operation that you can perform is swapping contents of two memory cells. what is the minimal number of such operations required for transposition? input the first line of input contains the number of test cases c (1<=c<=100). each test case consists of two integers a, b (0 <= a + b <= 500000). output for each test case output the minimal number of swaps required to transpose an 2a x 2b array. as it can be quite large, you have to output its remainder when divided by 1000003 (yes, it's a prime number :). example input: 3 1 1 2 2 5 7 output: 1 6 3744
loner is a one-dimensional board game for a single player. the board is composed of squares arranged in a single line, some of which initially have pawns on them. the player makes a move by jumping with a pawn over a pawn on an adjacent field, to an empty square two fields to the right or left of its initial position. the pawn that was jumped over is removed directly after the move, as illustrated below. the game is considered won if exactly one pawn remains on the gaming board, and is lost if the player cannot make a move. given the initial state of the gaming board, your task is to determine whether it is possible for the player to win the game. input the input begins with the integer t, the number of test cases. then t test cases follow. each test cases begins with the positive integer n <= 32000, denoting the size of the gaming board. the second and last line of the test case description contains a sequence of n characters 0 or 1, without any white spaces. the i-th square of the board is occupied by a pawn at the start of the game iff the i-th character of this sequence is 1. output for each test case output the word yes if it is possible for the player to win the game for the presented starting configuration, or the word no in the opposite case. example sample input: 2 7 0110011 6 111001 sample output: yes no
are n points marked on a surface, pair (xi, yi) is coordinates of a point number i. let's call a necklace a set of n figures which fulfils the following rules. the figure #i consists of all such points (x, y) that (x - xi)2 + (y - yi)2 ≤ ri2, where ri ≥ 0. figures #i and #(i+1) intersect (1 ≤ i < n). figures #1 and #n intersect. all the rest pairs of figures do not intersect. write a program which takes points and constructs a necklace. input first line of input contains an integer t (1 ≤ t ≤ 45), equals to the number of testcases. then descriptions of t testcases follow. the first line of the description contains one integer number n (2 ≤ n ≤ 100). each of the next n lines contains two real numbers xi, yi (-1000 ≤ xi, yi ≤ 1000), separated by one space. it is guaranteed that at least one necklace exists for each testcase. output for each testcase your program should output exactly n lines. a line #i should contain real number ri (0 ≤ ri < 10000). to avoid potential accuracy problems, a checking program uses the following rules. figures #i and #j definitely do not intersect if ri + rj ≤ dij - 10-5. figures #i and #j definitely intersect if dij + 10-5 ≤ ri + rj. the case when dij - 10-5 < ri + rj < dij + 10-5 is decided in favour of a contestant. dij equals sqrt((xi - xj)2 + (yi - yj)2) in the rules above. example input: 1 4 0 0 10 0 10 10 0 10 output: 7 7 7 7
vietnamese the famous archaeologist blue mary has found a site of a lost city. she found 12 huge steles in the center of the city - called ice-peak city by her, on which there were many designs. blue mary named these designs ice-peak articles(ipa for short). unfortunately, she can't find ice-peak city any more after she returns to her lab. the only thing blue mary knows about ice-peak city is pictures of the designs on the steles. with her intelligence she soon comes up with the syntax of ipa. its bnf form is below. <ipa> ::=<sentence>{<sentence>} <sentence> ::=<noun phrase>{<verb phrase><noun phrase>}[<verb phrase>] <noun phrase>::=<noun>|[<adverb>]<noun phrase> <verb phrase>::=<verb>|[<adverb>]<verb phrase> <words> ::=<verb>|<noun>|<adverb> where nouns, verbs and adverbs are given by a dictionary which we will discuss later. | denotes or. things in [] will appear zero or one time. things in {} will appear zero or more times. blue mary has compiled a dictionary of words in ipa. since characters appeared in ipa only contain 26 different forms, we will use small latin letters 'a' to 'z' to represent. there are no seperators between words or sentences, so blue mary asks you to write a program which will split a correct ipa into minimum number of sentences, and split these sentences into minimum number of words. input the first line contains the number of words in the dictionary, no more than 1000. next lines contain the words in the form "x.y", one per line, where x is one of the characters 'n', 'v', 'a', denoting that the corresponding word is noun, verb or adverb, and y is a string of lowercase latin letters, whose length will be no nore than 20. the next line contains a correct ipa (contains only lowercase latin letters), ends with a dot(.). the length of the ipa will be no more than 5kb. output the first line contains the minimum number of sentences in ipa. the second line contains the minimum number of words in ipa, when given ipa is split into minimum number of sentences. example input: 11 n.table n.baleine a.silly n.snoopy n.sillysnoopy v.is v.isnot n.kick v.kick a.big v.cry sillysnoopyisnotbigtablebaleinekicksnoopysillycry. output: 2 9 time limit has been changed to 200 ms in total for all tests.
a wireless network with multiple transmitters sending on the same frequencies, it is often a requirement that signals don't overlap, or at least that they don't conflict. one way of accomplishing this is to restrict a transmitter's coverage area. this problem uses a shielded transmitter that only broadcasts in a semicircle. a transmitter t is located somewhere on a 1,000 square meter grid. it broadcasts in a semicircular area of radius r. the transmitter may be rotated any amount, but not moved. given n points anywhere on the grid, compute the maximum number of points that can be simultaneously reached by the transmitter's signal. figure 1 shows the same data points with two different transmitter rotations. all input coordinates are integers (0-1000). the radius is a positive real number greater than 0. points on the boundary of a semicircle are considered within that semicircle. there are 1-150 unique points to examine per transmitter. no points are at the same location as the transmitter. input consists of information for one or more independent transmitter problems. each problem begins with one line containing the (x,y) coordinates of the transmitter followed by the broadcast radius, r. the next line contains the number of points n on the grid, followed by n sets of (x,y) coordinates, one set per line. the end of the input is signalled by a line with a negative radius; the (x,y) values will be present but indeterminate. figures 1 and 2 represent the data in the first two example data sets below, though they are on different scales. figures 1a and 2 show transmitter rotations that result in maximal coverage. for each transmitter, the output contains a single line with the maximum number of points that can be contained in some semicircle. input: 25 25 3.5 7 25 28 23 27 27 27 24 23 26 23 24 29 26 29 350 200 2.0 5 350 202 350 199 350 198 348 200 352 200 995 995 10.0 4 1000 1000 999 998 990 992 1000 999 100 100 -2.5 output: 3 4 4
= \{p \mid p: \mathrm{prime} \wedge (\exists x_1, x_2 \in \mathbb{z}, p = x_1^2 + x_2^2) \}$ is the set of all primes that can be represented as the sum of two squares. the function $s_{p2}(n)$ gives the $n$th prime number from the set $s_{p2}$. now, given two integers $n$ ($0 < n < 501$) and $k$ ($0 < k < 4$), find $p(s_{p2}(n), k)$ where $p(a, b)$ gives the number of unordered ways to sum to the given total ‘$a$’ with ‘$b$’ as its largest possible part. for example: $p(5, 2) = 3$ (i.e. $2+2+1$, $2+1+1+1$, and $1+1+1+1+1$). here $5$ is the total with $2$ as its largest possible part. input the first line gives the number of test cases $t$ followed by $t$ lines of integer pairs, $n$ and $k$. constraints $0 < t < 501$ $0 < n < 501$ $1 < s_{p2}(n) < 7994$ $0 < k < 4$ output the $p(s_{p2}(n), k)$ for each $n$ and $k$. append a newline character to every test cases’ answer. example input: 3 2 2 3 2 5 3 output: 3 7 85
are given an undirected graph g(v, e). each vertex has a mark which is an integer from the range [0..231 – 1]. different vertexes may have the same mark. for an edge (u, v), we define cost(u, v) = mark[u] xor mark[v]. now we know the marks of some certain nodes. you have to determine the marks of other nodes so that the total cost of edges is as small as possible. input the first line of the input data contains integer t (1 ≤ t ≤ 10) - the number of testcases. then the descriptions of t testcases follow. first line of each testcase contains 2 integers n and m (0 < n <= 500, 0 <= m <= 3000). n is the number of vertexes and m is the number of edges. then m lines describing edges follow, each of them contains two integers u, v representing an edge connecting u and v. then an integer k, representing the number of nodes whose mark is known. the next k lines contain 2 integers u and p each, meaning that node u has a mark p. it’s guaranteed that nodes won’t duplicate in this part. output for each testcase you should print n lines integer the output. the kth line contains an integer number representing the mark of node k. if there are several solutions, you have to output the one which minimize the sum of marks. if there are several solutions, just output any of them. example input: 1 3 2 1 2 2 3 2 1 5 3 100 output: 5 4 100
is some very greedy animal. a hydra has 9 heads when he is born, and many more new heads will come out when he grows up. of course, some old heads will break off because of caducity. one day, a hydra with m heads finds a tree with n fruits on it. he is very delighted and wants to eat this tree instantly. since he has m heads, he must divide these n fruit into m groups, each group contains at least 1 fruit, and each head will eat a group of fruits. the biggest head among the m heads is named "boss", it must eat neither more nor less than k fruits, and, in the nature of things, the biggest fruit included. these fruits are connected by n-1 branches, and there exists a path made up with branches between each pair of fruit. if two fruit connected by a single branch is put in different groups, the corresponding two heads will break the branch and eat the two fruits, otherwise the corresponding head will eat the two fruits without breaking the branch. eating branches is not very comfortable of course, so every branch has a weight of illness, and the weight of illness of this hydra is the sum of the weights of illness of all branches he has eaten. your task is to help the hydra to minimize his weight of illness. the picture below is an example. n=8,m=2,k=4.the bigger head eats 4 fruits(full points), the smaller head eats 4 fruits(empty points). the branch signed by a thin segment is eaten by the hydra. input ten test cases(given one after another, you have to process all!). for each test case the first line contains 3 integers n(1<=n<=300),m(2<=m<=n),k(1<=k<=n), separated by single spaces. the n fruits are numbered 1..n, and the biggest fruit is always numbered 1. n-1 lines follow, each contains 3 integers i,j,k separated by spaces denoted that there is a branch between fruit i (1<=i<=n) and fruit j (1<=j<=n) and the weight of illness of this branch is k(0<=k<=100000). output ten lines, each contains a single integer - the minimum weight of illness of the hydra. if we can't divide the fruit into m groups, output "-1"(without quotes). example input: 8 2 4 1 2 20 1 3 4 1 4 13 2 5 10 2 6 12 3 7 15 3 8 5 [and 9 test cases more] output: 4 [and 9 test cases more] link after solving this problem you can try the problem dragon2.
dotty software company makes software that is displayed on inexpensive text based terminals. one application for this system has a main window that can be subdivided into further subwindows. your task is to take a description of the screen layout after a sequence of window splits and draw the minimum sized window grid that is consistent with the description. in this problem we will concentrate on the boundaries of windows, so all the characters inside of windows will be left blank. each window that is not further subdivided has a label. each label is a distinct uppercase letter. for a text terminal the boundaries of windows must be drawn with characters, chosen as follows: a capital letter label is placed in the upper left-hand corner of each undivided window. asterisks,'*', appear in corners of windows where there is not a label. dashes, '-', appear on upper and lower boundaries where there are not corners. vertical bars, '|', appear on side boundaries where there are not corners. for example, the sequence of splits below would generate window 1: initially there could be an application window labeled m, that is split next into left and right subwindows, adding label r, and the left subwindow is split into top and bottom subwindows, adding the label c. for each pattern of splits there is a binary tree of characters that can describe it. the window splitting and tree structures are described together, building up from the simplest cases. a window may be an undivided rectangle. such a window has a capital letter as label. the tree for the window contains just the label. a window may either be split into left and right subwindows or into top and bottom subwindows, and the corresponding trees have as root the boundary character for the split: a vertical line '|' or a horizontal dash '-' respectively. the root has left and right subtrees corresponding to the top and bottom or left and right subwindows respectively. tree 1, above, and trees 2-4, below, would be consistent with windows 1-4. note that tree 4 contains trees 2 and 3. the trees may be more succinctly expressed via a preorder traversal: the preorder traversal of a tree with just one node (containing a letter) is that letter. the preorder traversal of a tree with a left and a right subtree is the character from the root of the tree ('-' or '|') followed by the preorder traversal of the left subtree, and then the preorder traversal of the right subtree. the preorder traversals for trees 1 through 4 are |-mcr -|-abc-d|e-fg -p-|q|rst |-|-abc-d|e-fg-p-|q|rst each undivided window must have space for at least one character inside. hence each tree of splits will be associated with a minimum window size. windows 1-4 are minimum sized windows for trees 1-4. each window illustrates the fact that even in a minimum sized window, not all undivided windows contain only one character. consider tree 4 and window 4. the main window is split into a left window with tree 2 and right window with tree 3. the left window is like window 2, but the right window is not just like window 3. the heights of left and right subwindows must match, so the right window must be stretched. the stretching rule depends on a definition of the size of windows. for dimension calculations it is easiest to imagine that a window contains its interior and a half character wide boundary on all sides, so the total dimensions of a window are one more than the dimensions of the interior. hence the minimum dimensions of a window are 2 by 2, since a window must contain one character inside, and we add one for the boundary. this definition also means that the sum of the widths of left and right subwindows is the width of their enclosing window. the sum of the heights of top and bottom subwindows is the height of their enclosing window. the right window in window 4 must be stretched to match the height 10 of the left window. the right window is split into a top with tree p having minimum height 2 and a bottom with tree -|q|rst having minimum height 4. the rule for the dimensions in the stretched window is that the heights of the subwindows expand in proportion to their minimum heights, if possible. some symbols may help here: let d = 10 be the height of the combined stretched window. we want to determine d1 and d2, the stretched heights of the top and bottom subwindow. call the corresponding minimum dimensions d = 6, d1 = 2, and d2 = 4. if the window were expanded from a total height d to d in proportion, we would have d1 = d1*(d/d) = 2*(10/6) = 3.333...and d2 = d2*(d/d) = 6.666.... since the results are not integers we increase d1 to 4 and decrease d2 to 6. there is a similar calculation for the bottom window with tree -|q|rst. it is further subdivided into a top with tree |q|rs and a bottom with tree t, each having minimum height 2 = d1 = d2. the heights need to add up to d = 6, so they are increased proportionally to d1 = d2 = 2*(6/4) = 3 (exact integers). the final dimensions of an enclosing window are always determined before the final dimensions of its subwindows. in this example only heights needed to be apportioned. if all horizontal and vertical splits were interchanged in this example, producing a tree -|-|abc|d-e|fg|p|-q-rst, then widths would be apportioned correspondingly, as shown in the third part of the sample output below. if the proportion calculations do not work out to integers, it is always the top or left subwindow whose dimension is increased to the next integer. the first line of input contains one integer, which is the total number of preorder traversals describing window structures. this line is followed by one line for each preorder traversal. each preorder traversal will contain appropriate dividers '|' and '-' and from 1 to 26 uppercase letters. for each preorder traversal, print the number of the preorder traversal on one line followed by the minimum sized window grid that the traversal could represent. contrary to the general contest output conventions, there may be more than one consecutive blank in this output, but the other general rules for contest output are followed. the total number of rows or columns in output grids will be no more than 53. input: 3 |-mcr |-|-abc-d|e-fg-p-|q|rst -|-|abc|d-e|fg|p|-q-rst output: 1 m-r-* | | | c-* | | | | *-*-* 2 a-c-p-----* | | | | b-* | | | | | | d-*-q-r-s-* | | | | | e-f-* | | | | | t-*-*-* | g-* | | | | | *-*-*-----* 3 a-b-d-e---* | | | | | c-*-* f-g-* | | | | | p---q-*t*-* | | | | | r--* | | | | | | s--* | | | | | *---*--*--*
a sheet of paper and scissors, you can cut out two faces to form a cylinder in the following way: cut the paper horizontally (parallel to the shorter side) to get two rectangular parts. from the first part, cut out a circle of maximum radius. the circle will form the bottom of the cylinder. roll the second part up in such a way that it has a perimeter of equal length with the circle's circumference, and attach one end of the roll to the circle. note that the roll may have some overlapping parts in order to get the required length of the perimeter. given the dimensions of the sheet of paper, can you calculate the biggest possible volume of a cylinder which can be constructed using the procedure described above? input specification the input consists of several test cases. each test case consists of two numbers w and h (1 ≤ w ≤ h ≤ 100), which indicate the width and height of the sheet of paper. the last test case is followed by a line containing two zeros. output specification for each test case, print one line with the biggest possible volume of the cylinder. round this number to 3 places after the decimal point. sample input 10 10 10 50 10 30 0 0 sample output 54.247 785.398 412.095 in the first case, the optimal cylinder has a radius of about 1.591549, in the second case, the optimal cylinder has a radius of 5, and in the third case, the optimal cylinder has a radius of about 3.621795.
painter's studio is preparing mass production of paintings. paintings are going to be made with aid of square matrices of various sizes. a matrix of size i consists of 2i rows and 2i columns. there are holes on intersections of some rows and columns. matrix of size 0 has one hole. for i > 0, matrix of size i is built of four squares of size 2(i-1)*2(i-1). look at the following figure: both squares on the right side and the bottom-left square are matrices of size i-1. top-left square has no holes. pictures are constructed in the following way. first, we fix three non-negative integers n, x, y. next, we take two matrices of size n, place one of them onto the other and shift the upper one x columns right and y rows up. we place such a pattern on a white canvas and cover the common part of matrices with the yellow paint. in this way we get yellow stains on the canvas in the places where the holes in both matrices agree. example consider two matrices of size 2. the upper matrix was shifted 2 columns right and 2 rows up. there are three places where holes agree. task write a program that for each test case: reads the sizes of two matrices and the numbers of columns and rows that the upper matrix should be shifted by, from the standard input; computes the number of yellow stains on the canvas; writes the result to the standard output. input the number of test cases t is in the first line of input, then t test cases follow separated by an empty line. there is one integer n, 0 <= n <= 100 in the first line of each test case. this number is the size of matrices used for production of paintings. in the second line there is one integer x and in the third line one integer y, where 0 <= x,y <= 2n. the integer x is the number of columns and y is the number of rows that the upper matrix should be shifted by. output for each test case your program should produce one line with exactly one integer - the number of stains on the canvas. example sample input: 1 2 2 2 sample output: 3
john's n (1 <= n <= 1000) cows each reside in one of b (1 <= b <= 20) barns which, of course, have limited capacity. some cows really like their current barn, and some are not so happy. fj would like to rearrange the cows such that the cows are as equally happy as possible, even if that means all the cows hate their assigned barn. each cow gives fj the order in which she prefers the barns. a cow's happiness with a particular assignment is her ranking of her barn. your job is to find an assignment of cows to barns such that no barn's capacity is exceeded and the size of the range (i.e., one more than the positive difference between the the highest-ranked barn chosen and that lowest-ranked barn chosen) of barn rankings the cows give their assigned barns is as small as possible. input line 1: two space-separated integers, n and b lines 2..n+1: each line contains b space-separated integers which are exactly 1..b sorted into some order. the first integer on line i+1 is the number of the cow i's top-choice barn, the second integer on that line is the number of the i'th cow's second-choice barn, and so on. line n+2: b space-separated integers, respectively the capacity of the first barn, then the capacity of the second, and so on. the sum of these numbers is guaranteed to be at least n. output one integer, the size of the minimum range of barn rankings the cows give their assigned barns, including the endpoints example input: 6 4 1 2 3 4 2 3 1 4 4 2 3 1 3 1 2 4 1 3 4 2 1 4 2 3 2 1 3 2 output: 2
your task will be to calculate number of different assignments of n different topics to n students such that everybody gets exactly one topic he likes. input first line of input contains number of test cases c (1<=c<=80). each test case begins with number of students n (1<=n<=20). each of the next n lines contains n integers describing preferences of one student. 1 at the ith position means that this student likes ith topic, 0 means that he definitely doesn't want to take it. output for each test case output number of different assignments (it will fit in a signed 64-bit integer). example input: 3 3 1 1 1 1 1 1 1 1 1 11 1 0 0 1 0 0 0 0 0 1 1 1 1 1 1 1 0 1 0 1 0 0 1 0 0 1 0 0 1 1 0 1 0 1 0 1 1 1 0 1 1 0 1 1 0 1 1 1 0 1 0 0 1 1 1 1 1 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 1 0 1 1 0 0 0 0 0 0 1 0 0 1 0 1 1 0 0 0 1 1 1 1 1 0 0 0 1 0 1 0 1 1 0 0 0 1 1 1 1 0 0 0 11 0 1 1 1 0 1 0 0 0 1 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 0 0 0 1 0 0 1 0 1 0 1 0 1 0 1 1 1 0 0 1 0 0 0 0 1 0 1 0 0 1 0 1 1 0 0 0 0 1 1 0 1 0 1 1 1 0 1 1 0 1 0 1 1 0 1 1 0 0 1 0 0 0 1 1 0 1 1 1 1 1 1 0 1 0 0 0 0 0 0 0 1 1 0 1 1 0 0 0 0 0 1 0 1 output: 6 7588 7426
wants to send a cake to blue mary to celebrate her birthday. the cake looks like a tower which has m floors, each floor is a cylinder. the i-th cylinder counted from downside to upside has a integer height hi and a integer radius ri. these numbers fulfill the following two conditions: h1 > h2 > h3 > ... > hm r1 > r2 > r3 > ... > rm adolf is interested in minimising the area of the surface of the cake, except for the underside of the lowest cylinder. he needs your help because of his poor math knowledge. input the very first line contains a integer number t. t test cases follow. for each test case, the first line contains a single integer number n (n<=10000), the second line contains a single integer number m (m<=10). the cake must be made of m cylinders and its volume must be n*pi (pi = acos(-1.0)). output for each test case, a single line containing a single integer s must be written to output. the required minimum area must be s*pi. example sample input: 1 100 2 sample output: 68
stirling number of the second kind s(n, m) stands for the number of ways to partition a set of n things into m nonempty subsets. for example, there are seven ways to split a four-element set into two parts: {1, 2, 3} u {4}, {1, 2, 4} u {3}, {1, 3, 4} u {2}, {2, 3, 4} u {1}, {1, 2} u {3, 4}, {1, 3} u {2, 4}, {1, 4} u {2, 3}. there is a recurrence which allows you to compute s(n, m) for all m and n. s(0, 0) = 1, s(n, 0) = 0, for n > 0, s(0, m) = 0, for m > 0, s(n, m) = m*s(n-1, m) + s(n-1, m-1), for n, m > 0. your task is much "easier". given integers n and m satisfying 1 <= m <= n, compute the parity of s(n, m), i.e. s(n, m) mod 2. for instance, s(4, 2) mod 2 = 1. task write a program that: reads two positive integers n and m, computes s(n, m) mod 2, writes the result. input the first line of the input contains exactly one positive integer d equal to the number of data sets, 1 <= d <= 200. the data sets follow. line i + 1 contains the i-th data set - exactly two integers ni and mi separated by a single space, 1 < = mi < = ni <= 109. output the output should consist of exactly d lines, one line for each data set. line i, 1 <= i < = d, should contain 0 or 1, the value of s(ni, mi) mod 2. example sample input: 1 4 2 sample output: 1
after trying to solve problem edit1(editor) and being ****ed by brainf**k, blue mary decided to set another difficult problem about editor. description some definitions: text: it's a sequence that consists characters whose ascii code is in [32,126]. cursor: it's a sign for pointing out the current position. it can be at the start or the end of the text or between two consecutive characters of the text. editor is a structure. it contains one text and one cursor. the operations are listed below: -------------------------------------------------------------------------- | name | input format | function | -------------------------------------------------------------------------- | move(k) | move k | move the cursor after the kth character | | | | in the text. if k=0, you should put | | | | the cursor at the start of the text. | -------------------------------------------------------------------------- | insert(n,s) | insert n s | insert string s whose length is n(>=1) | | | | after the cursor. the cursor doesn't move.| -------------------------------------------------------------------------- | delete(n) | delete n | delete n(>=1) characters after the cursor.| | | | the cursor doesn't move. | -------------------------------------------------------------------------- | get(n) | get n | output n(>=1) characters after the cursor.| -------------------------------------------------------------------------- | prev() | prev | move the cursor one character backward. | -------------------------------------------------------------------------- | next() | next | move the cursor one character forward. | -------------------------------------------------------------------------- if the text of a editor is empty, we say the editor is empty. here is an example._ denotes to the cursor,$ denotes to the start and the end. at start the editor is empty. ------------------------------------------------------------------------------ | operation | text after the operation | output | ------------------------------------------------------------------------------ | insert(13,"balanced tree") | $_balanced tree$ | $$ | ------------------------------------------------------------------------------ | move(2) | $ba_lanced tree$ | $$ | ------------------------------------------------------------------------------ | delete(5) | $ba_d tree$ | $$ | ------------------------------------------------------------------------------ | next() | $bad_ tree$ | $$ | ------------------------------------------------------------------------------ | insert(7," editor") | $bad_ editor tree$ | $$ | ------------------------------------------------------------------------------ | move(0) | $_bad editor tree$ | $$ | ------------------------------------------------------------------------------ | get(15) | $_bad editor tree$ | $bad editor tree$ | ------------------------------------------------------------------------------ your task is: build an empty editor. read some operations from the standard input and operate them. for each get operation, write the answer to the output. input the very first line contains the number of testcases t(t<=4).t tests follow. for each test, the first line is the number of operations n.n operations follow. blue mary is so depressed with the problem edit1 that she decides to make the problem more difficult. so she inserts many extra line breaks in the string of the insert operation. you must ignore them. except line breaks, all the characters' ascii code are in [32,126]. there's no extra space at the end of a line. you can assume that for each test case: no invalid operation is in the input. number of move operations is no more than 50000. number of the total of insert and delete operations is no more than 4000. number of the total of prev and next operations is no more than 200000. the characters inserted will not more than 2mb.the valid output will not more than 3mb. output the output should contain t blocks corresponding to each testcase. for each test case, the output should contain as many lines as the get operations in the input. each line should contains the output of each get operation. example input: 1 15 insert 26 abcdefghijklmnop qrstuv wxy move 15 delete 11 move 5 insert 1 ^ next insert 1 _ next next insert 4 .\/. get 4 prev insert 1 ^ move 0 get 22 output: .\/. abcde^_^f.\/.ghijklmno warning: large input/output data, be careful with certain languages
are given a tree (an acyclic undirected connected graph) with n nodes, and edges numbered 1, 2, 3...n-1. we will ask you to perfrom some instructions of the following form: change i ti : change the cost of the i-th edge to ti or query a b : ask for the maximum edge cost on the path from node a to node b input the first line of input contains an integer t, the number of test cases (t <= 20). t test cases follow. for each test case: in the first line there is an integer n (n <= 10000), in the next n-1 lines, the i-th line describes the i-th edge: a line with three integers a b c denotes an edge between a, b of cost c (c <= 1000000), the next lines contain instructions "change i ti" or "query a b", the end of each test case is signified by the string "done". there is one blank line between successive tests. output for each "query" operation, write one integer representing its result. example input: 1 3 1 2 1 2 3 2 query 1 2 change 1 3 query 1 2 done output: 1 3
x = a0a1a2...an-1 is a string where ai denotes the character at index i, a subsequence aj0aj1aj2...ajn is called an upsubsequence if aj0 <= aj1 <= aj2 <= ... <= ajn and j0 < j1 < j2 < ... < jn. a maximal upsubsequence of a string is defined as the upsubsequence of maximum length. buggyd observes that a string x can have many maximal upsubsequences. help him find all the maximal upsubsequences in x. input the first line of the input contains an integer t, the number of test cases. t test cases follow. each test case consists of a single line containing a string x, where the length of x is no more than 100. x will not contain any spaces, tabs or other whitespace characters. output for each test csae, output all of the maximal upsubsequences of x in lexicographical order. print a blank line after each test case. example input: 1 abcbcbcd output: abbbcd abbccd abcccd
are given an unweighted, undirected tree. write a program to output the length of the longest path (from one node to another) in that tree. the length of a path in this case is number of edges we traverse from source to destination. input the first line of the input file contains one integer n --- number of nodes in the tree (0 < n <= 10000). next n-1 lines contain n-1 edges of that tree --- each line contains a pair (u, v) means there is an edge between node u and node v (1 <= u, v <= n). output print the length of the longest path on one line. example input: 3 1 2 2 3 output: 2
people think that tetris was invented by two russian programmers. but that is not the whole truth. the idea of the game is very old -- even the egyptians had something similar. but they did not use it as a game. instead, it was used as a very complicated lock. the lock was made of wood and consisted of a large number of square fields, laid out in regular rows and columns. each field was either completely filled with wood, or empty. the key for this lock was two-dimensional and it was made by joining square parts of the same size as the fields of the lock. so they had a 2d lock and 2d key that could be inserted into the lock from the top. the key was designed so that it was not possible to move it upwards. it could only fall down and it could slide sideways -- exactly like in a tetris game. the only difference is that the key could not be rotated. rotation in tetris is really a russian invention. the entry gate into the pyramid has such a lock. the acm archaeologists have found several keys and one of them belongs to the lock with a very high probability. now they need to try them out and find which one to use. because it is too time-consuming to try all of them, it is better to begin with those keys that may be inserted deeper into the lock. your program should be able to determine how deep a given key can be inserted into a given lock. input the input consists of t test cases. the number of them (t) is given on the first line of the input file. each test case begins with a line containing two integers r and c (1 <= r,c <= 100) indicating the key size. then exactly r rows follow, each containing c characters. each character is either a hash mark (#) or a period (.). a hash mark represents one square field made of wood; a period is an empty field. the wooden fields are always connected, i.e. the whole key is made of one piece. moreover, the key remains connected even if we cut off arbitrary number of rows from its top. there is always at least one non-empty field in the top-most and bottom-most rows and the left-most and right-most columns. after the key description, there is a line containing two integers d and w (1 <= d <= 10000, 1 <= w <= 1000). the number w is the lock width, and d is its depth. the next d lines contain w characters each. the character may be either a hash mark (representing the wood) or a period (the free space). output your program should print one line of output for each test case. the line should contain the statement "the key falls to depth x.". replace x with the maximum depth to which the key can be inserted by moving it down and sliding it to the left or right only. the depth is measured as the distance between the bottom side of the key and the top side of the lock. if it is possible to move the key through the whole lock and take it away at the bottom side, output the sentence "the key can fall through.". example sample input: 4 2 4 #.## ###. 3 6 #....# #....# #..### 2 3 ##. .## 2 7 #.#.#.# .#.#.#. 1 1 # 1 10 ###....### 3 2 ## .# .# 1 5 #.#.# sample output: the key falls to depth 2. the key falls to depth 0. the key can fall through. the key falls to depth 2. warning: large input/output data, be careful with certain languages
you felt bored when counting triangles? like tricount and tcount2, we define the level of a triangle as in the following illustrative image: and now we will continue defining the level of a hexagram. it's called level n hexagram if itâ€™s joined by 12 triangles, each one is a level n triangle. task: all you have to do is to count all triangles in the level n hexagram. input the first line of the input contains an integer t - the number of test cases and t lines follow. each line contains an integer n which is the level of the hexagram in that test case. output for each test case, you should write a separate line: the number of triangles in the level n hexagram. (all answers will fit within the range of a 64-bit positive integer) example input: 1 1 output: 20 the author allows only few languages
sequence of small letters a and b (also the empty sequence) is called an ab-word. if x = [x1, ..., xn] is an ab-word and i, j are integers such that 1 <= i <= j <= n then x[i..j] denotes the subword of x consisting of the letters xi, ..., xj. we say that an ab-word x = [x1..xn] is nice if it has as many letters a as b and for all i = 1, ..., n the subword x[1..i] has at least as many letters a as b. now, we give the inductive definition of the similarity between nice ab-words. every two empty ab-words (i.e. words with no letters) are similar two non-empty nice ab-words x = [x1, ..., xn] and y = [y1, ..., ym] are similar if they have the same length (n = m) and one of the following conditions if fulfilled: x1 = y1, xn = yn and x[2..n-1] and y[2..n-1] are similar ab-words and they are both nice; there exists i, 1 <= i <= n, such that x[1..i], x[i+1..n] are nice ab-words and y[1..i], y[i+1..n] are nice ab-words and x[1..i] is similar to y[1..i] and x[i+1..n] is similar to y[i+1..n], or y[1..n-i], y[n-i+1..n] are nice ab-words and x[1..i] is similar to y[n-i+1..n] and x[i+1..n] is similar to y[1..n-i]. a level of diversity of a non-empty set s of nice ab-words is the maximal number of ab-words that can be chosen from s in such a way that for each pair w1,w2 of chosen words, w1 is not similar to w2. task write a program that for each test case: reads elements of s from standard input; computes the level of diversity of the set s; writes the result to standard output. input the number of test cases t is in the first line of input, then t test cases follow separated by an empty line. in the first line of a test case there is a number n of elements of the set s, 1 <= n <= 1000; in the following n lines there are elements of the set s, i.e. nice ab-words (one word in each line); the first letter of every ab-word is the first symbol in line and there are no spaces between two consecutive letters in the word; the length of every ab-word is an integer from the range [1..200]. output for each test case your program should output one line with one integer - the level of diversity of s. example sample input: 1 3 aabaabbbab abababaabb abaaabbabb sample output: 2
are given an unweighted, undirected tree t. we say t is special iff it has this property: "all nodes of degree greater than or equal to 3 are surrounded by at most two nodes of degree two or greater." finding maximal size subtree of this tree so that it's a special tree. input the first line of the input file contains one integer n --- number of nodes in the tree (0 < n <= 106). next n-1 lines contain n-1 edges of that tree --- each line contains a pair (u, v) means there is an edge between node u and node v (1 <= u, v <= n). output at the first line, output number of nodes in the optimal subtree you found. next lines, print all edges belong to that subtree, each line contains a pair u v means an edge between node u and node v. example input: 5 1 2 2 3 2 4 2 5 output: 5 1 2 2 3 2 4 2 5
set s of positive integers is called strongly triple-free if, for any integer x, the sets {x, 2x} and {x, 3x} are not subsets of s. let's define f(n) as a number of strongly triple-free subsets of {1, 2, ..., n}, where n is a natural number. you need to write a program which being given a number n calculates the number f(n) modulo 1 000 000 001. input the first line of input contains integer t (1 ≤ t ≤ 500) - the number of testcases. then descriptions of t testcases follow. the description of the testcase consists of one line. the line contains an integer number n (1 ≤ n ≤ 100 000). output for each testcase in the input your program should output one line. this line should contain one integer number which is the number f(n) modulo 1 000 000 001. example input: 5 3 1 10 20 39 output: 5 2 198 43776 971827200
are n dealers in the market. each of them has some unique goods (nobody else has the same goods). besides, each of them wants to obtain some other goods, which exist in the market. this is rather strange, but for each kind of goods on the market there exists exactly one dealer who wants to obtain it. to prevent fraud, only exchanges in pairs are allowed in this market. moreover, each dealer is allowed to make at most one exchange a day. but the total number of transactions isnâ€™t limited. a transaction means that all the goods of one dealer are exchanged for all the goods of the other participating dealer (partial transactions are not allowed). you are to write a program which outputs the minimum number of days needed for each dealer to get the goods that he wants. also output one of the possible variants of exchanges leading to this goal. input the first line contains an integer n [n <= 5000]. in the second line exactly n numbers of goods are given, which the dealers require. if integer j appears as the i-th at input, then this means that goods required by dealer i are initially owned by dealer j. output you must output the minimum number of days m which are needed to complete the transactions. in the next m lines you must output the way these transactions should be managed by the dealers. one line corresponds to one day. at the beginning of each line you must output the number of transactions on this day. after that output the pairs of dealers who exchange their goods on this day. dealers in pairs are separated by '-' symbol. if there are many ways to perform the exchanges then output any of them. example input: 7 2 1 3 5 6 7 4 output: 2 3 1-2 4-5 7-6 1 5-7 author: filimonenkov d.o.
likes old games very much. recently he has found one arcade game in his computer. when controlling the hero it is necessary to move on a map and collect various items. at a certain stage of the game serj has faced an unexpected problem. to continue his adventures the hero should get past over a chasm. for this purpose it is possible to use consistently located lifts which look like horizontal platforms. each lift moves up-down vertically between some levels. the hero can pass between the next adjacent platform, however it can be done only at the moment when they are at the same level. similarly, passing from the edge of a chasm onto the lift and vice versa is only possible at the moment when the lift appears on the level of the edge. each lift has a width equal to 4 meters. at the beginning the hero is in at a distance of two meters from the edge of a chasm. he should finish travel two meters after the opposite edge of the chasm. the hero moves at a speed of 2 meters a second. thus, if the hero is in the initial position or in the center of the lift and wishes to pass to the next lift (or to descend from last lift onto the opposite edge of a chasm), he should begin movement exactly one second before they meet at one level. in two seconds the hero appears in the center of the next lift (or in the final position on the other side). the edges of the chasm are at the same level. for each lift the range of heights between which it moves, its initial position and the direction of movement at the initial moment are given. all lifts move with a speed of one meter a second. find out whether the hero can get over to the opposite edge of the chasm, and if so what the minimal time required for this purpose is. input t â€“ the number of test cases, then t test cases follows. [empty line] a test case begins with n - the number of lifts, a positive integer (n <= 100), then n lines follow. the i-th line (0 < i <= n) contains four integers li ui si di, where: li - lowest position of the lift, ui - highest position of the lift, si - initial position of the lift, di - initial direction of movement (1 means up, -1 means down); (-100 <= li <= si <= ui <= 100, l1 < ui). output for each test case output the minmal time in seconds, required to get to the opposite edge of the chasm. if it is impossible output -1. example input: 1 4 -1 2 1 -1 0 3 0 1 -4 0 0 -1 -2 1 0 -1 output: 29
this morning blue mary wrote some equations on a piece of paper and left it on her desk.after solving some problems in spoj,she found that her classmate h.l. replaced all characters on the paper with some other ones.h.l. told her he replaced the same characters with the same ones,and different characters with different ones because of his goodness.now mary needs your help to get the original equations back.(see problem blueeq) input ten test cases(given one after another,you have to process all!)for each test case, the first line is a single integer n(n<=21).next 3 lines contains 3 strings, each of them has a length of n and contains only first n capital latin characters.the sum of the numbers the first two strings indicates equals to the number the third string incicates.the numbers can have leading zeros and each of their bases is n. output for each test case you should output one line contains n numbers separated by spaces, which is a permutation of integer numbers 0 to n-1.number x is on the k-th position iff x is replaced by the kth capital latin character.there is one and only one solution for each test case. example input: 5 abced bdace ebbaa [and 9 test cases more] output: 1 0 3 4 2 [and 9 test cases more]
m is pluvian. in city p, it rains frequently and many people complain that they always have trouble crossing the streets when raining. to make people cross the streets easier, the government set many "automatic umbrellas" above every crosswalk, shown in the picture below. each of these "automatic umbrellas" looks like a rectangle board, and their thickness is approximate zero. they can sop up the rain instantly. they are left unused when it's not raining and shuttle from one side to another in the same speed otherwise. the walkers will not be wringing-wet if he walks under the umbrella when it's raining. when many people want to cross the street, one "automatic umbrella" is not enough obviously. the government set many "automatic umbrella" on some main crosswalks. the width of each of the "automatic umbrella" equals to the width of the crosswalk, and any two of these umbrellas have different height. their length and speed may be different. you are to write a program to calculate the total volume of the rain falling to the ground from the time when it starts to rain to t seconds later. input the very first line comes a single integer q, the number of test cases. q blocks follow. for each test case: the first line contains 4 space-separated integers n (<=10), w (<=100), t (<=100), v (<=50), the number of "automatic umbrella", the length of the crosswalk in meters, the total time in seconds and the volume of rain falling to the ground per square meter per second. to simplify the description, we can build a cartesian coordinate system in the following way: let the left side of the street be the origin, the street be the positive ox-axes, and the vertical line to the ground be the positive oy-axes, see the picture below. each of the next n lines contains 3 integers xi, li, vi, the initial position(in meter), the length(in meter), the speed(in meter per second) of the i-th umbrella. if vi>0, the umbrella moves to the right side initially; if vi<0, the umbrella moves to the left side initially; if vi=0, the umbrella doesn't move at all. you can assume that the width of the umbrella and the crosswalk is 1 meter, the rain falls vertically, the speed of the rain will not change and the umbrellas and the crosswalk are absolutely horizontal. output for each test case, you should output a single real number(rounded to 2 decimal places) - the answer. you can assume the total distance of all the umbrella's movement will not exceed 550*w. example input: 1 2 4 3 10 0 1 1 3 1 -1 output: 65.00
order to celebrate the 2nd anniversary of travel agent spoj (safe – professional – hospitable – joyful), the management intend to hold free tours around cities for clients to make them more satisfied with spoj. a tour is a simple cycle, starting at any city (called a source-city) visits some other cities (each city must be visited at most once) and then returns to the source-city. the number of roads in the tour should be an even number because we are celebrating a 2nd anniversary, and 2 is even! since many tours in different areas of the country are planned, the cost of organising them could turn out quite high. hence, the management of spoj hope to find at least one 'reasonable' tour, which should have as small a number of roads as possible. you're given maps of the areas where spoj wants to hold free tours. for each map, help them figure out a reasonable tour. input the first line of input contains an integer t, the number of maps (t <= 5). t maps follow. for each map: in the first line there are 2 integers n – number of cities in that area, m – number of roads (1 <= n <= 8000, 0 <= m <= 10000) in the next m lines, the i-th line describes the i-th road: a line with two integers a b denotes a bidirectional road between city a and city b there is one blank line between successive tests. output for each map, if there is no tour satisfying the conditions, write "-1" (without quotes). otherwise, write one integer representing the number of roads in a reasonable tour, and in the next line show out the tour with form "source-city a b c ... source-city", that means the tour is source-city → city a → city b → … → source-city. if there are many tours satisfy in each map, any of them will be accepted. example input: 2 3 3 1 2 2 3 3 1 4 4 1 2 2 3 3 4 4 1 output: -1 4 1 2 3 4 1
you think sorting is easy? try your luck in brainfuck for those who don't know that brainfuck is a programming language: take a look at the converter to c. it will ignore every unknown command, therefore submitting a program in any other language won't necessarily lead to compile error, but certainly not to accepted. input the input consists of a line of up to 1000 uppercase letters, terminated with a '\n' character (ascii value 10). output the output should contain a line consisting of the same characters as the input line, but in non-descending order. example input: brainfuck output: abcfiknru
classic chinese rings puzzle comes in a variety of forms. the original version has seven rings linked together by a sliding loop threaded through them. the aim is to remove the loop by manipulating the rings. a modern implementation uses seven disks with specially shaped cut-outs mounted on a slide. the slide can move left and right. the slide can always move left until it reaches its left-most position, shown here: a disk can be rotated between horizontal and vertical only if it is positioned over the indentation marked '0' and the disk on its right is vertical. the right-most disk can always rotate if it is in position '0' since it has no disk on its right. the aim is to free the slide by moving it so its left edge aligns with the 'win' mark: your task is to write a program which will take several part-solved puzzles and compute the number of steps needed to move the slide to position 'win' for each puzzle. input there will be several puzzles in the input file. the first line of the file will contain an integer n specifying the number of puzzles. there will then be n lines, each of the form: length orientations position where length (length < 30) is an integer indicating the number of disks on the slide, orientations is a string of length characters from the set {h, v} giving the orientation of each disk from left to right (h stands for horizontal, and v for vertical), and position is an integer from 0 to length specifying the numbered mark which aligns with the left edge of the slide. output for each puzzle, your program should output one integer on a line which counts the minimum number of steps needed to win the puzzle. a step is either a movement of the slide, one unit left or right, or the rotation of a disk. example input: 3 2 vv 2 7 vhhhvhh 4 29 vvvvvvvvvvvvvvvvvvvvvvvvvvvvv 29 output: 7 357 1073741823 diagram of the first puzzle
is required to find out whether it is possible to delete given files from ms-dos directory executing the del command of ms-dos operation system only once. there are no nested subdirectories. a note del command has the following format: del wildcard the actual wildcard as well as a full file name can be made up either of a name containing 1 up to 8 characters or of a name and extension, containing up to 3 characters. the point character '.' separates the extension from the file name. the extension can be empty and this is equivalent to a name without any extension (in this case a wildcard ends with a point). in a wildcard the characters '?' and '*' can be used. a question mark substitutes exactly one character of the full file name excluding a point, an asterisk any sequence of characters (containing no points) even empty one. an asterisk can appear only at the last position of the name and the extension. ms-dos system can permit maybe other wildcards but they can not be used in this task. file names and extensions consist only of latin capitals and digits. input the first line of the input is an integer m, then a blank line followed by m datasets. there is a blank line between datasets. input data for each dataset contains a list of full file names without empty lines and spaces. each name is written in a separate line of input data file and preceded with a control sign: '-' for delete or '+' for keep. full file names are not repeated. the list comprises at least one file, and at least one file is marked to be deleted. there are no more than 1000 files. output for each dataset, write to the first line of output the required del command (only one proposal) or impossible if there is no solution. a space should separate "del" from wildcard. print a blank line between datasets. example input: 1 -bp.exe -bpc.exe +turbo.exe output: del ?p*.*
the far bare land there lives a mysterious tribe. they suffer from drought every year but they stick to their faith in god that they will never leave their home land. to counter the dry weather the shamans in the tribe must pray during the hard time and hope the blessed rain will aid their production of food. there are 4 chief shamans in the tribe and each of them will choose a summit in the territory to proceed with his praying. the area in which the shamans' spells take effect will be the quadrangle they form, each of them being one of its vertices (which the god will see when he looks down from the high heavens). the land is quite full of pinch and punch and the tribe has selected quite a few peaks for the shamans to pray on. of course the area of the quadrangle is expected to be as large as possible so before the shamans actually go out, they will have to choose the 4 peaks that best suit their purpose. input one integer in the first line, stating the number of test cases, followed by a blank line. there will be not more than 80 tests. for each test case, the first line is an integer n (4 <= n <= 2000) stating the number of peaks. then n lines follow, each presenting the position of a peak, with two integers x, y (-20000 <= x, y <= 20000). the test cases will be separated by a single blank line. output a floating point number with exactly 1 digit precision: the maximum area the shamans can cover. example input: 2 4 0 0 1 0 1 1 0 1 4 0 0 0 1 1 1 1 0 output: 1.0 1.0
you want to buy a new cellular phone, there are many various types to choose from. to decide which one is the best for you, you have to consider several important things: its size and weight, battery capacity, wap support, colour, price. one of the most important things is also the list of games the phone provides. nokia is one of the most successful phone makers because of its famous snake and snake ii. acm wants to make and sell its own phone and they need to program several games for it. one of them is master-mind, the famous board logical game. the game is played between two players. one of them chooses a secret code consisting of p ordered pins, each of them having one of the predefined set of c colours. the goal of the second player is to guess that secret sequence of colours. some colours may not appear in the code, some colours may appear more than once. the player makes guesses, which are formed in the same way as the secret code. after each guess, he/she is provided with an information on how successful the guess was. this feedback is called a hint. each hint consists of b black points and w white points. the black point stands for every pin that was guessed right, i.e. the right colour was put on the right position. the white point means right colour but on the wrong position. for example, if the secret code is "white, yellow, red, blue, white" and the guess was "white, red, white, white, blue", the hint would consist of one black point (for the white on the first position) and three white points (for the other white, red and blue colours). the goal is to guess the sequence with the minimal number of hints. the new acm phone should have the possibility to play both roles. it can make the secret code and give hints, but it can also make its own guesses. your goal is to write a program for the latter case, that means a program that makes master-mind guesses. input there is a single positive integer t on the first line of input. it stands for the number of test cases to follow. each test case describes one game situation and you are to make a guess. on the first line of each test case, there are three integer numbers, p, c and m. p ( 1 <= p <= 10) is the number of pins, c (1 <= c <= 100) is the number of colours, and m (1 <= m <= 100) is the number of already played guesses. then there are 2 x m lines, two lines for every guess. at the first line of each guess, there are p integer numbers representing colours of the guess. each colour is represented by a number gi, 1 <= gi <= c. the second line contains two integer numbers, b and w, stating for the number of black and white points given by the corresponding hint. let's have a secret code s1, s2, ... sp and the guess g1, g2, ... gp. then we can make a set h containing pairs of numbers (i,j) such that si = gj, and that any number can appear at most once on the first position and at most once on the second position. that means for every two different pairs from that set, (i1,j1) and (i2,j2), we have i1 <> i2 and j1 <> j2. then we denote b(h) the number of pairs in the set, that meet the condition i = j, and w(h) the number of pairs with i <> j. we define an ordering of every two possible sets h1 and h2. let's say h1 <= h2 if and only if one of the following holds: b(h1) < b(h2), or b(h1) = b(h2) and w(h1) <= w(h2) then we can find a maximal set hmax according to this ordering. the numbers b(hmax) and w(hmax) are the black and white points for that hint. output for every test case, print the line containing p numbers representing p colours of the next guess. your guess must be valid according to all previous guesses and hints. the guess is valid if the sequence could be a secret code, i.e. the sequence was not eliminated by previous guesses and hints. if there is no valid guess possible, output the sentence you are cheating!. if there are more valid guesses, output the one that is lexicographically smallest. i.e. find such guess g that for every other valid guess v there exists such a number i that: gj = vj for every j<i, and gi<vi. example sample input: 3 4 3 2 1 2 3 2 1 1 2 1 3 2 1 1 4 6 2 3 3 3 3 3 0 4 4 4 4 2 0 8 9 3 1 2 3 4 5 6 7 8 0 0 2 3 4 5 6 7 8 9 1 0 3 4 5 6 7 8 9 9 2 0 sample output 1 1 1 3 you are cheating! 9 9 9 9 9 9 9 9 warning: large input/output data, be careful with certain languages
building his huge villa, mr. rich cannot help but notice that the interior walls look rather blank. to change that, he starts to hang paintings from his wonderful collection. but soon he realizes that it becomes quite difficult to find a place on the wall where a painting can be placed without overlapping other paintings. now he needs a program which would tell him, given the already placed paintings, where to place the next painting without moving any other paintings (or indicating that this is impossible). paintings have a rectangular shape and are to be placed parallel to the side of the wall. if you do not mind a nice reward from mr. rich, go on and solve the problem. input specification the first line of the input file contains a number representing the number of test cases to follow. each test case starts with a line containing three numbers n, w and h. n is the number of paintings already hanging on the wall, w is the width of the wall and h is the height of the wall. the next n lines contain 4 integers x1, y1, x2, y2 each (0 ≤ x1 < x2 ≤ w, 0 ≤ y1 < y2 ≤ h); the x-coordinates give the distance to the left end of the wall, the y-coordinates give the distance to the bottom of the wall. (x1, y1) is the position of the lower left corner of a painting, (x2, y2) is the position of the upper right corner. the last line of each test case contains the dimensions of the next painting to be placed, first its width w', then its height h' (1 ≤ w' ≤ w, 1 ≤ h' ≤ h). you are not allowed to rotate the painting. you can assume that 0 ≤ n ≤ 200 and 1 ≤ w, h ≤ 1000000. moreover, all paintings already hanging do not overlap. output specification produce one line of output for each test case. write "fail!" if there is no place left on the wall where the painting could be placed without overlapping other paintings. otherwise, write the coordinates where the lower left corner of the painting should be placed. in case there is more than one solution, select the solution with a minimum y-coordinate, and break ties using the minimum x-coordinate. sample input 2 1 10 9 5 4 10 9 9 5 2 10 10 5 5 10 10 0 0 4 3 3 4 sample output fail! 4 0 the following image illustrates the second sample test case:
puzzles are usually simple and very entertaining for all ages. they are so entertaining that pizza-hut company started using table covers with word puzzles printed on them, possibly with the intent to minimise their client's perception of any possible delay in bringing them their order. even though word puzzles may be entertaining to solve by hand, they may become boring when they get very large. computers do not yet get bored in solving tasks, therefore we thought you could devise a program to speedup (hopefully!) solution finding in such puzzles. the following figure illustrates the pizzahut puzzle. the names of the pizzas to be found in the puzzle are: margarita, alema, barbecue, tropical, suprema, louisiana, cheeseham, europa, havaiana, camponesa. 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 0 q w s p i l a a t i r a g r a m y k e i 1 a g t r c l q a x l p o i j l f v b u q 2 t q t k a z x v m r w a l e m a p k c w 3 l i e a c n k a z x k p o t p i z c e o 4 f g k l s t c b t r o p i c a l b l b c 5 j e w h j e e w s m l p o e k o r o r a 6 l u p q w r n j o a a g j k m u s j a e 7 k r q e i o l o a o q p r t v i l c b z 8 q o p u c a j s p p o u t m t s l p s f 9 l p o u y t r f g m m l k i u i s x s w 10 w a h c p o i y t g a k l m n a h b v a 11 e i a k h p l b g s m c l o g n g j m l 12 l d t i k e n v c s w q a z u a o e a l 13 h o p l p g e j k m n u t i i o r m n c 14 l o i u f t g s q a c a x m o p b e i o 15 q o a s d h o p e p n b u y u y o b x b 16 i o n i a e l o j h s w a s m o u t r k 17 h p o i y t j p l n a q w d r i b i t g 18 l p o i n u y m r t e m p t m l m n b o 19 p a f c o p l h a v a i a n a l b p f s problem your task is to produce a program that given the word puzzle and words to be found in the puzzle, determines, for each word, the position of the first letter and its orientation in the puzzle. you can assume that the left upper corner of the puzzle is the origin, (0,0). furthemore, the orientation of the word is marked clockwise starting with letter a for north (note: there are 8 possible directions in total). input the first line of the input contains a number t ≤ 10 which indicates the number of test cases to follow. each test case starts with a line consisting of three positive numbers: the number of lines of the word puzzle, 0 < l ≤ 1000, the number of columns, 0 < c ≤ 1000, and the number of words to be found, 0 < w ≤ 1000. the following l input lines, each consisting of c uppercase letters, contain the word puzzle. then at last the w words are input one per line. you can assume that each word can be found exactly once in the word puzzle. output for each test case your program should output w lines: for each word (using the same order as the words were input) print a triplet defining the coordinates, line and column, where the first letter of the word appears, followed by a letter indicating the orientation of the word according to the rules defined above. each value in the triplet must be separated by one space only. print one blank line between test cases. example input: 1 20 20 10 qwspilaatiragramykei agtrclqaxlpoijlfvbuq tqtkazxvmrwalemapkcw lieacnkazxkpotpizceo fgklstcbtropicalblbc jewhjeewsmlpoekorora lupqwrnjoaagjkmusjae krqeioloaoqprtvilcbz qopucajsppoutmtslpsf lpouytrfgmmlkiuisxsw wahcpoiytgaklmnahbva eiakhplbgsmclogngjml ldtikenvcswqazuaoeal hoplpgejkmnutiiormnc loiuftgsqacaxmopbeio qoasdhopepnbuyuyobxb ioniaelojhswasmoutrk hpoiytjplnaqwdribitg lpoinuymrtemptmlmnbo pafcoplhavaianalbpfs margarita alema barbecue tropical suprema louisiana cheeseham europa havaiana camponesa output: 0 15 g 2 11 c 7 18 a 4 8 c 16 13 b 4 15 e 10 3 d 5 1 e 19 7 c 11 11 h
is a big palace in which rooms are constructed in the from of a square matrix. now these rooms have to be filled with people. as there are conflicts between people to maintain the equilibrium total number of people must be odd in every row and every column. a room can accommodate only a single person. given the size of palace n one has to find total number of ways people can be accommodated. input first line consists of an integer k and then k test cases follow. output for each test case you have to output the result%98777 in a separate line. example input: 1 3 output: 16
easy to know that arctan(1/2) + arctan(1/3) = arctan(1). given number a, write a program to calculate the minimum sum b+c. a, b and c are all positive integers and satisfy the equation below: arctan(1/a) = arctan(1/b) + arctan(1/c) input the first line contains a integer number t (about 1000). t lines follow, each contains a single integer a, 1<=a<=60000. output t lines, each contains a single integer which denotes to the minimum sum b+c. example sample input: 1 1 sample output: 5 added some new test data.
equidivision of an n × n square array of cells is a partition of the n^2 cells in the array in exactly n sets, each one with n contiguous cells. two cells are contiguous when they have a common side. a good equidivision is composed of contiguous regions. the figures show a good and a wrong equidivision for a 5×5 square: note that in the second example the cells labeled with 4 describe three non-contiguous regions and cells labeled with 5 describe two non-contiguous regions. you must write a program that evaluates if an equidivision of the cells in a square array is good or not. input it is understood that a cell in an n×n square array is denoted by a pair (i, j), with 1 <= i, j <= n. the input file contains several test cases. each test case begins with a line indicating n, 0 < n < 100, the side of the square array to be partitioned. next, there are n − 1 lines, each one corresponding to one partition of the cells of the square, with some non-negative integer numbers. consecutive integers in a line are separated with a single blank character. a line of the form a1 a2 a3 a4 ... means that cells denoted with the pairs (a1, a2), (a3, a4), ... belong to one of the areas in the partition. the last area in the partition is defined by those cells not mentioned in the n − 1 given lines. if a case begins with n = 0 it means that there are no more cases to analyze. output for each test case good must be printed if the equidivision is good, in other case, wrong must be printed. the answers for the different cases must preserve the order of the input. example input: 2 1 2 2 1 5 1 1 1 2 1 3 3 2 2 2 2 1 4 2 4 1 5 1 3 1 4 5 5 2 5 3 5 5 5 4 2 5 3 4 3 5 4 3 4 4 5 1 1 1 2 1 3 3 2 2 2 2 1 3 1 4 1 5 1 4 2 4 5 5 2 5 3 5 5 5 4 2 4 1 4 3 5 4 3 4 4 0 output: wrong good wrong
mary extremely like lemon trees. when the softness moon shines the ground, she lies under the lemon tree, thinking about the true meaning of life, the universe and everything quietly. before long, she is shadowed by the lemon tree. blue mary is such a cute girl, that she soon comes up with a question: what is the area of the shadow? she knows it's hard for her to measure the shadow directly. so that, she tries to calculate it in geometrical way. as mary knows well about this beautiful lemon tree, she regards it as n frustums of cones, each frustums of cone is defined as a floor, numbered 1..n from the bottom to top. of course, the nth(top) is a cone. each frustum has two circle surfaces. each two adjacent frustums shares a same circle surface. all the centres of the circle surfaces are on a plumb line. mary knows that the height of every frustums is h1, h2, ... hn, and the undersurface of the 1st frustum has a height h0 from the ground. mary measures that the included angle of the moonshine and the ground is alpha, which is an acute angle. for briefness, we suppose the moonshine is parallel and the ground is aclinic. and we ignore the bole of the tree. mary comes up with the answer quickly, and she wants your ideas all the same. input the very first line of the input data contains one integer t, the number of tests. t blocks follow. for each test: the first line of the input data contains one integer number n (n<=500) and a real number alpha (alpha>0.3). n denote the number of floors, alpha denote the included angle of the moonshine and the ground(radian). the second line contains n + 1 real number h0 h1 h2 ... hn. (hi<=100) h0 denotes the height of the undersurface of the 1st frustum. h1 ... hn denote the height of each floor. the third line contains n real number r1 r2 ... rn (ri<=100), the radii of the undersurface in each floor. all the data in each line is separated by spaces. output for each data set you should output one line containing a single real number - the area of the shadow. numbers should be rounded to two decimal places. example input: 1 2 0.7853981633 10.0 10.00 10.00 4.00 5.00 output: 171.97
are given a positive integer n. let us consider set a of fractions x/y where 0 <= x/y <= 1, y <= n and the maximum common divisor of x and y is 1. for example n = 5. set a in increasing order consists of elements 0/1; 1/5; 1/4; 1/3; 2/5; 1/2; 3/5; 2/3; 3/4; 4/5; 1/1. your task is to find the i-th smallest fraction in set a. input the first line of input contains the number of testcases t (t <= 15). the first line of each testcase contains numbers n and m (n <= 5000, m <= 10000). the next m lines contain one question each. output for each testcase, you should output m lines which are the answers to the m questions. example input: 1 5 4 1 3 5 8 output: 0/1 1/4 2/5 2/3
is a string containing only decimal digit characters. the length of the string is between 1 and 1000. using characters of the string, you have to construct the maximum number which divides by fifteen without remainder. each character of the string may not be used more than once. input first line of input contains an integer t (1 ≤ t ≤ 90), equal to the number of testcases. then descriptions of t testcases follow. each testcase is described in a single line representing the source string. output for each testcase output one line with the decimal representation of the maximum number. leading zeroes should be omitted. if no number can be constructed, output a single word “impossible”. example input: 1 02041 output: 4200
you want to buy a new cellular phone, there are many various types to choose from. to decide which one is the best for you, you have to consider several important things: its size and weight, battery capacity, wap support, colour, price. one of the most important things is also the list of games the phone provides. nokia is one of the most successful phone makers because of its famous snake and snake ii. acm wants to make and sell its own phone and they need to program several games for it. one of them is master-mind, the famous board logical game. the game is played between two players. one of them chooses a secret code consisting of p ordered pins, each of them having one of the predefined set of c colours. the goal of the second player is to guess that secret sequence of colours. some colours may not appear in the code, some colours may appear more than once. the player makes guesses, which are formed in the same way as the secret code. after each guess, he/she is provided with an information on how successful the guess was. this feedback is called a hint. each hint consists of b black points and w white points. the black point stands for every pin that was guessed right, i.e. the right colour was put on the right position. the white point means right colour but on the wrong position. for example, if the secret code is "white, yellow, red, blue, white" and the guess was "white, red, white, white, blue", the hint would consist of one black point (for the white on the first position) and three white points (for the other white, red and blue colours). the goal is to guess the sequence with the minimal number of hints. the new acm phone should have the possibility to play both roles. it can make the secret code and give hints, but it can also make its own guesses. your goal is to write a program for the latter case, that means a program that makes master-mind guesses. input there is a single positive integer t on the first line of input. it stands for the number of test cases to follow. each test case describes one game situation and you are to make a guess. on the first line of each test case, there are three integer numbers, p, c and m. p ( 1 <= p <= 10) is the number of pins, c (1 <= c <= 100) is the number of colours, and m (1 <= m <= 100) is the number of already played guesses. then there are 2 x m lines, two lines for every guess. at the first line of each guess, there are p integer numbers representing colours of the guess. each colour is represented by a number gi, 1 <= gi <= c. the second line contains two integer numbers, b and w, stating for the number of black and white points given by the corresponding hint. let's have a secret code s1, s2, ... sp and the guess g1, g2, ... gp. then we can make a set h containing pairs of numbers (i,j) such that si = gj, and that any number can appear at most once on the first position and at most once on the second position. that means for every two different pairs from that set, (i1,j1) and (i2,j2), we have i1 <> i2 and j1 <> j2. then we denote b(h) the number of pairs in the set, that meet the condition i = j, and w(h) the number of pairs with i <> j. we define an ordering of every two possible sets h1 and h2. let's say h1 <= h2 if and only if one of the following holds: b(h1) < b(h2), or b(h1) = b(h2) and w(h1) <= w(h2) then we can find a maximal set hmax according to this ordering. the numbers b(hmax) and w(hmax) are the black and white points for that hint. output for every test case, print the line containing p numbers representing p colours of the next guess. your guess must be valid according to all previous guesses and hints. the guess is valid if the sequence could be a secret code, i.e. the sequence was not eliminated by previous guesses and hints. if there is no valid guess possible, output the sentence you are cheating!. if there are more valid guesses, output the one that is lexicographically smallest. i.e. find such guess g that for every other valid guess v there exists such a number i that: gj = vj for every j<i, and gi<vi. example sample input: 3 4 3 2 1 2 3 2 1 1 2 1 3 2 1 1 4 6 2 3 3 3 3 3 0 4 4 4 4 2 0 8 9 3 1 2 3 4 5 6 7 8 0 0 2 3 4 5 6 7 8 9 1 0 3 4 5 6 7 8 9 9 2 0 sample output 1 1 1 3 you are cheating! 9 9 9 9 9 9 9 9 warning: large input/output data, be careful with certain languages
k-path cover of a directed graph is a set of exactly k of its edges chosen in such way that every two of them have different start vertices and every two of them have different end vertices. assuming that for each vertex we know its cost we can define cost of the edge as a sum of costs of its start and end. we can also define cost of a k-path cover as a sum of costs of its edges. your task is to find cheapest k-path cover for given directed graph with known costs of the vertices. a graph and its cheapest 4-path cover. input first line of input contains number of test cases c (1<=c<=20). each test case begins with k, number of vertices n and number of edges m (1<=k<=100, 1<=n<=10000, 0<=m<=1000000). next n lines contain costs of the vertices, each of them is an integer from [-100000,100000]. then m lines describing edges follow, each of them containing exactly two numbers representing its start and end vertices. vertices are numbered from 1 to n. output for each test case output cost of the cheapest k-path cover. when given graph has no k-path cover output none. example input: 1 4 6 9 5 4 6 10 2 3 1 2 1 4 2 4 3 2 4 3 5 4 6 3 5 6 6 5 output: 33
triangle made of coins of height h is as follows it has h coins at the base and h-1 coins one level above base and so on.(coins are placed as shown in the figure below) and at the top most level there will be only one coin now given h the task is to invert this triangle by moving minimum number of coins. for example when h=4 triangle is for h=4 at least 3 coins must be moved to invert it. input in the first line n will be given and then n lines follow with each line having a integer which is the height of triangle in that test case.00â‰¤h<1010; output for each test case output in a seperate line the minimum number of moves required to invert the triangle. output fits in long long data type example inputt: 1 3 output: 2
positive integer is called a palindrome if its representation in the decimal system is the same when read from left to right and from right to left. for a given positive integer k of not more than 1000000 digits, write the value of the smallest palindrome larger than k to output. numbers are always displayed without leading zeros. input the first line contains integer t, the number of test cases. integers k are given in the next t lines. output for each k, output the smallest palindrome larger than k. example input: 2 808 2133 output: 818 2222 warning: large input/output data, be careful with certain languages
trying to solve problem number 31 (fast multiplication) with some script languages that support arbitrary large integers and timing out, you wonder what would be the best language to do fast multiplication of integers. and naturally it comes to your mind: of course it is brainf**k, because there are only very cheap operations in that language. input two positive integers, ended with a line feed (ascii 10) each. output the product of the two integers, terminated by a line feed. you may assume that this number will be less than 10000. example input: 1 2 output: 2
sudoku grid is a 16x16 grid of cells grouped in sixteen 4x4 squares, where some cells are filled with letters from a to p (the first 16 capital letters of the english alphabet), as shown in the figure. the game is to fill all the empty grid cells with letters from a to p such that each letter from the grid occurs once only in the line, the column, and the 4×4 square it occupies. the initial content of the grid satisfies the constraints mentioned above and guarantees a unique solution. a c o i j a b p c g f h d f i e p g e l h m j e c g i k g a b e j d g p j f a e c b d p o e f m d l k a c o i l h p c f a b g o d j h k j h a p l b p e k a h b k f i c f c d h n a) sudoku grid f p a h m j e c n l b d k o g i o j m i a n b d p k c g f l h e l n d k g f o i j e a h m b p c b g c e l k h p o f i m a j d n m f h b e l p o a c k j g n i d c i l n k d g a h b m o p e f j d o g p i h j m f n l e c a k b j e k a f c n b g i d p l h o m e b o f p m i j d g h l n k c a n c j d h b a e k m o f i g l p h m p l c g k f i a e n b d j o a k i g n o d l b p j c e f m h k d e m j i f n c h g a o p b l g l b c d p m h e o n k j i a f p h n o b a l k m j f i d c e g i a f j o e c g l d p b h m n k b) solution input the first line of the input contains an integer k - determining the number of datasets (k <= 10). each data set encodes a grid and contains 16 strings on 16 consecutive lines as shown in the example input below. the ith string stands for the ith line of the grid, is 16 characters long, and starts from the first position of the line. string characters are from the set {a, b ... p, -}, where – (minus) designates empty grid cells. the data sets are separated by single empty lines. output for each data set in the input print the completed 16×16 sudoku as specified by the rules above. the program prints the solution of the input encoded grids in the same format and order as used for input. the output for each data set should be separated by single empty lines. example input: 1 --a----c-----o-i -j--a-b-p-cgf-h- --d--f-i-e----p- -g-el-h----m-j-- ----e----c--g--- -i--k-ga-b---e-j d-gp--j-f----a-- -e---c-b--dp--o- e--f-m--d--l-k-a -c--------o-i-l- h-p-c--f-a--b--- ---g-od---j----h k---j----h-a-p-l --b--p--e--k--a- -h--b--k--fi-c-- --f---c--d--h-n- output: fpahmjecnlbdkogi ojmianbdpkcgflhe lndkgfoijeahmbpc bgcelkhpofimajdn mfhbelpoackjgnid cilnkdgahbmopefj dogpihjmfnlecakb jekafcnbgidplhom ebofpmijdghlnkca ncjdhbaekmofiglp hmplcgkfiaenbdjo akignodlbpjcefmh kdemjifnchgaopbl glbcdpmheonkjiaf phnobalkmjfidceg iafjoecgldpbhmnk
loves gambling in the dicent city. every saturday the whole community meets to attend a dice contest. they started a few years ago with a classic six-sided die with 1 to 6 dots displayed on the sides and had a lot of fun. however they soon got bored and that's why more sophisticated dice are in use nowadays. they put a sticker on each side and write a positive integer on each sticker. the contest is run on a strip divided into squares in a chessboard-like manner. the strip is 4 squares wide and infinite to the left and to the right (is anyone going to say it can't exist in the real world, huh?). the rows of the strip are numbered from 1 to 4 from the bottom to the top and the columns are numbered by consecutive integers from the left to the right. each square is identified by a pair (x,y) where x is a column number and y is a row number. the game begins with a die placed on a square chosen be a contest committee with one-dot side on the top and two-dots side facing the player. to move the die the player must roll the die over an edge to an adjacent (either horizontally or vertically) square. the number displayed on the top of the die after a roll is the cost of the move. the goal of the game is to roll the die from the starting square to the selected target square so that the sum of costs of all moves is minimal. task write a program that: reads the description of a die, a starting square and a target square, computes the minimal cost of rolling the die from the starting square to the target square, writes the result. note: all teams participating in the contest received dice from the organisers. input the input begins with the integer t, the number of test cases. then t test cases follow. for each test case the first line of the input contains six integers l1, l2, l3, l4, l5, l6 (1 < = li < = 50) separated by single spaces. integer li is the number written on a side having originally i dots. the second line of the input contains four integers x1, y1, x2, y2 ( -109 < = x1, x2 < = 109, 1 <= y1, y2 < = 4) separated by single spaces. integers x1, y1 are the column and the row number of the starting square respectively. integers x2, y2 are the column and the row number of the target square respectively. output for each test case the first and the only line of the output should contain the minimal cost of rolling the die from the starting square to the target square. example sample input: 1 1 2 8 3 1 4 -1 1 0 2 sample output: 7
call a cuboid regular if: one of its vertices is a point with coordinates (0,0,0), edges beginning in this vertex lie on the positive semi-axes of the coordinate system, the edges are not longer than 106 there is given a set a of points of space, whose coordinates are integers from the interval [1..106]. we try to find a regular cuboid of maximal volume which does not contain any of the points from the set a. a point belongs to the cuboid if it belongs to the interior of the cuboid, i.e. it is a point of the cuboid, but not of its wall. task write a program which: reads from the standard input the coordinates of points from the set a, finds one of the regular cuboids of maximal volume which does not contain any points from the set a, writes the result to standard output. input input begins with a line containing integer t<=10, the number of test cases. t test cases follow. in the first line of each test case one non-negative integer n is written ( n <= 5000). it is the number of elements in the set a. in the following n lines of the input there are triples of integers from the interval [1..106], which are the x, y and z coordinates of points from a, repectively. numbers in each line are separated by single spaces. output for each test case there should be three integers separated by single spaces. these are the x, y and z coordinates (respectively) of the vertex of the regular cuboid of maximal volume. if there is more than one such a cuboid, choose whichever. we require that all coordinates be positive. example sample input: 1 4 3 3 300000 2 200000 5 90000 3 2000 2 2 1000 sample output: 1000000 200000 1000
abdul really loves football. so you better don't ask how much money he has spent to make famous teams join the annual tournament. of course, having spent so much money, he would like to see certain teams play each other. he worked out a complete list of games he would like to see. now it is your task to distribute these games into rounds according to following rules: in each round, each remaining team plays at most one game if there is an even number of remaining teams, every team plays exactly one game if there is an odd number of remaining teams, there is exactly one team which plays no game (it advances with a wildcard to the next round) the winner of each game advances to the next round, the loser is eliminated from the tournament if there is only one team left, this team is declared the winner of the tournament as can be proved by induction, in such a tournament with n teams, there are exactly n - 1 games required until a winner is determined. obviously, after round 1, teams may already have been eliminated which should take part in another game. to prevent this, for each game you also have to tell which team should win. input specification the input file contains several test cases. each test case starts with an integer n (2 ≤ n ≤ 1000), the number of teams participating in the tournament. the following n lines contain the names of the teams participating in the tournament. you can assume that each team name consists of up to 25 letters of the english alphabet ('a' to 'z' or 'a' to 'z'). then follow n - 1 lines, describing the games the sheikh would like to see (in any order). each line consists of the two names of the teams which take part in that game. you can assume that it is always possible to find a tournament schedule consisting of the given games. the last test case is followed by a zero. output specification for each test case, write the game schedule, distributed in rounds. for each round, first write "round #x" (where x is the round number) in a line by itself. then write the games scheduled in this round in the form: "a defeats b", where a is the name of the advancing team and b is the name of the team being eliminated. you may write the games of a round in any order. if a wildcard is needed for the round, write "a advances with wildcard" after the last game of the round, where a is the name of the team which gets the wildcard. after the last round, write the winner in the format shown below. print a blank line after each test case. sample input 3 a b c a b b c 5 a b c d e a b c d a e c e 0 sample output round #1 b defeats a c advances with wildcard round #2 c defeats b winner: c round #1 a defeats b c defeats d e advances with wildcard round #2 e defeats a c advances with wildcard round #3 e defeats c winner: e note that there is always more than one possible game schedule; you may print any of them.
two strings x and y, your task is find the minimum number of characters to be removed from x in order to obtain a string x' that does not contain y as a substring. input input contains some test cases. each test cases contains two lines, first is x and second is y. length of x <= 10000, length of y <= 1000. output for each test cases, you should output exactly one integer is the minimum number of characters to be remove example input: ababaa aba output: 1
the number n of test cases, convert n positive integers less than 2^32 (given one per line) from one representation to another. for convenience, n is given in the same format as the other numbers. input input is given by spelling the number in english digits (all upper case letters). thus the range of (32-bit) input values permissible extends from zero (or oh) through four two nine four nine six seven two nine five. output output 2 lines for each test case. output is in the form of "extended" roman numerals (also called "butchered" roman numerals), with an overline (see sample for details) indicating the value below is "times 1000", and lower-case letters indicating "times 1000000". thus, the range of (32-bit) output values possible is from through ivccxcivcmlxviiccxcv, where there is a line above iv and cmlxvii. note: for values whose residues modulo 100000 are less than 4000, m is used to represent 1000; for values whose residues are 4000 or greater, i is used. thus 3999 would read out as mmmcmxcix while 4000 would readout as iv with an overline. similar rules apply to the use of m and i for 1000000, and to that of m and i for 1000000000. warning: this problem has a somewhat strict source limit example input: three four oh one nine nine nine nine nine nine nine nine nine one two three zero four five output: xl ______ mcmxcixcmxcixcmxcix ___ cxxmmmxlv
building his huge villa, mr. rich cannot help but notice that the interior walls look rather blank. to change that, he starts to hang paintings from his wonderful collection. but soon he realizes that it becomes quite difficult to find a place on the wall where a painting can be placed without overlapping other paintings. now he needs a program which would tell him, given the already placed paintings, where to place the next painting without moving any other paintings (or indicating that this is impossible). paintings have a rectangular shape and are to be placed parallel to the side of the wall. if you do not mind a nice reward from mr. rich, go on and solve the problem. input specification the first line of the input file contains a number representing the number of test cases to follow. each test case starts with a line containing three numbers n, w and h. n is the number of paintings already hanging on the wall, w is the width of the wall and h is the height of the wall. the next n lines contain 4 integers x1, y1, x2, y2 each (0 ≤ x1 < x2 ≤ w, 0 ≤ y1 < y2 ≤ h); the x-coordinates give the distance to the left end of the wall, the y-coordinates give the distance to the bottom of the wall. (x1, y1) is the position of the lower left corner of a painting, (x2, y2) is the position of the upper right corner. the last line of each test case contains the dimensions of the next painting to be placed, first its width w', then its height h' (1 ≤ w' ≤ w, 1 ≤ h' ≤ h). you are not allowed to rotate the painting. you can assume that 0 ≤ n ≤ 200 and 1 ≤ w, h ≤ 1000000. moreover, all paintings already hanging do not overlap. output specification produce one line of output for each test case. write "fail!" if there is no place left on the wall where the painting could be placed without overlapping other paintings. otherwise, write the coordinates where the lower left corner of the painting should be placed. in case there is more than one solution, select the solution with a minimum y-coordinate, and break ties using the minimum x-coordinate. sample input 2 1 10 9 5 4 10 9 9 5 2 10 10 5 5 10 10 0 0 4 3 3 4 sample output fail! 4 0 the following image illustrates the second sample test case:
n be a positive integer, consider the following recurrence: f(1) = n and f(k) = (0.5 + 2.5 * (f(k-1) mod 2)) * f(k-1) + (f(k-1) mod 2) if k>1. for a given n you have to compute the smallest l for which f(l)=1 (such an l always exists for n's in the input). input each line contains a positive integer n in decimal notation. you can be sure that n and all intermediate results are not bigger than 10^1888. input terminated by eof. output for each number n in the input print one line with the value of l in decimal notation. example input: 1 2 321 1111111111111 111111111111111111111111111111111111111111111111111111111111 output: 1 2 25 261 1296
an undirected weighted graph {v,e}. your task to calculate the importance of each node. the importance of a node v (i(v)) can be defined as follow: cs,t is the number of different shortest paths from s to t, cs,t(v) is the number of different shortest paths from s to t through v. input multiple test cases, the number of them is given in the very first line. for each test case: the first line contains two space-separated integers n(n<=100) and m(m<=4500), the number of nodes in the graph and the number of edges in the graph. the nodes are numbered from 1 to n. m lines follow, each contains 3 integers a, b, c, 1<=a, b<=n, 1<=c<=1000, a!=b, which denotes that there is an undirected edge between node a and node b weighted c. you may assume that there is at most one edge between any pair of nodes, and the number of shortest paths between any pair of nodes is at least 1 and at most 1010. output for each test case: your output should contains n lines, each contains one single real number, with 3 decimal places after radix point. the number in the ith line denotes the importance of the ith node. example input: 1 4 4 1 2 1 2 3 1 3 4 1 4 1 1 output: 1.000 1.000 1.000 1.000
likes to ride her bicycle, but since the pretty city of greenhills where she lives has grown, jill often uses the excellent public bus system for part of her journey. she has a folding bicycle which she carries with her when she uses the bus for the first part of her trip. when the bus reaches some pleasant part of the city, jill gets off and rides her bicycle. she follows the bus route until she reaches her destination or she comes to a part of the city she does not like. in the latter event she will board the bus to finish her trip. through years of experience, jill has rated each road on an integer scale of niceness. positive niceness values indicate roads jill likes; negative values are used for roads she does not like. there are not zero values. jill plans where to leave the bus and start bicycling, as well as where to stop bicycling and re-join the bus, so that the sum of niceness values of the roads she bicycles on is maximized. this means that she will sometimes cycle along a road she does not like, provided that it joins up two other parts of her journey involving roads she likes enough to compensate. it may be that no part of the route is suitable for cycling so that jill takes the bus for its entire route. conversely, it may be that the whole route is so nice jill will not use the bus at all. since there are many different bus routes, each with several stops at which jill could leave or enter the bus, she feels that a computer program could help her identify the best part to cycle for each bus route. input the input file contains information on several bus routes. the first line of the file is a single integer b representing the number of route descriptions in the file. the identifier for each route (r) is the sequence number within the data file, 1 ≤ r ≤ b. each route description begins with the number of stops on the route: an integer s, 2 ≤ s ≤ 100000 on a line by itself. the number of stops is followed by s - 1 lines, each line i (1 ≤ i < s) is an integer ni with absolute value ≤ 1000 representing jill's assessment of the niceness of the road between the two stops i and i+1. output for each route in the input file, your program should identify the beginning bus stop i and the ending bus stop j that identify the segment of the route which yields the maximal sum of niceness, m= ni+ni+1+...+nj-1. if more than one segment is maximally nice, choose the one with the longest cycle ride (largest j-i). to break ties in longest maximal segments, choose the segment that begins with the earliest stop (lowest i). for each route r in the input file, print a line in the form: the nicest part of route r is between stops i and j however, if the maximal sum is not positive, your program should print: route r has no nice parts example input: 3 3 -1 6 10 4 -5 4 -3 4 4 -4 4 -5 4 -2 -3 -4 output: the nicest part of route 1 is between stops 2 and 3 the nicest part of route 2 is between stops 3 and 9 route 3 has no nice parts
by his last successful exploit, the bytelandian fanatic cryptographer impudently encrypted a three-digit number by subtracting 1 from it. this time he has really overstepped the mark! soldier, go and beat him, for burger king & country! oh, and remember your good manners, use brainf**k (no other language is allowed). input an encrypted 3-digit positive integer. output the decrypted value. example input: 699 output: 700
sum problem can be formulated as follows: given four lists a, b, c, d of integer values, compute how many quadruplet (a, b, c, d ) belongs to a x b x c x d are such that a + b + c + d = 0 . in the following, we assume that all lists have the same size n. input the first line of the input file contains the size of the lists n (this value can be as large as 4000). we then have n lines containing four integer values (with absolute value as large as 228 ) that belong respectively to a, b, c and d. (edited: n <= 2500) output output should be printed on a single line. example input: 6 -45 22 42 -16 -41 -27 56 30 -36 53 -37 77 -36 30 -75 -46 26 -38 -10 62 -32 -54 -6 45 output: 5
hachioji has devised a new numeral system of integral numbers with four lowercase letters "m", "c", "x", "i" and with eight digits "2", "3", "4", "5", "6", "7", "8", "9". he doesn't use digit "0" nor digit "1" in this system. the letters "m", "c", "x" and "i" correspond to 1000, 100, 10 and 1, respectively, and the digits "2", ...,"9" correspond to 2, ..., 9, respectively. this system has nothing to do with the roman numeral system. for example, character strings "5m2c3x4i", "m2c4i" and "5m2c3x" correspond to the integral numbers 5234 (=5*1000+2*100+3*10+4*1), 1204 (=1000+2*100+4*1), and 5230 (=5*1000+2*100+3*10), respectively. the parts of strings in the above example, "5m", "2c", "3x" and "4i" represent 5000 (=5*1000), 200 (=2*100), 30 (=3*10) and 4 (=4*1), respectively. each of the letters "m", "c", "x" and "i" may be prefixed by one of the digits "2", "3", ..., "9". in that case, the prefix digit and the letter are regarded as a pair. a pair that consists of a prefix digit and a letter corresponds to an integer that is equal to the original value of the letter multiplied by the value of the prefix digit. for each letter "m", "c", "x" and "i", the number of its occurrence in a string is at most one. when it has a prefix digit, it should appear together with the prefix digit. the letters "m", "c", "x" and "i" must appear in this order, from left to right. moreover, when a digit exists in a string, it should appear as the prefix digit of the following letter. each letter may be omitted in a string, but the whole string must not be empty. a string made in this manner is called an mcxi-string. an mcxi-string corresponds to a positive integer that is the sum of the values of the letters and those of the pairs contained in it as mentioned above. the positive integer corresponding to an mcxi-string is called its mcxi-value. moreover, given an integer from 1 to 9999, there is a unique mcxi-string whose mcxi-value is equal to the given integer. for example, the mcxi-value of an mcxi-string "m2c4i" is 1204 that is equal to 1000 + 2*100 + 4*1. there are no mcxi-strings but "m2c4i" that correspond to 1204. note that strings "1m2c4i", "mcc4i", "m2c0x4i", and "2cm4i" are not valid mcxi-strings. the reasons are use of "1", multiple occurrences of "c", use of "0", and the wrong order of "c" and "m", respectively. your job is to write a program for prof. hachioji that reads two mcxi-strings, computes the sum of their mcxi-values, and prints the mcxi-string corresponding to the result. input the input is as follows. the first line contains a positive integer n (<= 500) that indicates the number of the following lines. the k+1 th line is the specification of the k th computation (k=1, ..., n). n specification1 specification2 ... specificationn each specification is described in a line: mcxi-string1 mcxi-string2 the two mcxi-strings are separated by a space. you may assume that the sum of the two mcxi-values of the two mcxi-strings in each specification is less than or equal to 9999. output for each specification, your program should print an mcxi-string in a line. its mcxi-value should be the sum of the two mcxi-values of the mcxi-strings in the specification. no other characters should appear in the output. example input: 10 xi x9i i 9i c2x2i 4c8x8i m2ci 4m7c9x8i 9c9x9i i i 9m9c9x8i m i i m m9i i 9m8c7xi c2x8i output: 3x x 6cx 5m9c9x9i m 9m9c9x9i mi mi mx 9m9c9x9i
king has won the brutal battle and this whole land is now ours. the special thing about this land is that it has many beautiful golden statues. our king wants to take back as much gold as possible to his palace. we have found that there are n types of statues and -- almost unbelievably -- that there is an unlimited number of each type of statue. each statue of type i has a weight of w[i] units and occupies v[i] units of volume. our king wants to maximize the amount of gold he carries back to his palace. we may use s sacks for this purpose, each of volume y. all sacks are filled up independently by golden statues. however, there is a provision to stitch two sacks together, at the cost of c units of gold. stitching three sacks costs 2*c because it requires two stitchings, and so on. your task is to find how much gold our king can possibly gain, i.e. the total weight of the statues brought back, minus the stitching charges. input t â€“ the number of test cases. for each test case : n s y c // 1st line next n lines two numbers w[i] and v[i] each. output one integer, the maximum gain in gold for our king. this gain is the total amount of gold transported minus stitching charges. constraints : 1<= s <= 1000 1<= y <= 1000 000 000 1<= n <= 1000 1<= w[i] <= 100; (for all i) 1<= v[i] <= 18; the output will fit into a 64-bit integer. 1<=t<=20 all w[i] & v[i] are guaranteed to be either prime or equal to 1. example sample input: 2 2 5 3 1 1 2 5 7 2 5 3 1 1 2 7 5 sample output: 6 17
johnny of byteland has in his short period of sovereignty established quite a few national holidays (close on thirty, in fact) in honour of... more or less anything he could think of. each of these holidays occurs every a fixed number of days (possibly different for every holiday), and is accompanied by feasts, cabaret shows, and general merrymaking. sometimes more than one holiday occurs on a single day, and once in a while all holidays take place on the same day. if this happens, the celebrations are combined and even more festive. after one such party, king johnny started behaving strangely and had to be temporarily isolated from society. for the period of king johnny's absence (about 48 hours) you have been appointed regent of byteland. as a true patriot, you know that holidays are not good for the people, and would like to remove some before king johnny returns (he won't mind, he never remembers anything after a party anyway). the people however, very sadly, don't know what is good for them, and will revolt if you remove more than k holidays. try to choose the holidays you remove in such a way as to guarantee that the number of days which elapse between two consecutive holiday parties is as long as possible. solve the problem in at most 4kb of source code. input the first line of input contains a single integer t<=200 - the number of test cases. t test case descriptions follow. for each test case, the first line contains two space separated integers n k (1<=k < n<=30), denoting the total number of holidays and the number of holidays to be removed. the next line contains n space separated integers, the i-th being ti (1<=ti<=1018) - the number of days every which the i-th holiday occurs. output for each test case, output one line containing an increasing sequence of exactly k integers - the numbers of the holidays to be removed (holidays are numbered in the input order from 1 to n). example input: 1 5 2 6 13 10 15 7 output: 2 5 (the shortest period between two successive holiday parties is 2 days.)
matchers have been designed for various sorts of patterns. mr. hkp likes to observe patterns in numbers. after completing his extensive research on the squares of numbers, he has moved on to cubes. now he wants to know all numbers whose cube ends in 888. given a number k, help mr. hkp find the kth number (indexed from 1) whose cube ends in 888. input the first line of the input contains an integer t, the number of test cases. t test cases follow. each test case consists of a single line containing a single integer k (1 <= k <= 2000000000000). output for each test case, output a single integer which denotes the kth number whose cube ends in 888. the result will be less than 263. example input: 1 1 output: 192
is only 6 years old, but he already has many skills. he likes drawing and asking riddles very much. this morning he got a sheet of grid paper and a pencil from his mother and he started drawing. all his drawings have some common properties: jasiek colors full grid squares; if some coloured grid squares touch each other, it means they have a common edge or a corner; all grid squares are connected, which means between every two coloured grid squares there is a sequence of coloured grid squares, which have a common edge; there are no white holes, that is from every white grid box it is possible to draw a line to the boundary of the sheet which never touches any coloured grid square. at noon mom phoned and asked what jasiek's today's picture was. the boy didn't answer directly, but described the picture by a sequence of moves needed to walk around the centres of the coloured squares on its boundary, ie. those squares which have at least one common corner with a white square. jasiek set the starting square and then gave the sequence of moves necessary to walk along the boundary squares anti-clockwise. mom was very surprised by the complexity of the picture and especcialy by the number of coloured squares. given jasiek's description, can you quickly count how many coloured squares there are in the picture? task write a program which reads (from standard input) jasiek's description of the picture, counts the number of coloured squares, writes out the outcome (to standard output). input ten test cases (given one under another, you have to process all!). each of the test cases is a series of lines. each line consists of only one character. the letter p means the beginning of the description. the letter k means the end of the desription (and the test case). all other lines (if any) contain one of the letters n, w, s or e (n meaning north, w - west, s - south and e - east). every line of the description corresponds to the relative position of the centre of some square on the boundary of the picture. the first and the last line correspond to the same square. a letter in a line other than the first or the last tells you which way you have to go in order to get to the next boundary square when going around the picture anti-clockwise. jasiek's description finishes after going around the picture once. the length of the description doesn't exceed 20000 letters. output for every testcase your program should write (to the standard output) only one line with one integer, equal to the number of coloured squares in jasiek's picture. example input: p s s s e n e e s e e n n n n s s s w w n n w w w n s k [and 9 test cases more] output: 23 [and 9 test cases more]
puzzles are usually simple and very entertaining for all ages. they are so entertaining that pizza-hut company started using table covers with word puzzles printed on them, possibly with the intent to minimise their client's perception of any possible delay in bringing them their order. even though word puzzles may be entertaining to solve by hand, they may become boring when they get very large. computers do not yet get bored in solving tasks, therefore we thought you could devise a program to speedup (hopefully!) solution finding in such puzzles. the following figure illustrates the pizzahut puzzle. the names of the pizzas to be found in the puzzle are: margarita, alema, barbecue, tropical, suprema, louisiana, cheeseham, europa, havaiana, camponesa. 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 0 q w s p i l a a t i r a g r a m y k e i 1 a g t r c l q a x l p o i j l f v b u q 2 t q t k a z x v m r w a l e m a p k c w 3 l i e a c n k a z x k p o t p i z c e o 4 f g k l s t c b t r o p i c a l b l b c 5 j e w h j e e w s m l p o e k o r o r a 6 l u p q w r n j o a a g j k m u s j a e 7 k r q e i o l o a o q p r t v i l c b z 8 q o p u c a j s p p o u t m t s l p s f 9 l p o u y t r f g m m l k i u i s x s w 10 w a h c p o i y t g a k l m n a h b v a 11 e i a k h p l b g s m c l o g n g j m l 12 l d t i k e n v c s w q a z u a o e a l 13 h o p l p g e j k m n u t i i o r m n c 14 l o i u f t g s q a c a x m o p b e i o 15 q o a s d h o p e p n b u y u y o b x b 16 i o n i a e l o j h s w a s m o u t r k 17 h p o i y t j p l n a q w d r i b i t g 18 l p o i n u y m r t e m p t m l m n b o 19 p a f c o p l h a v a i a n a l b p f s problem your task is to produce a program that given the word puzzle and words to be found in the puzzle, determines, for each word, the position of the first letter and its orientation in the puzzle. you can assume that the left upper corner of the puzzle is the origin, (0,0). furthemore, the orientation of the word is marked clockwise starting with letter a for north (note: there are 8 possible directions in total). input the first line of the input contains a number t ≤ 10 which indicates the number of test cases to follow. each test case starts with a line consisting of three positive numbers: the number of lines of the word puzzle, 0 < l ≤ 1000, the number of columns, 0 < c ≤ 1000, and the number of words to be found, 0 < w ≤ 1000. the following l input lines, each consisting of c uppercase letters, contain the word puzzle. then at last the w words are input one per line. you can assume that each word can be found exactly once in the word puzzle. output for each test case your program should output w lines: for each word (using the same order as the words were input) print a triplet defining the coordinates, line and column, where the first letter of the word appears, followed by a letter indicating the orientation of the word according to the rules defined above. each value in the triplet must be separated by one space only. print one blank line between test cases. example input: 1 20 20 10 qwspilaatiragramykei agtrclqaxlpoijlfvbuq tqtkazxvmrwalemapkcw lieacnkazxkpotpizceo fgklstcbtropicalblbc jewhjeewsmlpoekorora lupqwrnjoaagjkmusjae krqeioloaoqprtvilcbz qopucajsppoutmtslpsf lpouytrfgmmlkiuisxsw wahcpoiytgaklmnahbva eiakhplbgsmclogngjml ldtikenvcswqazuaoeal hoplpgejkmnutiiormnc loiuftgsqacaxmopbeio qoasdhopepnbuyuyobxb ioniaelojhswasmoutrk hpoiytjplnaqwdribitg lpoinuymrtemptmlmnbo pafcoplhavaianalbpfs margarita alema barbecue tropical suprema louisiana cheeseham europa havaiana camponesa output: 0 15 g 2 11 c 7 18 a 4 8 c 16 13 b 4 15 e 10 3 d 5 1 e 19 7 c 11 11 h
triangle can be divided into two equal triangles by drawing a median on its largest edge (in the figure below such a division is shown with the red line). then the smaller two triangles can be divided in similar fashion into equal triangles (shown in the picture below with blue lines). this process can continue forever. some mathematicians have found that when we split a triangle into smaller ones using the method specified above we have only some "styles" of triangles that only differ in size. so now given the lengths of the sides of the triangle your job is to find out how many different styles of small triangles we have. (two triangles are of same style if they are similar.) input first line of the input file contains an integer n (0 < n < 35) that indicates how many lines of input there are. each line contains three integers a, b, c (0 < a,b,c < 100) which indicate the sides of a valid triangle. (a valid triangle means a real triangle with positive area.) output for each line of input you should produce an integer t, which indicates the number of different styles of small triangles, formed for the triangle at input. look at the example for details. you can safely assume that for any triangle t will be less than 100. example input: 2 3 4 5 12 84 90 output: 3 41
has a difficult job. he must distribute advertising booklets for extra school activities in different schools. the booklets have different number of pages. bob has a list with the number of pages of each booklet and the number of schools that he must visit. he has to distribute the booklets such that each school gets a number of booklets equal to either the lower integer part (lip),or the upper integer part (uip) of the number of booklets divided by the number of schools. poor bob must obey other rules too. he must distribute all the uip number of booklets first and then the lip number of booklets. any booklet a that is distributed to a school s_i must have fewer or at most an equal number of pages that any other booklet b that is distributed to a school s_j, if s_i gets the booklets before s_j (i.e if i < j then pages(a) <= pages(b)). when bob distributes the booklets to a school he must distribute them in the same relative order in which they are on his list. moreover, he must distribute them very fast. when he comes back to the advertising company his boss verifies if he accomplished well his task, by asking him the number of pages of the first booklet distributed to a specific school, following the order in which bob visited the schools (starting with 0). difficult job, isn't it? can you help him? input the input starts with a line containing a single integer t <= 20, the number of test cases. t test cases follow. each data set in the input stands for a particular set of bookets. for each set of booklets the input contains the number of schools, the school specified by bob's boss, the number of booklets (less than 3000), the number of pages of each booklet (fits in integer). white spaces can occur freely between the numbers in the input. the input data are correct. output for each set of data the program prints the result to the standard output on a separate line. the solution is represented by the number of pages of the first booklet distributed to the specified school. example input: 1 3 2 7 3 5 9 1 11 14 2 output: 11
every year, the plans for the construction of motorways in poland are more and more advanced. for some time, it seemed as if the building was actually going to start, so the question of purchasing the land under the roads was of some importance. only certain cities can be connected by a road directly, provided the farmer owning the land under it agrees to sell out. as a result of the constant swing of moods, the price demanded for the land by each farmer changes in a linear fashion, with possibly different coefficients for every road. it may either increase or decrease (and sometimes even be negative, if the owner anticipates future profit from the proximity of a motorway). it has been decided that the purchase of land will be made at some moment in between two fixed dates. at that moment, the current prices of land will be frozen, and the least costly configuration of bidirectional roads connecting all cities (directly or indirectly) will be chosen. all the land under the selected roads will subsequently be bought at the frozen price. since business in the proximity of a motorway does have its advantages, some land owners might actually want their land to be bought and they may offer money into the bargain, consequently making the price of purchase negative. you act as an intermediary for the purchase and charge a steady commission, proportional to the total sum of purchase. oddly enough, when signing the contract you missed the clause about the possibility of the price being negative and now you begin to wonder whether you won't end up being charged for your own hard work. since it is one of your tasks to select the moment of purchase, do so in such a way as to maximise your profit (if this is impossible, at least cut your losses as much as possible). input the input begins with the integer t, the number of test cases. then t test cases follow. for each test case the first line contains two integers n m, denoting the number of cities to be connected and the number of available potential roads,respectively(1<=n<= 120,1<=m<=820). the next line contains two integers t1 t2, which stand for the earliest possible and latest possible moments of purchase (-10000<=t1<=t2<=10000). each of the following m lines contains four integers, the i-th being: ui vi ai bi, which means that the i-th road connects city ui with city vi, and the purchase of the land under it costs bi+j*ai units of currency at moment j (e.g. at moment 0 the land costs bi units). please note that these integers are chosen from the following ranges: 0<=ui,vi<=n-1, -32000<=ai,bi<=32000. output for each test case output a line with two floating point numbers, accurate to three digits after the decimal point. the first represents the moment of transaction you ought to choose, the second - the total value of the transaction at that moment. if more than one moment fulfills the conditions of the problem, choose the earliest. example sample input: 2 5 6 0 5 1 0 -6 -4 2 0 3 -3 3 0 1 5 3 1 -2 -3 4 1 -3 -2 4 3 -2 -3 5 7 -20 20 1 0 1 2 2 1 -7 4 3 1 -9 0 3 2 4 9 4 1 0 -2 4 2 2 3 4 3 6 -5 sample output: 0.000 -13.000 0.111 -1.000
has always been fascinated with chess boards (though he really sucks at chess). he makes an observation that a chess board is complete with respect to knights and rooks and incomplete with respect to bishops (unless the dimensions are 1 ã— 1). a complete chess board is one in which it is possible to traverse all the squares starting from one possible square. knights have always been his favourite pieces and he has decided to analyze completeness with respect to knights. given the dimesions of the chess board help buggyd find the lexicographically first path that visits all squares of a chess board with a knight. each square must be traversed only once. note that a knight can only move two squares in one direction and one square perpendicular to the previous direction. input the first line of the input contains an integer t, the number of test cases. t test cases follow. each test case consists of a single line cotaining two integers (x and y) separated by a single space, specifying the dimensions of the chess board. the numbers 1 to x denote rows and the capital letters a to y denote the coloumns. each square is represented by its column index followed by it's row index - for example, b4 denotes the square in the 4th row and 2nd column. the total number of squares on the chess board will be no more than 26. output for each test case output one line consisting of the lexicographically first path of the knight, or "-1" (quotes for clarity) if the chess board is incomplete with respect to a knight. example input: 1 4 5 output: a1b3c1a2b4d3e1c2d4e2c3a4b2d1e3c4a3b1d2e4
a sequence of consecutive integers n, n+1, n+2,..., m, an anti-prime sequence is a rearrangement of these integers so that each adjacent pair of integers sums to a composite (non-prime) number. for example, if n = 1 and m = 10, one such anti-prime sequence is 1, 3, 5, 4, 2, 6, 9, 7, 8, 10. this is also the lexicographically first such sequence. we can extend the definition by defining a degree d anti-prime sequence as one where all consecutive subsequences of length 2, 3,..., d sum to a composite number. the sequence above is a degree 2 anti-prime sequence, but not a degree 3, since the subsequence 5, 4, 2 sums to 11. the lexicographically first degree 3 anti-prime sequence for these numbers is 1, 3, 5, 4, 6, 2, 10, 8, 7, 9. input input will consist of multiple input sets. each set will consist of three integers, n, m, and d on a single line. the values of n, m and d will satisfy 1 ≤ n < m ≤ 1000, and 2 ≤ d ≤ 10. the line 0 0 0 will indicate end of input and should not be processed. output for each input set, output a single line consisting of a comma-separated list of integers forming a degree d anti-prime sequence (do not insert any spaces and do not split the output over multiple lines). in the case where more than one anti-prime sequence exists, print the lexicographically first one (i.e., output the one with the lowest first value; in case of a tie, the lowest second value, etc.). in the case where no anti-prime sequence exists, output: no anti-prime sequence exists. example input: 1 10 2 1 10 3 1 10 5 40 60 7 0 0 0 output: 1,3,5,4,2,6,9,7,8,10 1,3,5,4,6,2,10,8,7,9 no anti-prime sequence exists. 40,41,43,42,44,46,45,47,48,50,55,53,52,60,56,49,51,59,58,57,54
the number, you are to answer the question: "is it prime?" solutions to this problem can be submitted in c, c++, pascal, perl, python, ruby, lisp, hask, ocaml, prolog, whitespace, brainf**k and intercal only. input t â€“ the number of test cases, then t test cases follows. [t <= 500] each line contains one integer: n [2 <= n <= 2^63-1] output for each test case output string "yes" if given number is prime and "no" otherwise. example input: 5 2 3 4 5 6 output: yes yes no yes no
singh (a crook) has just robbed a bank and would like to get out of the country as soon as possible. but there is a slight problem, the police! on his way out of the country he has to pass through some police stations. each police station has a certain risk (for dhamaka singh) associated with it. he wants to get to the airport within a certain time t or else he'll miss his flight. he also wants to take a path that minimizes the total risk associated with it. help dhamaka singh get out of the country. input the first line of the input contains an integer t, the number of test cases. t test cases follow. the first line of each test case contains 2 integers n (3 <= n <= 100) and t (1 <= t <= 250), denoting the number of police stations and the total time he has to reach the airport, respectively. dhamaka singh has to start from the first police station and reach the nth one (the airport is just after the nth police station). you can consider the time taken between the nth police station and the airport to be negligible. next there are n lines with n numbers in each line, separated by single spaces. all numbers are separated by a single space. the jth integer in the ith line represents the time taken to reach the jth police station from the ith police station. next there are another n lines with n numbers in each line. all numbers are separated by a single space. the jth integer in the ith line represents the risk involved in travelling to the jth police station from the ith police station. output for each test case output one line containing 2 integers separated by a single space. the first integer denotes the minimum total risk to reach the airport. the second integer denotes the minimum time required to reach the airport at the minimum total risk. if it is impossible to reach the airport within time t (inclusive), just print "-1" (quotes for clarity). example input: 1 4 10 0 6 2 3 6 0 2 3 3 1 0 2 3 3 2 0 0 2 2 7 2 0 1 2 2 2 0 5 7 2 5 0 output: 4 9
two sequences of words: x=(x1,...,xn) and y=(y1,...,yn), determine how many binary sequences p=(p1,...,pn) exist, such that the word concatenation z1z2...zn, where zi=xi iff pi=1 and zi=yi iff pi=0, is a palindrome (a word which is the same when read from left to right and from right to left). input the input begins with the integer t, the number of test cases. then t test cases follow. for each test case the first line contains the positive integer n - the number of words in a sequence (1<=n<=30). the following n lines contain consecutive words of the sequence x, one word per line. the next n lines contain consecutive words of the sequence y, one word per line. words consist of lower case letters of the alphabet ('a' to 'z'), are non-empty, and not longer than 400 characters. output for each test case output one line containing a single integer - the number of different possible sequences p. example sample input: 1 5 ab a a ab a a baaaa a a ba sample output: 12
far can you make a stack of cards overhang a table? if you have one card, you can create a maximum overhang of half a card length. (we're assuming that the cards must be perpendicular to the table.) with two cards you can make the top card overhang the bottom one by half a card length, and the bottom one overhang the table by a third of a card length, for a total maximum overhang of 1/2 + 1/3 = 5/6 card lengths. in general you can make n cards overhang by 1/2 + 1/3 + 1/4 + ... + 1/(n + 1) card lengths, where the top card overhangs the second by 1/2, the second overhangs tha third by 1/3, the third overhangs the fourth by 1/4, etc., and the bottom card overhangs the table by 1/(n + 1). this is illustrated in the figure below. input the input consists of one or more test cases, followed by a line containing the number 0.00 that signals the end of the input. each test case is a single line containing a positive floating-point number c whose value is at least 0.01 and at most 5.20; c will contain exactly three digits. output for each test case, output the minimum number of cards necessary to achieve an overhang of at least c card lengths. use the exact output format shown in the examples. input: 1.00 3.71 0.04 5.19 0.00 output: 3 card(s) 61 card(s) 1 card(s) 273 card(s)
ancient mathematician and philosopher pythagoras believed that reality is mathematical in nature. present-day biologists study properties of biosequences. a biosequence is a sequence of m integers, which • contains each of the numbers 0,1,…,m-1, • starts with 0 and ends with m-1, and • has no two elements e,e+1 in adjacent positions in this order. a subsequence consisting of adjacent elements of a biosequence is called a segment.. a segment of a biosequence is called a framed interval if it includes all integers whose values are between the value of the first element, which must be the smallest element in the segment, and the last element, which must be the largest and different from the first. a framed interval is called an empodio if it does not contain any shorter framed intervals. as an example, consider the biosequence (0,3,5,4,6,2,1,7). the whole biosequence is a framed interval. however, it contains another framed interval (3,5,4,6) and therefore it is not an empodio. the framed interval (3,5,4,6) does not contain a shorter framed interval, so it is an empodio. furthermore, it is the only empodio in that biosequence. you are to write a program that, given a biosequence, finds all empodia (plural for empodio) in that biosequence. input t - the number of test cases [t <= 20], then t test cses follows. the first line of each test case contains a single integer m: the number of integers in the input biosequence. the following m lines contain the integers of the biosequence in the order of the sequence. each of these m lines contains a single integer. in one test case, 1000000 <= m <= 1100000. in all other test cases, 1 <= m <= 60000. additionally, in 50% of the test cases, m <= 2600. output the first line for each test case is to contain one integer h: the number of empodia in the input biosequence. the following h lines describe all empodia of the input biosequence in the order of appearance of the starting point in the biosequence. each of these lines is to contain two integers a and b (in that order) separated by a space, where the ath element of the input biosequence is the first element of the empodio and the bth element of the input biosequence is the last element of the empodio. example input: 1 8 0 3 5 4 6 2 1 7 output: 1 2 5
king of byteland likes greek mythology very much. the most impressive myth for him is the one about minotaur. a creature which was imprisoned in a maze-like construction. now the king wants to have similar maze. he ordered to his architect to build such construction. the architect decided that maze will have rectangular form. its floor will be made from large square plates. also there will be many walls, each of which will separate two common floor plates. from the bird's eye whole construction will look like a grid with some cells separated by walls. the maze should be very tricky, that's why he calls the maze correct if and only if for every two plates there is exactly one path between them. here path is a sequence of moves between plates that share a common side and are not separated by wall. each plate can only appear once in a path. sooner or later, the architect started his work. after a couple of months he created a rectangular area with h rows and w columns. also he has built k walls. sounds perfect but he was seized with a lingering doubt about correctness of his maze. that's why he asks you to help him. he wants to know how many different correct mazes can be built based on his current maze i.e. you can only add new walls but not to break any of the old ones. for example (see figure 1.) the maze size is 2x2 and there are no walls. all four ways to complete this maze are shown on the right of the figure (new walls are dashed). figure 2. illustrates maze of size 3x3 with 3 walls. there are exactly 4 ways to complete it. figure 3. shows the maze that cannot be completed, because there is no path from lower right plate to upper left one. input the first line contains two integer numbers w and h (1 ≤ w, h ≤ 5). second line contains one integer number k (k ≥ 0). next k lines contain description of walls. each wall is determined by two plates it separates. thus, each line contains four integer numbers: r_1, c_1, r_2 and c_2, here r_1 and c_1 - row and column coordinates of the first plate. similar, r_2 и c_2 - are coordinates of the second plate (1 ≤ r_1, r_2 ≤ h, 1 ≤ c_1, c_2 ≤ w). rows are numbered from up to bottom, colums - left to right started from 1. it is guaranteed that all walls are correct and there are no duplicates. walls that form perimeter of the maze will not be specified. output output the number of different correct mazes that can be built based on the given one. there should be no leading zeroes. example input: 2 2 0 output: 4 input: 3 3 3 3 1 3 2 2 2 2 3 2 3 3 3 output: 4 input: 3 3 5 3 1 3 2 2 2 2 3 2 3 3 3 2 2 2 1 1 2 2 2 output: 0
black box algorithm supposes that natural number sequence u(1), u(2) ... u(n) is sorted in non-descending order, n ≤ m and for each p (1 ≤ p ≤ n) an inequality p ≤ u(p) ≤ m is valid. making tests for this algorithm we have met with the following problem. for setting a random sequence {u(i)} a usual random data generator did not fit. as the sequence itself had been imposed certain restrictions, the method of choosing the next random element (in the interval defined by restrictions) did not give the random sequence as a whole. we have come to a conclusion that the problem can be solved in the following way. if we arrange all possible sequences in certain order (for example, in lexicographical order) and assign each sequence its number, after choice of the random number it is possible to take the correspondent sequence for the random one. at the first glance it seems enough to make up a program generating all these sequences in such order. alas! even having not great values of m and n it would have taken any powerful modern computer centuries to enumerate all such sequences. it turned out it was possible to avoid generating all sequences if we managed to create required sequence according to its number immediately. but even this statement does not cover all. as the amount of sequences is quite large, the number can be a long one, composed of hundreds decimal digits, though our random data generator could give only normal numbers. we decided to produce a long random number from a real random number distributed in [0, 1]. namely, present the number in binary notation: 0.b(1)b(2)..., where all b(i) = 0 or 1. let us set a regulation to associate such real number to an integer from [a, b] segment: formula here we suppose, that a ≤ b, p ≥ 0 and "div 2" is an integer division by 2. let m, n (1 ≤ n ≤ m ≤ 200) and a binary real number 0.b(1)b(2) ... b(p) (1 ≤ p ≤ 400) be given. write a program to find out the corresponding u(1), u(2) ... u(n) sequence, i.e. to find a sequence with g(1, t, 0.b(1)b(2) ... b(p)) number in lexicographical order of all possible {u(i)} for the given m and n (t is the quantity of such sequences). numeration begins with 1. keep in mind that in lexicographical order {l(i)} proceeds {h(i)} if after omitting equal beginnings, the first number of {l(i)} tail is smaller than the first number or {h(i)} tail. the following example illustrates the list of all possible sequences for m = 4 and n = 3 in lexicographical order. a note (it does not concern the solution of this task): the choice of random binary vector 0.b(1)b(2) ... b(p) does not give an absolute uniform random data generator if we use the formula. however, taking into account the fact that [a, b] interval is big we shall obtain a distribution applicable in most cases. example 1, 2, 3 1, 2, 4 1, 3, 3 1, 3, 4 1, 4, 4 2, 2, 3 2, 2, 4 2, 3, 3 2, 3, 4 2, 4, 4 3, 3, 3 3, 3, 4 3, 4, 4 4, 4, 4 (here t = 14) input the first line of the input is an integer k ≤ 10, followed by k datasets. the first line of each dataset contains m and n. the second line contains binary real number 0.b(1)b(2) ... b(p) (without leading, trailing and other spaces). output for each dataset, write into the output data file the corresponding sequence u(1), u(2) ... u(n). the sequence numbers should be separated with spaces and end-of-line characters. there should be up to 20 numbers in each line. if necessary, the numbers will have leading blanks to occupy 3 characters. example input: 1 4 3 0.01101101011110010001101010001011010 output: 2 2 4
uses a new special technology of building its transceiver stations. this technology is called modular cuboid architecture (mca) and is covered by a patent of lego company. all parts of the transceiver are shipped in unit blocks that have the form of cubes of exactly the same size. the cubes can be then connected to each other. the mca is modular architecture, that means we can select preferred transceiver configuration and buy only those components we need . the cubes must be always connected "face-to-face", i.e. the whole side of one cube is connected to the whole side of another cube. one cube can be thus connected to at most six other units. the resulting equipment, consisting of unit cubes is called the bulk in the communication technology slang. sometimes, an old and unneeded bulk is condemned, put into a storage place, and replaced with a new one. it was recently found that acm has many of such old bulks that just occupy space and are no longer needed. the director has decided that all such bulks must be disassembled to single pieces to save some space. unfortunately, there is no documentation for the old bulks and nobody knows the exact number of pieces that form them. you are to write a computer program that takes the bulk description and computes the number of unit cubes. each bulk is described by its faces (sides). a special x-ray based machine was constructed that is able to localise all faces of the bulk in the space, even the inner faces, because the bulk can be partially hollow (it can contain empty spaces inside). but any bulk must be connected (i.e. it cannot drop into two pieces) and composed of whole unit cubes. input there is a single positive integer t on the first line of input (equal to about 1000). it stands for the number of bulks to follow. each bulk description begins with a line containing single positive integer f, 6 <= f <= 250, stating the number of faces. then there are f lines, each containing one face description. all faces of the bulk are always listed, in any order. any face may be divided into several distinct parts and described like if it was more faces. faces do not overlap. every face has one inner side and one outer side. no side can be "partially inner and partially outer". each face is described on a single line. the line begins with an integer number p stating the number of points that determine the face, 4 <= p <= 200. then there are 3 x p numbers, coordinates of the points. each point is described by three coordinates x,y,z (0 <= x,y,z <= 1000) separated by spaces. the points are separated from each other and from the number p by two space characters. these additional spaces were added to make the input more human readable. the face can be constructed by connecting the points in the specified order, plus connecting the last point with the first one. the face is always composed of "unit squares", that means every edge runs either in x, y or z-axis direction. if we take any two neighbouring points x1,y1,z1 and x2,y2,z2, then the points will always differ in exactly one of the three coordinates. i.e. it is either x1 <> x2, or y1 <> y2, or z1 <> z2, other two coordinates are the same. every face lies in an orthogonal plane, i.e. exactly one coordinate is always the same for all points of the face. the face outline will never touch nor cross itself. output your program must print a single line for every test case. the line must contain the sentence the bulk is composed of v units., where v is the volume of the bulk. example sample input: 2 12 4 10 10 10 10 10 20 10 20 20 10 20 10 4 20 10 10 20 10 20 20 20 20 20 20 10 4 10 10 10 10 10 20 20 10 20 20 10 10 4 10 20 10 10 20 20 20 20 20 20 20 10 4 10 10 10 10 20 10 20 20 10 20 10 10 5 10 10 20 10 20 20 20 20 20 20 15 20 20 10 20 4 14 14 14 14 14 16 14 16 16 14 16 14 4 16 14 14 16 14 16 16 16 16 16 16 14 4 14 14 14 14 14 16 16 14 16 16 14 14 4 14 16 14 14 16 16 16 16 16 16 16 14 4 14 14 14 14 16 14 16 16 14 16 14 14 4 14 14 16 14 16 16 16 16 16 16 14 16 12 4 20 20 30 20 30 30 30 30 30 30 20 30 4 10 10 10 10 40 10 40 40 10 40 10 10 6 10 10 20 20 10 20 20 30 20 30 30 20 30 40 20 10 40 20 6 20 10 20 20 20 20 30 20 20 30 40 20 40 40 20 40 10 20 4 10 10 10 40 10 10 40 10 20 10 10 20 4 10 40 10 40 40 10 40 40 20 10 40 20 4 20 20 20 30 20 20 30 20 30 20 20 30 4 20 30 20 30 30 20 30 30 30 20 30 30 4 10 10 10 10 40 10 10 40 20 10 10 20 4 40 10 10 40 40 10 40 40 20 40 10 20 4 20 20 20 20 30 20 20 30 30 20 20 30 4 30 20 20 30 30 20 30 30 30 30 20 30 sample output: the bulk is composed of 992 units. the bulk is composed of 10000 units. warning: large input/output data, be careful with certain languages
wants to plan what to cook in the next days. he can cook various dishes. for each dish the costs of the ingredients and the benefit value is known. if a dish is cooked the second time in a row, the benefit value for the second time is 50 percent of the benefit value of first time, if it is prepared for the third or higher time in a row, the benefit value is 0. for example cooking a dish with benefit value v three times in a row leads to a total benefit value of 1.5*v. help him to build the menu which maximizes the benefit value under the constraint that his budget is not exceeded. input the input consists of several test cases. each test case begins with 3 integers in a line: the number of days k (1 ≤ k ≤ 21) alfred wants to plan for, the number of dishes n (1 ≤ n ≤ 50) he can cook and his budget m (0 ≤ m ≤ 100). the following n lines describe the dishes alfred can cook. the i-th line contains two integers: the costs c (1 ≤ c ≤ 50) and the benefit value v (1 ≤ v ≤ 10000) of the i-th dish. the end of the input is signalled by a test case with k = n = m = 0. you don't need to process this test case. output for each output, print the maximum benefit value reachable with 1 digit after the decimal point. then print k integers with i-th integer being the number of the dish to cook on day i. dishes are numbered from 1 to n. print at least one space or new line character after each integer. if there are several possible menus reaching the maximum benefit value, select the one with minimum costs, if there are several with minimum costs, you can print any of them. if every menu exceeds the budget, print only the benefit value of 0. example input: 2 1 5 3 5 3 5 20 2 5 18 6 1 1 3 3 2 3 0 0 0 output: 0.0 13.0 1 5 1
vietnamese farmer john and bessie the cow have embarked on one of those 'active' vacations. they spend entire days walking in the mountains and then, at the end of the day, they tire and return to their vacation cabin. since climbing requires a lot of energy and they are already tired, they wish to return to the cabin using a path that has the least difference between its highest and lowest elevations, no matter how long that path is. help fj find this easy-to-traverse path. the map of the mountains is given by an n x n (2 <= n <= 100) matrix of integer elevations (0 <= any elevation <= 110) fj and bessie are currently at the upper left position (row 1, column 1) and the cabin is at the lower right (row n, column n). they can travel right, left, toward the top, or toward the bottom of the grid. they can not travel on a diagonal. input line 1: the single integer, n lines 2..n+1: each line contains n integers, each of which specifies a square's height. line 2 contains the first (top) row of the grid; line 3 contains the second row, and so on. the first number on the line corresponds to the first (left) column of the grid, and so on. output an integer that is the minimal height difference on the optimal path. example input: 5 1 1 3 6 8 1 2 2 5 5 4 4 0 3 3 8 0 2 3 4 4 3 0 2 1 output: 2
byteland they have a very strange monetary system. each bytelandian gold coin has an integer number written on it. a coin n can be exchanged in a bank into three coins: n/2, n/3 and n/4. but these numbers are all rounded down (the banks have to make a profit). you can also sell bytelandian coins for american dollars. the exchange rate is 1:1. but you can not buy bytelandian coins. you have one gold coin. what is the maximum amount of american dollars you can get for it? input the input will contain several test cases (not more than 10). each testcase is a single line with a number n, 0 <= n <= 1 000 000 000. it is the number written on your coin. output for each test case output a single line, containing the maximum amount of american dollars you can make. example input: 12 2 output: 13 2 you can change 12 into 6, 4 and 3, and then change these into $6+$4+$3 = $13. if you try changing the coin 2 into 3 smaller coins, you will get 1, 0 and 0, and later you can get no more than $1 out of them. it is better just to change the 2 coin directly into $2.
agents need to unite. they are on a road and each of them possess a special device which can both send and receive signals, in both directions up to a maximal distance of d units. apart from this small limitation, the devices work very efficiently so that the time taken for interdevice communication is practically zero. now that the agents are at different points on the road, for them to be able to communicate with each other at will, every agent should be connected to every other agent through one or more intermediate devices. for example: agent a may communicate to agent c via agent b’s device, when a and c are not close enough. this happens when dist(a, c) > d, but dist(a, b) <= d and dist(b, c) <= d. getting the line ready, is the process of agents moving from their current positions in order to get the network fully connected. that is, from every agent to every other agent, there is a communication path. the agent’s final positions (in two cases that are going to follow) are decided by a programmer, who watches the scene from above and instructs each agent of the time to move and the final position to move to. each agent moves a unit distance in unit time. we need to find the minimal time taken for the programmer to “get the line ready” if he moves the agents: 1. independently: in other words, every agent moves to their final position without waiting for any other agent; all agents are told of their final positions at time zero. 2. sequentially: in this the agents form a definite sequence of movement. no two agents are moving at the same time. input t – number of test cases. for each test case : n d – where n is the number of agents, d is the maximal communication distance the i-th line, of the n-lines that follow gives the position of the i-th agent on the road currently. output for each test case, output two integers; 1st – minimal time taken to unite if they move independently 2nd – minimal time taken to unite if they move sequentially constraints: t<=20 1<=n, d<=100 ; each agent's initial position is between 0 and 1000. example sample input: 2 4 3 10 20 30 35 5 3 1 2 3 4 30 sample output: 8 23 12 23
n integer registers r1, r2 ... rn we define a compare-exchange instruction ce(a, b), where a, b are register indices (1 <= a < b <= n): ce(a, b):: if content(ra) > content(rb) then exchange the contents of registers ra and rb; a compare-exchange program (shortly ce-program) is any finite sequence of compare-exchange instructions. a ce-program is called a minimum-finding program if after its execution the register r1 always contains the smallest value among all values in the registers. such a program is called reliable if it remains a minimum-finding program after removing any single compare-exchange instruction. given a ce-program p, what is the smallest number of instructions that should be added at the end of program p in order to get a reliable minimum-finding program? for instance, consider the following ce-program for 3 registers: ce(1, 2), ce(2, 3), ce(1, 2). in order to make this program a reliable minimum-finding program it is sufficient to add only two instructions: ce(1, 3) and ce(1, 2). task write a program that: reads the description of a ce-program, computes the smallest number of ce-instructions that should be added to make this program a reliable minimum-finding program, writes the result. input the first line of the input contains exactly one positive integer d equal to the number of data sets, 1 <= d <= 10. the data sets follow. each data set consists of exactly two consecutive lines. the first of those lines contains exactly two integers n and m separated by a single space, 2 <= n <= 10000, 0 <= m <= 25000. integer n is the number of registers and integer m is the number of program instructions. the second of those lines contains exactly 2m integers separated by single spaces - the program itself. integers aj, bj on positions 2j-1 and 2j, 1 <= j < = m, 1 < = aj < bj <= n, are parameters of the j-th instruction in the program. output the output should consist of exactly d lines, one line for each data set. line i, 1 <= i <= d, should contain only one integer - the smallest number of instructions that should be added at the end of the i-th input program in order to make this program a reliable minimum-finding program. example input: 1 3 3 1 2 2 3 1 2 output: 2
called commedia dell' arte is a theater genre first played in italy at the beginning of the sixteenth century. it was inspired with the roman theater. the play had no fixed script and the actors (also called performers) had to improvise a lot. there were only a simple directions by the author like "enter the stage and make something funny" or "everyone comes on stage and everything is resolved happily". you can see it might be very interesting to play the commedia dell' arte. therefore the acm want to put a new play on a stage, which was completely unknown before. the main hero has a puzzle that takes a very important role in the play and gives an opportunity of many improvisations. the puzzle is the worldwide known lloyd's fifteen puzzle. acm wants to make the play more interesting so they want to replace the "standard" puzzle with a three-dimensional one. the puzzle consists of a cube containing m3 slots. each slot except one contains a cubic tile (one position is free). the tiles are numbered from 1 to m3-1. the goal of the puzzle is to get the original ordering of the tiles after they have been randomly reshuffled. the only allowed moves are sliding a neighbouring tile into the free position along one of the three principal directions. original configuration is when slot with coordinates (x,y,z) from {0,...,m-1}3 contains tile number z.m2+y.m+x+1 and slot (m-1,m-1,m-1) is free. you are to write a program to determine whether it is possible to solve the puzzle or not. input the input consists of n cases. the first line of the input contains only positive integer n. then follow the cases. the first line of each case contains only one integer m, 1 <= m <= 100. it is the size of 3d puzzle cube. then follow m lines, each contains exactly m2 numbers on the tiles for one layer. first is the layer on the top of the cube and the last one on the bottom. in each layer numbers are arranged from the left top corner linewise to the right bottom corner of the layer. in other words, slot with coordinates (x,y,z) is described by the (x+m.y+1)-th number on the (z+1)-th line. numbers are separated by space. number 0 means free position. output for each case, print exactly one line. if the original configuration can be reached by sliding the tiles, print the sentence 'puzzle can be solved.'. otherwise, print the sentence 'puzzle is unsolvable.'. example sample input: 2 2 1 2 3 4 5 7 6 0 2 2 1 3 5 4 6 0 7 sample output: puzzle is unsolvable. puzzle can be solved. warning: large input/output data, be careful with certain languages
consider only special type of tournaments. each tournament consists of a series of matches. we have n competitors at the beginning of a competition and after each match the loser is moved out of the competition and the winner stays in (there are no draws). the tournament ends when there is only one participant left - the winner. it is a task of national sports federation to schedule the matches. members of this committee can pick the contestants for the first match. then, after they know the result, they say which of the remaining contestants meet in the second match, and so on until there is only one participant left. it is easy to see that not only skill and training decides about the win, but also "luck" - i.e. the schedule. the members of nsf know it as well. the committee used the training time to look carefully on the performance of each probable contestant. it is clear now, at the start of the season, that some of the results between the competitors are 100% predictable. having this information nsf considers if it is possible to schedule the matches in such a way that the given contestant x wins. that is to plan the matches for x only with those who will lose with him (then he wins the whole tournament of course). if it is possible then w say that the tournament can be set for x. task your task is to write a program which determines the number of contestants of a given tournament for which it is possible to set it. input t [number of tests to solve]. in the first line of each test: n (1<=n<=1000) - the number of participants of the tournament. we number the participants with numbers 1, 2 ... n. the following line contains a list of participants who will inevitably win with participant 1. this list begins with a number m (the number of contestants "better" than 1) and numbers n1, n2 ... nm delimited by single spaces. next n-1 lines contain analogous lists for participants 2, 3 ... n. remark 1. the fact that participant a would lose with b and b would lose with c doesn't necessarily mean that a would lose with c in a direct match. remark 2. it is not possible that a is on the list of contestants better than b and b is on the list of a at the same time. output for each test your program should output a single integer - the number of participants, for which it is possible to set the tournament. example input: 1 3 2 3 2 1 3 0 output: 1
may know the great american cartoon called tom and jerry. in that cartoon, tom is a stupid cat, and jerry is a cute mouse. they are all living in blue mary's house. (maybe the name of the owner of the house they living in is not blue mary, but this is not important. ^_^) one day jerry gets a gps, so after that he can detect tom's position accurately. he decides to play tricks on tom again. the house has n (1<= n <= 1000) rooms numbered from 1 to n and e (1<= e <=1000) corridors, each connects two different rooms, and there is at most one corridor between two rooms. when jerry gets the gps, he is in room number p (1<= p <=n) while tom is in room number q (1<= q <= n). you may assume that room number p and room number q is in one connected component and they are not the same room. since jerry is very cute and tom is very stupid, if they are in the same room, jerry can befool tom as soon as possible. now jerry wants to get to tom's room as soon as possible. at each time unit, he will detect tom's position, and choose the room next to his room which is the nearest to tom's position and go to that room. if there are several rooms satisfied the condition above, he will choose the one with the least room number. after that, if they are in the same room, jerry will stay and play tricks on tom, or he will repeat this progress one more time otherwise. now poor tom doesn't know he'll be played, he is taking a walk in the house leisurely. each time unit he will choose a room next to the room he is in and go to that room or stay in the room he is in now, with equal probability. for example, if tom is now in room 1, room 2 and room 3 are the only neighbors of room 1 (i.e. there is a corridor between room 1 and room 2, and there is a corridor between room 1 and room 3), at the next time unit, the probability of that tom is in room 1, 2 or 3 are all 1/3. suppose at each time unit, jerry moves first, and tom will move after jerry complete his move. you task is to calculate the expected time unit from the time when jerry gets the gps to the time when jerry and tom are in the same room. input multiple test cases, the number of them is given in the very first line. for each test case: the first line contains two space-separated integers n and e. the second line contains two space-separated integers p and q. e lines then follow, each contains 2 space-separated integers a and b which shows that there is a corridor between room a and room b. output for each test case: output one line, which contains a single real number - the expected time unit, rounded to 3 decimal places. example input: 2 4 3 1 4 1 2 2 3 3 4 9 9 9 3 1 2 2 3 3 4 4 5 3 6 4 6 4 7 7 8 8 9 output: 1.500 2.167
the beginning of spring all the sheep move to the higher pastures in the mountains. if there are thousands of them, it is well worthwhile gathering them together in one place. but sheep don't like to leave their grass-lands. help the shepherd and build him a fence which would surround all the sheep. the fence should have the smallest possible length! assume that sheep are negligibly small and that they are not moving. sometimes a few sheep are standing in the same place. if there is only one sheep, it is probably dying, so no fence is needed at all... input t [the number of tests <= 100] [empty line] n [the number of sheep <= 100000] x1 y1 [coordinates of the first sheep] ... xn yn [integer coordinates from -10000 to 10000] [empty line] [other lists of sheep] text grouped in [ ] does not appear in the input file. assume that sheep are numbered in the input order. output o [length of circumference, rounded to 2 decimal places] p1 p2 ... pk [the sheep that are standing in the corners of the fence; the first one should be positioned bottommost and as far to the left as possible, the others ought to be written in anticlockwise order; ignore all sheep standing in the same place but the first to appear in the input file; the number of sheep should be the smallest possible] [empty line] [next solutions] example input: 8 5 0 0 0 5 10 5 3 3 10 0 1 0 0 3 0 0 1 0 2 0 4 0 0 0 0 0 1 1 0 3 0 0 0 1 1 0 6 0 0 -1 -1 1 1 2 2 3 3 4 4 2 10 0 0 0 7 -3 -4 2 -3 4 3 -4 2 0 5 2 -3 -1 4 output: 30.00 1 5 3 2 0.00 1 4.00 1 3 3.41 1 4 3 3.41 1 3 2 14.14 2 6 20.00 2 1 26.98 1 2 3 5 4 warning: large input/output data, be careful with certain languages
corp." is a very small company that owns a single airplane. the customers of abeas corp are large airline companies which rent the airplane to accommodate occasional overcapacity. customers send renting orders that consist of a time interval and a price that the customer is ready to pay for renting the airplane during the given time period. orders of all the customers are known in advance. of course, not all orders can be accommodated and some orders have to be declined. eugene lawler, the chief scientific officer of abeas corp would like to maximize the profit of the company. you are requested to compute an optimal solution. small example consider for instance the case where the company has 4 orders: order 1 (start time 0, duration 5, price 10) order 2 (start time 3, duration 7, price 8) order 3 (start time 5, duration 9, price 7) order 4 (start time 6, duration 9, price 8) the optimal solution consists in declining order 2 and 3 and the gain is 10+8 = 18. note that the solution made of order 1 and 3 is feasible (the airplane is rented with no interruption from time 0 to time 14) but non-optimal. input the first line of the input contains a number t ≤ 30 that indicates the number of test cases to follow. the first line of each test case contains the number of orders n (n ≤ 10000). in the following n lines the orders are given. each order is described by 3 integer values: the start time of the order st (0 ≤ st < 1000000), the duration d of the order (0 < d < 1000000), and the price p (0 < p < 100000) the customer is ready to pay for this order. output you are required to compute an optimal solution. for each test case your program has to write the total price paid by the airlines. example input: 1 4 0 5 10 3 7 14 5 9 7 6 9 8 output: 18 warning: large input/output data, be careful with certain languages
old tube screen to your computer turned out to be the cause of your chronic headaches. you therefore decide to buy one of these new flat tft monitors. at the entrance of the computer shop you see that it is quite full with customers. in fact, the shop is rather packed with customers and moving inside involves a certain amount of elbowing. since you want to return home quickly to complete your half finished spoj tasks, you want to sidestep the crowd as much as possible. you examine the situation somewhat closer and realise that the crowding is less in some parts of the shop. thus, there is reason for hope that you can reach your goal in due time, provided that you take the shortest way. but which way is the shortest way? you sketch the situation on a piece of paper but even so, it is still a tricky affair. you take out your notebook from your pocket and start to write a program which will find the shortest way for you. input the first line of the input specifies the width w and height h of the shop. neither dimension exceeds 25. the following h lines contain w characters each. a letter x symbolises a shelf, the letter s marks your starting position, and the letter d marks the destination (i.e. the square in front of the monitors). all free squares are marked with a digit from 1 to 9, meaning the number of seconds needed to pass this square. there are many test cases separated by an empty line. input terminates with width and height equal 0 0. output your program is to output the minimum number of seconds needed to reach to destination square. each test case in a separate line. movements can only be vertical and horizontal. of course, all movements must take place inside the grid. there will always be a way to reach the destination. example sample input: 4 3 x1s3 42x4 x1d2 5 5 s5213 2x2x5 51248 4x4x2 1445d 0 0 sample output: 4 23
task is to calculate the result of the hashing process in a table of 101 elements, containing keys that are strings of length at most 15 letters (ascii codes 'a',...,'z'). implement the following operations: find the index of the element defined by the key (ignore, if no such element), insert a new key into the table (ignore insertion of the key that already exists), delete a key from the table (without moving the others), by marking the position in table as empty (ignore non-existing keys in the table) when performing find, insert and delete operations define the following function: integer hash(string key), which for a string key=a1...an returns the value: hash(key)=h(key) mod 101, where h(key)=19 *(ascii(a1)*1+...+ascii(an)*n). resolve collisions using the open addressing method, i.e. try to insert the key into the table at the first free position: (hash(key)+j2+23*j) mod 101, for j=1,...,19. after examining of at least 20 table entries, we assume that the insert operation cannot be performed. input t [the number of test cases <= 100] n1 [the number of operations (one per line)[<= 1000] add:string [or] del:string [other test cases, without empty lines betwee series] output for every test case you have to create a new table, insert or delete keys, and write to the output: the number of keys in the table [first line] index:key [sorted by indices] example input: 1 11 add:marsz add:marsz add:dabrowski add:z add:ziemii add:wloskiej add:do add:polski del:od del:do del:wloskiej output: 5 34:dabrowski 46:polski 63:marsz 76:ziemii 96:z
preseason and the local newspaper wants to publish a preseason ranking of the teams in the local amateur basketball league. the teams are the ants, the buckets, the cats, the dribblers, and the elephants. when scoop mcgee, sports editor of the paper, gets the rankings from the selected local experts down at the hardware store, he’s dismayed to find that there doesn’t appear to be total agreement and so he’s wondering what ranking to publish that would most accurately reflect the rankings he got from the experts. he’s found that finding the median ranking from among all possible rankings is one way to go. the median ranking is computed as follows: given any two rankings, for instance acdbe and abcde, the distance between the two rankings is defined as the total number of pairs of teams that are given different relative orderings. in our example, the pair b, c is given a different ordering by the two rankings. (the first ranking has c above b while the second ranking has the opposite.) the only other pair that the two rankings disagree on is b, d; thus, the distance between these two rankings is 2. the median ranking of a set of rankings is that ranking whose sum of distances to all the given rankings is minimal. (note we could have more than one median ranking.) the median ranking may or may not be one of the given rankings. suppose there are 4 voters that have given the rankings: abdce, bacde, abced and acbde. consider two candidate median rankings abcde and cdeab. the sum of distances from the ranking abcde to the four voted rankings is 1 + 1 + 1 + 1 = 4. we’ll call this sum the value of the ranking abcde. the value of the ranking cdeab is 7 + 7+ 7 + 5 = 26. it turns out that abcde is in fact the median ranking with a value of 4. input there will be multiple input sets. input for each set is a positive integer n on a line by itself, followed by n lines (n no more than 100), each containing a permutation of the letters a, b, c, d and e, left-justified with no spaces. the final input set is followed by a line containing a 0, indicating end of input. output output for each input set should be one line of the form: ranking is the median ranking with value value. of course ranking should be replaced by the correct ranking and value with the correct value. if there is more than one median ranking, you should output the one which comes first alphabetically. example input: 4 abdce bacde abced acbde 0 output: abcde is the median ranking with value 4.
company provides service for its partners that are located in different towns. the company has three mobile service staff employees. if a request occurs at some location, an employee of the service staff must move from his current location to the location of the request (if no employee is there) in order to satisfy the request. only one employee can move at any moment. they can move only on request and are not allowed to be at the same location. moving an employee from location p to location q incurs a given cost c(p, q). the cost function is not necessarily symmetric, but the cost of not moving is 0, i.e. c(p, p)=0. the company must satisfy the received requests in a strict first-come, first-serve basis. the goal is to minimize the total cost of serving a given sequence of requests. you are to write a program that decides which employee of the service staff is to move for each request such that the total cost of serving the given sequence of requests is as small as possible. input the first line of input contains the number of test cases - ntest. each test case contains: the first line of each test cases contains two integers, l and n. l (3 <= l <= 200) is the number of locations and n (1 <= n <= 1000) is the number of requests. locations are identified by the integers from 1 to l. each of the next l lines contains l non-negative integers. the jth number in the line i+1 is the cost c(i,j), and it is less than 2000. the last of each test cases contains n integers, the list of the requests. a request is identified by the identifier of the location where the request occurs. initially, the three service staff employees are located at location 1, 2 and 3, respectively. output for each test case write the minimal total cost in a separate line. example input: 1 5 9 0 1 1 1 1 1 0 2 3 2 1 1 0 4 1 2 1 5 0 1 4 2 3 4 0 4 2 4 1 5 4 3 2 1 output: 5
day, mathematician and philosopher were engaged in a heated dispute. philosopher said: - ideal line has only length and no width, therefore, no line can have an area. mathematician replied: - that's as it may be, but still you can fill a square with a line in such a way that there will be no gaps. and you can't deny that a square has an area, and he grinned. but philosopher still wasn't convinced: - show me this line, then. - with pleasure... - responded mathematician and scribbled some equations on a piece of paper: - with t increasing, the point (x, y) will move around the square, forming a line. - so what? - asked philosopher. how is it going to ll the entire square? - indeed, it will, - said mathematician, - whichever point inside the square you draw, the line will eventually cross that point. - no, - replied philosopher indignantly, - anyway, i don't believe. when will the line cross this point? - and he put a thick dot inside the square. give philosopher an answer. input t â€“ number of tests [t <= 150], than t test cases follows. the first line of each test case contains the coordinates (x0, y0) of the dot center (-1 <= x0, y0 <= 1). the second line contains eps <= 0.0001 - the radius of the dot (the dot is essentially a small circle). output for each test case output any value of t in the segment [0, 10^12], which corresponds to the line crossing the dot, or "fail", if the line doesn't cross the dot. example sample input: 1 0.744 0.554 0.01 sample output: 5.3
magician shuffles a small pack of cards, holds it face down and performs the following procedure: the top card is moved to the bottom of the pack. the new top card is dealt face up onto the table. it is the ace of spades. two cards are moved one at a time from the top to the bottom. the next card is dealt face up onto the table. it is the two of spades. three cards are moved one at a time… this goes on until the nth and last card turns out to be the n of spades. this impressive trick works if the magician knows how to arrange the cards beforehand (and knows how to give a false shuffle). your program has to determine the initial order of the cards for a given number of cards, 1 ≤ n ≤ 20000. input on the first line of the input is a single positive integer, telling the number of test cases to follow. each case consists of one line containing the integer n. output for each test case, output a line with the correct permutation of the values 1 to n, space separated. the first number showing the top card of the pack, etc… example input: 2 4 5 output: 2 1 4 3 3 1 4 5 2
floor of a store is a rectangle divided into n*m square fields. two fields are adjacent, if they have a common side. a parcel lays on one of the fields. each of the remaining fields is either empty, or occupied by a case, which is too heavy to be moved by a store-keeper. the store-keeper has to shift the parcel from the starting field p to the final field k. he can move on the empty fields, going from the field on which he stands to a chosen adjacent field. when the store-keeper stays on a field adjacent to the one with the parcel he may push the parcel so that if moves to the next field (i.e. the field on the other side of the parcel), assuming condition that there are no cases on this field. task write a program, which: reads from the standard input a store scheme, a starting position of the store-keeper and a final position of the parcel, computes minimal number of the parcel shifts through borders of fields, which are necessary to put the parcel in the final position or decides that it is impossible to put the parcel there, writes the result into the standard output. input the number of test cases t is in the first line of input, then t test cases follow separated by an empty line. in the first line of each test case two positive integers separated by a single space, n,m<=100, are written. these are dimensions of the store. in each of the following n lines there appears one m-letter word made of letters s, m, p, k, w. a letter on i-th position in j-th word denotes a type of the field with coordinates (i,j) and its meaning is following: s - case, m - starting position of the store-keeper, p - starting position of the parcel, k - final position of the parcel, w - empty field. each letter m, p and k appears in the test case exactly once. output your program should write to the standard output for each test case: exactly one word no if the parcel cannot be put on the target field, exactly one integer, equal to the minimal number of the parcel shifts through borders of the fields, necessary to put a parcel on a final position, if it is possible to put the parcel there. example sample input: 1 10 12 ssssssssssss swwwwwwwssss swsssswwssss swsssswwskss swsssswwswss swwwwwpwwwww ssssssswswsw ssssssmwswww ssssssssssss ssssssssssss sample output 7
the next century certain regions on earth will experience severe water shortages. the old town of uqbar has already started to prepare itself for the worst. recently they created a network of pipes connecting the cisterns that distribute water in each neighbourhood, making it easier to fill them at once from a single source of water. but in case of water shortage the cisterns above a certain level will be empty since the water will flow to the cisterns below. you have been asked to write a program to compute the level to which cisterns will be filled with a certain volume of water, given the dimensions and position of each cistern. to simplify we will neglect the volume of water in the pipes. task write a program that: reads the description of cisterns and the volume of water, computes the level to which the cisterns will be filled with the given amount of water, writes the result. input the first line of the input contains the number of data sets k, 1 <= k <= 30. the data sets follow. the first line of each data set contains one integer n, the number of cisterns, 1 <= n <= 50000. each of the following n lines consists of 4 nonnegative integers, separated by single spaces: b, h, w, d - the base level of the cistern, its height, width and depth in meters, respectively. the integers satisfy 0 <= b <= 106 and 1 <= h*w*d <= 40000. the last line of the data set contains an integer v - the volume of water in cubic meters to be injected into the network. integer v satisfies 1 <= v <= 2*109. output the output should consist of exactly d lines, one line for each data set. line i, 1 <= i <= d, should contain the level that the water will reach, in meters, rounded to two fractional digits, or the word "overflow" (without quotes), if the volume of water exceeds the total capacity of the cisterns. example sample input: 3 2 0 1 1 1 2 1 1 1 1 4 11 7 5 1 15 6 2 2 5 8 5 1 19 4 8 1 132 4 11 7 5 1 15 6 2 2 5 8 5 1 19 4 8 1 78 sample output: 1.00 overflow 17.00 warning: enormous input/output data, be careful with certain languages
xml (extensible markup language) is gaining popularity as a new standard for data representation and exchange on the internet. xml provides a text-based means to describe and apply a tree-based structure to information. the xml document consists of nested elements, some of which usually have attributes and content. but for simplifying this problem, we needn't consider the attributes and content, i.e. only tags allowed. an element typically consists of two tags, a start tag and an end tag. the start tag consists of a name surrounded by angle brackets, like "<tag>"; the end tag consists of the same name surrounded by angle brackets, but with a slash preceding the name, like "</tag>". the element's content is empty or other sub-element (child) that appears between the start tag and the end tag. specially, no xml element that has the same tag in its direct sub-elements (children), i.e. all sibling elements have different tag names. the following is an valid example for xml documents. <thu> <team> <acrush></acrush> <jelly></jelly> <cooly></cooly> </team> <jiajia> <team> <ahyangyi></ahyangyi> <dragon></dragon> <cooly><amber></amber></cooly> </team> </jiajia> </thu> for identifying the elements in a document, we number the elements in according to the order that the start tags of the elements appear in the document. for instances, "thu" is numbered 1. the first "team" is numbered 2. "acrush" is numbered 3. "ahyangyi" is numbered 8. the problem of querying xml documents has been given much attention by researchers. now we are given a querying pattern of xml documents and a text of xml documents. the following is an valid example for pattern. <team><cooly></cooly></team> and we are requested to find all occurrences of the pattern in the text of xml documents. here, the pattern occurs at a particular text position if placing the pattern with root element at that text position leads to a situation in which each pattern element overlaps some text element with the same label. because the sibling elements have different labels, there is only one way to put the pattern into the text. input there are two parts in the input file. the first part is a valid xml documents with exactly one root element. the second part is a valid xml documents as querying pattern with exactly one root element. please ignore all whitespaces (unvisiable characters) in the input file, i.e. only consider the uppercase and lowercase letter and "/", "<", ">". assume xml documents is always strictly a rooted tree. the input file is less than 100kb. output output all the occurrences of pattern in a text of xml documents. the first line consists of an integer n that denotes the number of the occurrences. then the next n line, each line consists of an id number of an element that occurs the query pattern. please print them in increasing order. example input: <thu> <team> <acrush></acrush> <jelly></jelly> <cooly></cooly> </team> <jiajia> <team> <ahyangyi></ahyangyi> <dragon></dragon> <cooly><amber></amber></cooly> </team> </jiajia> </thu> <team><cooly></cooly></team> output: 2 2 7
the middle ages the capital of byteland was surrounded by stout walls to protect the citizens from intruders. the gates of the city were well guarded and the drawbridge was lifted for the night, and everyone felt pretty happy and secure. at least, for a while. with time the usual disadvantages of a walled city became apparent. as the population increased, crime flourished in the cramped living space. eventually it all became so bad that the mayor decided to intervene. some of the guards were reassigned from their usual occupation of reading newspapers in the guard posts near the gates, and told to start patrolling the city. many of the officers were rather unhappy about all this, especially after the first men to go on the beat returned with bleeding noses and bumps on their heads. sensing the low morale of the men, the captain of the guard, a bright young individual, decided to reinterpret the order he had received from the mayor. he decided that patrol officers would only go out in large groups and armed to the teeth, and would only move along a few carefully chosen streets from which they could see everything that was going on in the city without actually getting involved. the city is laid out on a regular grid, with each street running north-south or east-west from one end of the city to the other (as far as the walls allow). every point with integer coordinates is at an intersection of two streets, one leading north-south, the other east-west. the walls that surround the city form a simple polygon whose sides run directly alongside sections of some streets of the city. every street in the set of 'patrolled streets' chosen by the captain intersects with at least one other patrolled street. furthermore, if a point belongs to one of the streets of the city then it is visible from some point of one of the patrolled street (points see each other iff the line segment connecting them is a fragment of a street). finally, the set of patrolled streets chosen by the captain consists of the minimum possible number of streets. given a description of the capital of byteland, find out how many of its streets were actually patrolled by guards after the captain issued his order. input the first line of input contains t - the number of test cases. t test cases follow. for each test case, the first line contains a single integer n - the number of sections the city wall consists of (4 <= n <= 2000). the second line contains exactly n integers a1,...,an describing successive sections of wall (1<=|ai|<=100000). any two successive sections of wall are perpendicular to each other. the length of the i-th section is the absolute value of ai, while its direction is described by the sign of ai (positive means northbound or eastbound, negative - southbound or westbound when traversing the walls clockwise). output for each test case output a single integer k - the number of elements of the patrolled set of streets selected by the captain. example input: 1 14 +2 +2 +2 +2 -4 +2 +1 +2 -3 +2 -2 -8 +4 -2 output: 4
string s is called an (k,l)-repeat if s is obtained by concatenating k>=1 times some seed string t with length l>=1. for example, the string s = abaabaabaaba is a (4,3)-repeat with t = aba as its seed string. that is, the seed string t is 3 characters long, and the whole string s is obtained by repeating t 4 times. write a program for the following task: your program is given a long string u consisting of characters ‘a’ and/or ‘b’ as input. your program must find some (k,l)-repeat that occurs as substring within u with k as large as possible. for example, the input string u = babbabaabaabaabab contains the underlined (4,3)-repeat s starting at position 5. since u contains no other contiguous substring with more than 4 repeats, your program must output the maximum k. input in the first line of the input contains h- the number of test cases (h <= 20). h test cases follow. first line of each test cases is n - length of the input string (n <= 50000), the next n lines contain the input string, one character (either ‘a’ or ‘b’) per line, in order. output for each test cases, you should write exactly one interger k in a line - the repeat count that is maximized. example input: 1 17 b a b b a b a a b a a b a a b a b output: 4 since a (4, 3)-repeat is found starting at the 5th character of the input string.
is a country located in the archipelago of rectangular islands. the archipelago consists of 1<=n<=1000 islands. a fact that each island has a rectangular shape is very nice for bytelandian cartographers. bytelandian islands are rather small and none are very fertile, so each of (rectangular of course) pieces of cultivated land is under special control, simply speaking: ‘never enter there to save your life’. other areas are guaranteed to be free accessible for the people. the communication between islands is possible by ferries. on each island there is 0<=b<=10 terminals, from where crossings to another terminals on other islands are possible. it is known that total number of crossing connections is 0<=m<=100000. other infrastructure is practically unknown. specifically the only possible way of traveling through the island is to do it on foot. well, now we are close to a task you are requested to solve. john – one of the bytelandian citizens is working as a sales manager. simply speaking he is often requested to travel from one place to another, what he rather dislike and preferably (like other bytelandian people use to do) he would like to spent more time in one of the beach clubs playing puto (a kind of strategic game, very popular in byteland). please help him to find a way to spare his time. task find one of the fastest ways for john using ferries and foot paths on islands. assume that while walking john is always moving one bm (bytelandian unit of length) per bh (bytelandian unit of time). you can also assume that the ferry departures nearly immediately after john arrives the terminal, it will be enough to round up the walking time to the nearest integer. input in the first line t - the number of tests, then for each test: in next line n - the number of islands. description of each island is as follows: name w h [island dimensions] b - [number of terminals] [description of each terminal in a form:] name x y [name of a terminal and its coordinates] f [number of restricted areas f<20] xl, yd, xr, yu [coordinates of each restricted area, 0 <=xl < xr<=250 0<=yd < yu<=250.] all coordinates are nonnegative integers measured in bm according to upper left corner of an island. you can assume that any two restricted areas are disjoint. after the description of all islands all ferry connections are given (each connection is bi-directional). m [number of connections] [description of each connection] nb1 nw1 nb2 nw2 time [name of a first terminal, its island, the second respectively and communiaction time] ... [description follows] ... nbs nws nbc nwc [start and goal terminal for john] output for each test describe the shortest route for john from terminal nbs on nws island to terminal nbc on nwc island in the following format: case nr y [nr - test number] t [travel time in bh] nbs nws ... [consecutive terminals] ... nbc nwc [empty line] [consecutive tests] if two consecutive terminals are located on the same island and john must take some walk you must give all middle point like in an example. example input: 1 3 w1 8 7 2 lindos 4 0 kamejros 4 7 3 2 1 6 2 2 3 6 4 2 5 6 6 w2 14 12 2 malia 14 1 knossos 1 12 5 2 6 10 10 11 1 12 6 8 1 10 5 11 7 12 9 3 2 5 4 w3 1 1 1 korkyra 0 0 0 2 kamejros w1 knossos w2 100 malia w2 korkyra w3 100 korkyra w3 lindos w1 an example of a correct answer: output: case 1 y 230 korkyra w3 malia w2 12 6 11 7 10 10 knossos w2 kamejros w1 2 6 2 1 lindos w1
task is to calculate the cube root of a given positive integer. we can not remember why exactly we need this, but it has something in common with a princess, a young peasant, kissing and half of a kingdom (a huge one, we can assure you). write a program to solve this crucial task. input the input starts with a line containing a single integer t <= 20, the number of test cases. t test cases follow. the next lines consist of large positive integers of up to 150 decimal digits. each number is on its own separate line of the input file. the input file may contain empty lines. numbers can be preceded or followed by whitespaces but no line exceeds 255 characters. output for each number in the input file your program should output a line consisting of two values separated by single space. the second value is the cube root of the given number, truncated (not rounded!) after the 10th decimal place. first value is a checksum of all printed digits of the cube root, calculated as the sum of the printed digits modulo 10. example input: 5 1 8 1000 2 33076161 output: 1 1.0000000000 2 2.0000000000 1 10.0000000000 0 1.2599210498 6 321.0000000000
this problem you have to find the square root for given number. you may assume that such a number exist and it will be always an integer. solutions to this problem can be submitted in c, c++, pascal, algol, fortran, ada, ocaml, prolog, whitespace, brainf**k and intercal only. input t - the number of test cases [t <= 50] then t positive numbers follow, each of them have up to 800 digits in decimal representation. output output must contain exactly t numbers equal to the square root for given numbers. see sample input/output for details. example input: 3 36 81 226576 output: 6 9 476
a student of computer science, is very keen on crossâ­country running, and she participates in races organised every saturday in a big park. each of the participants obtains a route card, which specifies a sequence of checkpoints, which they need to visit in the given order. agness is a very atractive girl, and a number of male runners have asked her for a date. she would like to choose one of them during the race. thus she invited all her admirers to the park on saturday and let the race decide. the winner would be the one, who scores the maximum number of points. agnes came up with the following rules: a runner scores one point if he meets agnes at the checkpoint, if a runner scored a point at the checkpoint, then he cannot get another point unless he and agnes move to the next checkpoints specified in their cards. route specified by the card may cross the same checkpoint more than once, each competitor must strictly follow race instructions written on his card. between two consecutive meetings, the girl and the competitors may visit any number of checkpoints. the boys will be really doing their best, so you may assume, that each of them will be able to visit any number of checkpoints whilst agnes runs between two consecutive ones on her route. task write a program which for each data set from a sequence of several data sets: reads in the contents of agnes' race card and contents of race cards presented to tom, computes the greatest number of times tom is able to meet agnes during the race, writes it to output. input there is one integer d in the first line of the input file, 1 <= d <= 10. this is the number of data sets. the data sets follow. each data set consists of a number of lines, with the first one specifying the route in agnes' race card. consecutive lines contain routes on cards presented to tom. at least one route is presented to tom. the route is given as a sequence of integers from interval [1, 1000] separated by single spaces. number 0 stands for the end of the route, though when it is placed at the beginning of the line it means the end of data set. there are at least two and at most 2000 checkpoints in a race card. output the i-th line of the output file should contain one integer. that integer should equal the greatest number of times tom is able to meet with agnes for race cards given in the i-th data set. example sample input: 3 1 2 3 4 5 6 7 8 9 0 1 3 8 2 0 2 5 7 8 9 0 1 1 1 1 1 1 2 3 0 1 3 1 3 5 7 8 9 3 4 0 1 2 35 0 0 1 3 5 7 0 3 7 5 1 0 0 1 2 1 1 0 1 1 1 0 0 sample output: 6 2 3
from the hanging gardens the babylonians (around 3000-539 b.c.) built the tower of babylon as well. the tower was meant to reach the sky, but the project failed because of a confusion of language imposed from much higher above. for the 2638th anniversary a model of the tower will be rebuilt. n different types of blocks are available. each one of them may be duplicated as many times as you like. each type has a height y, a width x and a depth z. the blocks are to be stacked one upon eachother so that the resulting tower is as high as possible. of course the blocks can be rotated as desired before stacking. however for reasons of stability a block can only be stacked upon another if both of its baselines are shorter. input the number of types of blocks n is located in the first line of each test case. on the subsequent n lines the height yi, the width xi and the depth zi of each type of blocks are given. there are never more than 30 different types available. there are many test cases, which come one by one. input terminates with n = 0. edited: you can assume that max(xi, yi, zi) <= 2500. output for each test case your program should output one line with the height of the highest possible tower. example sample input: 5 31 41 59 26 53 58 97 93 23 84 62 64 33 83 27 1 1 1 1 0 sample output: 342 1
some countries building highways takes a lot of time... maybe that's because there are many possibilities to construct a network of highways and engineers can't make up their minds which one to choose. suppose we have a list of cities that can be connected directly. your task is to count how many ways there are to build such a network that between every two cities there exists exactly one path. two networks differ if there are two cities that are connected directly in the first case and aren't in the second case. at most one highway connects two cities. no highway connects a city to itself. highways are two-way. input the input begins with the integer t, the number of test cases (equal to about 1000). then t test cases follow. the first line of each test case contains two integers, the number of cities (1<=n<=12) and the number of direct connections between them. each next line contains two integers a and b, which are numbers of cities that can be connected. cities are numbered from 1 to n. consecutive test cases are separated with one blank line. output the number of ways to build the network, for every test case in a separate line. assume that when there is only one city, the answer should be 1. the answer will fit in a signed 64-bit integer. example sample input: 4 4 5 3 4 4 2 2 3 1 2 1 3 2 1 2 1 1 0 3 3 1 2 2 3 3 1 sample output: 8 1 1 3
a billiard table with horizontal side a inches and vertical side b inches, a ball is launched from the middle of the table. after s > 0 seconds the ball returns to the point from which it was launched, after having made m bounces off the vertical sides and n bounces off the horizontal sides of the table. find the launching angle a (measured from the horizontal), which will be between 0 and 90 degrees inclusive, and the initial velocity of the ball. assume that the collisions with a side are elastic (no energy loss), and thus the velocity component of the ball parallel to each side remains unchanged. also, assume the ball has a radius of zero. remember that, unlike pool tables, billiard tables have no pockets. input input consists of a sequence of lines, each containing five nonnegative integers separated by whitespace. the five numbers are: a, b, s, m, and n, respectively. all numbers are positive integers not greater than 10000. input is terminated by a line containing five zeroes. output for each input line except the last, output a line containing two real numbers (accurate to two decimal places) separated by a single space. the first number is the measure of the angle a in degrees and the second is the velocity of the ball measured in inches per second, according to the description above. example input: 100 100 1 1 1 200 100 5 3 4 201 132 48 1900 156 0 0 0 0 0 output: 45.00 141.42 33.69 144.22 3.09 7967.81
an integer sequence containing n elements (numbered from 1 to n), your task is to find the minimum value m so that we can find k + 1 integers 0 = p(0) < p(1) < p(2) < ... < p(k-1) < p(k) = n, such that for any i from 0 to k - 1, the sum of elements from postition p(i)+1 to postition p(i+1) is not greater than m. input the first line of input contains the number of test cases ntest (1 <= ntest <= 10). each test case contains: the first line contains n, k. (1 <= k <= n <= 15000) each of the next n lines contains an integer of the sequence with value range from -30000 to 30000. output for each test case write the minimum number m in a separate line. example input: 1 9 4 1 1 1 3 2 2 1 3 1 output: 5
upon a time in a kingdom far far away, the royal treasury started getting emptier and emptier. the king decided to change the situation and he invented a new system of cooperation with in the office of the royal treasurer. the clerks of the office are supposed to form pairs (in order to avoid being bribed) in such away that each pair is formed by a clerk and his/her direct subordinate. your task is to compute, given the structure of the office of the treasurer, the maximum number of pairs that can be formed this way and in how many different ways this is possible. the office of the treasurer is led by george skinflint. each clerk has zero, one or more subordinates and is a subordinate of a single clerk (except for george skinflint who is responsible only to the king himself). the number of clerks does not exceed 1000. your task is to compute the maximum number of pairs that can be formed by clerks in such a way that every pair is formed by a clerk and his/her direct subordinate. in addition, you should also compute the number of ways such pairs can be formed. note that some clerks need not be contained in a pair. input the input contains multiple testcases. the first line of each testcase contains a single number n that represents the number of clerks 1 <= n <= 1000. the clerks are assigned unique id numbers from the range between 1 and n. the id number of the treasurer (skinflint) is 1. each of the following n lines corresponds to one of the clerks: it contains his/her id number, the number k of his/her subordinates, 0 <= k <= 999, and the id numbers of his/her k subordinates separated by single spaces. you can assume that the line corresponding to a clerk never appears before the line corresponding to his/her supervisor. output the output for each testcase should consist of two lines. the first line of the output should contain a single number that represents the maximum number m of pairs that the clerks can form. the second line should contain the number of different ways in which the clerks can form m pairs obeying the rules given by the king. example input: 7 1 3 2 4 7 2 1 3 4 1 6 3 0 7 1 5 5 0 6 0 output: 3 4
gordian dance is a traditional bytelandian dance performed by two pairs of dancers. at the beginning the dancers are standing in the corners of the square abcd, forming two pairs: a-b and c-d. every pair is holding an outstretched string. so in the starting position both strings are stretched horizontally and parallel. the dance consists of a series of moves. there are two kinds of moves: (s) the dancers standing at points b and c swap positions (without releasing their strings) in such a way that the dancer standing at b raises the hand in which he is holding the string and, when going to point c, lets the dancer going from c to b pass in front of him, under his arm. (r) all dancers make a turn by 90 degrees clockwise without releasing their strings. this means that the dancer from a goes to b, the dancer from b goes to c, the dancer from c goes to d, and the dancer from d goes to a. during the dance the strings tangle with each other, but in the end they should be untangled and stretched horizontally and parallel. the dancers do not have to occupy the same spots as in the begining. the dance requires a lot of experience, because the strings can be extremely tangled during the dance. the sequence of moves after which they are no longer tangled and are stretched horizontally and parallel can be difficult to guess. your program should help beginner dancers end a dance. you are to determine the minimal number of mover required to end the dance given a sequence of moves already performed. illustration for example after the sequence ss we get the following configuration. the shortest sequence of moves required to end the dance is of length 5: rsrss. task write a program which reads from standard input the moves made in a dance, finds the minimal number of moves required to untangle the strings and stretch them horizontally and parallel (the dancers don't have to be in their starting spots). writes the outcome to standard output. input ten test cases (given one under another, you have to process all!). the first line of each test case consists of one integer n equal to the nmber of moves already made, 0<=n<=1000000. the second line of each test case consists of one word of length n, made up of letters s and/or r. output for every testcase your program should write to standard output only one line with one integer number: the minimal number of moves required to untangle the strings and stretch them horizontally and parallel. example input: 2 ss [and 9 test cases more] output: 5 [and 9 test cases more] warning: large input/output data, be careful with certain languages
mary, the well-known astronaut, had sent robot number 1 to mars finally. robot number 1 was so smart that he could make one robot per second. assume the time robot number 1 arrived was second 1. at second i, robot number 1 made a new robot: robot number i. (i>=2) the new robots started work as soon as he was produced successfully. robot number m only had a rest at second t, where t is a multiple of m. for example, robot number 3 worked at second 4, 5, 7, 8, ... and had a rest at second 6, 9, ... when a robot was having a rest, he could send his own informations to the newly produced robot. for example, when robot number 6 was produced successfully, robot number 2 and robot number 3 are having a rest, so robot number 6 would get information from robot number 2 and number 3. we call robot number 2 and number 3 are teachers of robot number 6. we call two robots are independent if each of them wasn't a teacher of the other one and they had no common teachers. please note that robot number 1 was independent to any other robots and wasn't a teacher of any other robots, since only robot number 1 could make robots. the good number of robot number m is the number of robots who was produced earlier than number m and independent to number m. here are some examples: the good number of robot number 1 is 0. the good number of robot number 2 is 1. number 1 was that robot. the good number of robot number 6 is 2. number 1 and number 5 were those robots. number 2 and number 3 were his teachers. number 4 and him had a common teacher: number 2. the robots had 3 kinds of occupations. to robot number m: if m can be written as the multiple of an even number of distinct odd primes, he was a businessman. if m can be written as the multiple of an odd number(1 included) of distinct odd primes, he was a hacker. all other robots were doctors. now blue mary was interesting to robot number m. she wants to know the sum of good numbers of all businessmen, hackers and doctors among robot number m and his teachers. she comes up with the answer quickly, and so can you. blue mary is so kind that she gives you the prime divisors of m and you can only tell her the answers modudo 10000. input the very first line contains a single integer t, the number of test cases.t blocks follow. for each block, the first line contains a single integer k.k lines follow, each contains two integers pi and ai separated by a single space. m = p1a1 * p2a2 * p3a3 * ... * pkak. you can assume that: all pi are distinct primes and are less than 10,000. p1 < p2 < p3 < ... n. all ai are positive and no more than 1,000,000. 1 <= k <= 1000. output for each test case, output 3 lines. the first line contains a single integer denotes to the sum of good numbers of all businessmen among robot number m and his teachers modudo 10000. the second line contains a single integer denotes to the sum of good numbers of all hackers among robot number m and his teachers modudo 10000. the third line contains a single integer denotes to the sum of good numbers of all doctors among robot number m and his teachers modudo 10000. example input: 1 3 2 1 3 2 5 1 output: 8 6 75 hints in the sample input, m=21*32*51=90. robot number 90 has 10 teachers. among robot number 90 and his teachers, robot number 15 is a businessman; number 3 and number 5 are hackers; all others are doctors, their numbers are 2, 6, 9, 10, 18, 30, 45, 90.
is a game played on an 8x8 chessboard. the rows and columns of the chessboard are numbered from 1 to 8, from the top to the bottom and from left to right respectively. there are four identical pieces on the board. in one move it is allowed to: move a piece to an empty neighboring field (up, down, left or right), jump over one neighboring piece to an empty field (up, down, left or right). there are 4 moves allowed for each piece in the configuration shown above. as an example let's consider a piece placed in the row 4, column 4. it can be moved one row up, two rows down, one column left or two columns right. task write a program that: reads two chessboard configurations from the standard input, verifies whether the second one is reachable from the first one in at most 8 moves, writes the result to the standard output. input the input begins with the integer t, the number of test cases. then t test cases follow. for each test case, each of two input lines contains 8 integers a1, a2, ..., a8 separated by single spaces and describes one configuration of pieces on the chessboard. integers a2j-1 and a2j (1 <= j <= 4) describe the position of one piece - the row number and the column number respectively. output for each test case the output should contain one word for each test case - 'yes' if a configuration described in the second input line is reachable from the configuration described in the first input line in at most 8 moves, or one word 'no' otherwise. example sample input: 1 4 4 4 5 5 4 6 5 2 4 3 3 3 6 4 6 sample output: yes
you know the famous game the king of fighters? if the answer is yes, i'm sure you know the three black group: chris, shermie and yashiro. today chris is invited to one of his friends' home to play the king of fighters.blue mary is now at chris' home, she knows where shermie's and yashiro's home is, but she doesn't know where chris actually is.so she decides that: if yashiro's home is nearer than shermie's, she will go to yashiro's home first, if she doesn't find chris, she will then go to shermie's, and vice versa. the map of the city is strange. each of the houses is assigned to a unique number in the range[1,n], where n is the number of houses. between some pairs of houses there are some roads. there exists one and only one path from any house to any other house. she will go along the only path between the two houses. unfortunately, you don't know where chris' home actually is, and the same as yashiro's and shermie's. now you are interesting in the maximum time from the time when blue mary starts from chris' home to the time when blue mary finds chris in the worst case. input the number of test cases t is given in the very first line.t blocks follow. for each test case, the first line contains 2 space-separated integers n(3<=n<=200000) and m, which denotes the number of houses and the number of roads in the city.m lines follow, each contains 3 space-separated integers x,y,z(1<=x,y<=n,1<=z<=109).it tells us there exist a road between house no.x and house no.y, and to go from x to y or from y to x along this road will take z minutes.no two roads are repeated. output for each test case you should output a single line, which contains a single integer - the maximum time measured in minutes. example input: 1 4 3 1 2 1 2 3 1 3 4 1 output 4 warning: large input/output data, be careful with certain languages
are given a convex polygon on cartesian coordinate system. it has projections on x and y-axis. you can arbitrary rotate this polygon. what minimum and maximum sum of projections can you achieve? input first line contains one integer number n (3 ≤ n ≤ 100) - number of polygon's vertices. following n lines contain vertex coordinates xi and yi. all numbers are integers. vertices are given in clockwise or anticlockwise direction. no two vertices coincide. no three consecutive vertices lie on the same line. all coordinates do not exceed 10000 by absolute value. output write minimum and maximum value of sum of the polygon's projections. separate them by a space. your answer should not differ with the correct one more than 10-6. example input: 4 0 0 0 1 1 1 1 0 output: 2 2.828427124
poker, you have 5 cards. there are 10 kinds of poker hands (from highest to lowest): royal flush - ace, king, queen, jack and ten, all in the same suit. straight flush - five cards of the same suit in sequence, such as 10, 9, 8, 7, 6 of clubs; ace can be counted both as the highest card or as the lowest card - a, 2, 3, 4, 5 of hearts is a straight flush. but 4, 3, 2, a, k of hearts is not a straight flush - it's just a flush. four of a kind - four cards of the same rank, such as four kings. full house - three cards of one rank plus two cards of another rank. flush - five cards of the same suit (but not a straight flush). straight - five cards in order - just like the straight flush, but mixed suits. three of a kind - three cards of one rank and two other cards. two pairs - two cards of one rank, two cards of another rank, and one more card. pair - two cards of the same rank. high card - none of the above. write a program that will help you play poker by telling you what kind of hand you have. input the first line of input contains the number of test cases (no more than 20). each test case consists of one line - five space separated cards. each card is represented by a two-letter (or digit) word. the first character is the rank (a, k, q, j, t, 9, 8, 7, 6, 5, 4, 3 or 2), the second character is the suit (s, h, d, c standing for spades, hearts, diamonds and clubs). the cards can be in any order (but they will not repeat). output for each test case output one line describing the type of a hand, exactly like in the list above. example input: 3 ah kh qh th jh kh 5s 3c 5c 7d qh qd 2s qc 2c output: royal flush pair full house
are n rectangles drawn on the plane. each rectangle has sides parallel to the coordinate axes and integer coordinates of vertices. we define a block as follows: each rectangle is a block, if two distinct blocks have a common segment then they form the new block otherwise we say that these blocks are separate. examples the rectangles in figure 1 form two separate blocks. figure 1 the rectangles in figure 2 form a single block figure 2 task write a program that for each test case: reads the number of rectangles and coordinates of their vertices; finds the number of separate blocks formed by the rectangles; writes the result to the standard output. input the number of test cases t is in the first line of input, then t test cases follow separated by an empty line. in the first line of a test case there is an integer n, 1 <= n <= 7000, which is the number of rectangles. in the following n lines there are coordinates of rectangles. each rectangle is described by four numbers: coordinates x, y of the bottom-left vertex and coordinates x, y of the top-right vertex. all these coordinates are non-negative integers not greater than 10000. output for each test case you should output one line with the number of separate blocks formed by the given rectangles. example sample input: 1 9 0 3 2 6 4 5 5 7 4 2 6 4 2 0 3 2 5 3 6 4 3 2 5 3 1 4 4 7 0 0 1 4 0 0 4 1 sample output: 2
millman hates us, and worse, characterizes us as liars. we don’t care if he means it or not, but we (more professional that him!) planned to give the lower and upper bound on the number of liars in the class (so that you know what happens the next time he scolds us! ). to start with we took a survey of all students in the class. each student gave a reply about every student saying whether that student is a liar or not. these answers are in the form of a matrix a, where a[i][j] represents the reply given by the i-th student about the j-th student. if that character is ‘l’ – it means he/she is a liar; if it’s ‘t’ – then it means that, that student is a truth speaker. we take the following as our definition of the terms truth-speaker, and liar: truth-speaker (‘t’): all his/her replies are true. liar (‘l’) : (s)he has made at least one false reply. input t – the number of test cases; for each test case : n – total number of students in the class matrix a of nxn characters, without space separation; output for i-th test case output one line of the form “class room#i contains at least a and at most b liars”, where a and b are the lower and the upper bounds on the number of liars respectively. if there is a paradoxical class room, instead of the above line, print “class room#i is paradoxical”. constraints: t<=50; our class rooms contain at most 70 students. example sample input: 4 2 ll tt 3 ttt ttt ttt 4 tlll ltll lltl lllt 5 tltlt ttttt lltll lllll tltlt sample output: class room#1 is paradoxical class room#2 contains at least 0 and at most 3 liars class room#3 contains at least 3 and at most 4 liars class room#4 contains at least 4 and at most 4 liars here a paradox occurs if a person can't be classified as a liar or a truth-speaker.
input consists of exactly 5 test cases in the following format: input n a0 b0 l0 a1 b1 l1 [3<=n<=1000,1<=a0<=b0<=l0<=n,1<=a1<=b1<=l1<=n] output exactly 5 lines,each contains: a) a n-character sequence (we name it s) consisting of only characters '0' and '1' and no extra whitespaces, which satisfy the following conditions: the number of '0' in any consecutive subsequence of s whose length is l0 is not more than b0 and not less than a0. the number of '1' in any consecutive subsequence of s whose length is l1 is not more than b1 and not less than a1. or b)a single number -1,if the sequence which satisfies the conditions above doesn't exist. example input: 6 1 2 3 1 1 2 [and 4 test cases more] output: 010101 [and 4 test cases more]
on a graph" is a game that is played on a board on which an undirected graph is drawn. the graph is complete and has all loops, i.e. for any two locations there is exactly one arrow between them. the arrows are coloured. there are three players, and each of them has a piece. at the beginning of the game, the three pieces are in fixed locations on the graph. in turn, the players may do a move. a move consists of moving one's own piece along an arrow to a new location on the board. the following constraint is imposed on this: the piece may only be moved along arrows of the same colour as the arrow between the two opponents' pieces. in the sixties ("make love not war") a one-person variant of the game emerged. in this variant one person moves all the three pieces, not necessarily one after the other, but of course only one at a time. goal of this game is to get all pieces onto the same location, using as few moves as possible. find out the smallest number of moves that is necessary to get all three pieces onto the same location, for a given board layout and starting positions. input the input file contains several test cases. each test case starts with the number n. input is terminated by n=0. otherwise, 1<=n<=50. then follow three integers p1, p2, p3 with 1<=pi<=n denoting the starting locations of the game pieces. the colours of the arrows are given next as a nã—n matrix m of whitespace-separated lower-case letters. the element mij denotes the colour of the arrow between the locations i and j. since the graph is undirected, you can assume the matrix to be symmetrical. output for each test case output on a single line the minimum number of moves required to get all three pieces onto the same location, or the word "impossible" if that is not possible for the given board and starting locations. example input: 3 1 2 3 r b r b b b r b r 2 1 2 2 y g g y 0 output: 2 impossible
the given numbers. input n [the number of multiplications <= 101] l1 l2 [numbers to multiply (at most 300000 decimal digits each)] text grouped in [ ] does not appear in the input file. output the results of multiplications. example input: 5 4 2 123 43 324 342 0 12 9999 12345 output: 8 5289 110808 0 123437655 warning: large input/output data, be careful with certain languages
is a puzzle for two persons, let's say alice and bob. alice draws an n-vertex convex polygon and numbers its vertices with integers 1, 2, ... , n in an arbitrary way. then she draws a number of noncrossing diagonals (the vertices of the polygon are not considered to be crossing points). she informs bob about the sides and the diagonals of the polygon but not telling him which are which. each side and diagonal is specified by its ends. bob has to guess the order of the vertices on the border of the polygon. help him solve the puzzle. if n = 4 and (1,3), (4,2), (1,2), (4,1), (2,3) are the ends of four sides and one diagonal then the order of the vertices on the border of this polygon is 1, 3, 2, 4 (with the accuracy to shifting and reversing). task write a program that: reads the description of sides and diagonals given to bob by alice, computes the order of the vertices on the border of the polygon, writes the result. input the first line of the input contains exactly one positive integer d equal to the number of data sets, 1 <= d <= 20. the data sets follow. each data set consists of exactly two consecutive lines. the first of those lines contains exactly two integers n and m separated by a single space, 3 <= n <= 10 000, 0 <= m <= n-3. integer n is the number of vertices of a polygon and integer m is the number of its diagonals, respectively. the second of those lines contains exactly 2(m+n) integers separated by single spaces. those are ends of all sides and some diagonals of the polygon. integers aj, bj on positions 2j-1 and 2j, 1 <= j < = m+n, 1 < = aj <= n, 1 < = bj < = n, aj <> bj, specify ends of a side or a diagonal. the sides and the diagonals can be given in an arbitrary order. there are no duplicates. alice does not cheat, i.e. the puzzle always has a solution. output line i, 1 <= i < = d, should contain a sequence of n integers separated by single spaces - a permutation of 1, 2, ... , n, i.e. the numbers of subsequent vertices on the border of the polygon from the i-th data set, the sequence should always start from 1 and its second element should be the smaller vertex of the two border neighbours of vertex 1. example sample input: 1 4 1 1 3 4 2 1 2 4 1 2 3 sample output: 1 3 2 4 warning: large input/output data, be careful with certain languages
the equation x2 - ny2 = 1 where n is some integer. find the smallest strictly positive integer solutions (x, y) for a given n. input the number of test cases t (around 30), followed by a list of t values of n (2 ≤ n ≤ 1000). you can assume that the equation can be solved for all values of n in the input set. output for every test case, the values of x and y separated by a space character, on separate lines. example input: 3 2 6 61 output: 3 2 5 2 1766319049 226153980
separatist leader general grievous, the second in command of count dooku, comes to know that chancellor palpatine’s convoy, escorted by obi-wan and anakin, is scheduled to depart from kashyyyk in the middle rim of the universe to alderaan. general grievous is aware that there are multiple paths going via different sets of planets from kashyyyk to alderaan. to make his abduction attempt successful, he decides to send his robots to the planet closest to kashyyyk, other than itself, which lies on all the possible paths from kashyyyk to alderaan. since you have pledged your allegiance to count dooku, you need to help him identify this planet. the planetary map which is given to you for this purpose consists of a set of one-way connections between planets. you also know that a pair of planets can have at most one connection between them in each direction and there is always a path from kashyyyk to alderaan. note: in the given example, the planet with index 5 is the required planet. input description the first line of the input is a positive integer t ≤ 20, which is the number of test cases. the descriptions of the test cases follow one after the other. the first line of each test case is a pair of positive integers n, m (separated by a single space). 2 ≤ n ≤ 30011 is the number of planets and m ≤ 100011 is the number of connections between planets. the planets are indexed with integers from 1 to n and the indices of kashyyyk and alderaan are 1, n respectively. each of the next m lines contains two integers p,q, meaning that there is a one-way connection from planet p to planet q. output description the output should contain t lines. the ith line corresponds to the ith test case. the output for the ith test case should be the index of the planet with the required property. example input 2 3 2 1 3 3 2 4 4 1 3 3 4 1 2 2 4 output 3 4
antique comedians of malidinesia play an interesting comedy where many animals occur. because they want their plays to be as true as possible, a specialist studies the behaviour of various animals. recently, he is interested in a binary dynamic ecological system hares-foxes (shf). as a part of this project, you are asked to design and implement intelligent automatic target evaluation simulator (iates) for this system. the behaviour of the shf follows so called standard model, described by the following set of difference equations. hy+1 = a.hy - b.fy fy+1 = c.fy + d.hy where hy resp. fy represent the difference of the number of hares resp. foxes in year y and the reference count determined at the beginning of the experiment. the units of hy and fy are unknown. therefore, hy and fy are to be treated as real numbers. your task is to write a program to determine the long term evolution of shf. input the input consists of n cases (equal to about 5000). the first line of the input contains only positive integer n. then follow the cases. each case consists of six real numbers a, b, c, d, h1998 and f1998, written in this order on three lines, two numbers per line, separated by one or more spaces. the numbers are given in the classical format, i.e. optional sign, sequence of digits, optional dot and optional sequence of digits. the text form of a number does not exceed 10 characters. each case is followed by one empty line. output for each case, print one of the following sentences: 'ecological balance will develop.' - if after sufficiently long time the population of both hares and foxes approaches the reference count with an arbitrary a priori given precision, i.e. lim hy=0 and lim fy=0. 'hares will die out while foxes will overgrow.' - if after sufficiently long time the population of hares resp. foxes falls under resp. exceeds any a priori given threshold, i.e. lim hy=-infinity and lim fy=+infinity. 'hares will overgrow while foxes will die out.' - if after sufficiently long time the population of foxes resp. hares falls under resp. exceeds any a priori given threshold, i.e. lim hy=+infinity and lim fy=-infinity. 'both hares and foxes will die out.' - if after sufficiently long time the population of both hares and foxes falls under any a priori given threshold, i.e. lim hy=-infinity and lim fy=-infinity. 'both hares and foxes will overgrow.' - if after sufficiently long time the population of both hares and foxes exceeds any a priori given threshold, i.e. lim hy=+infinity and lim fy=+infinity. 'chaos will develop.' - if none of the above mentioned description fits. example sample input: 2 2 0.5 0.5 0.6 2 3 0.1 1 2 0.1 1 1 sample output: both hares and foxes will overgrow. hares will die out while foxes will overgrow.
polska english version for each index of n element permutation print m subsequent permutations (in separate lines) in lexicographical order starting from the one pointed by index. between outputs of subsequent tests there should be an empty line. next permutation to the last one is the first one. input t [number of tests <= 1000] n index m [2 <= n <= 100 - number of elements in permutation, 0 <= index < n! - index of the first permutation, 1 <= m <= 100 - how many permutations to print] output p1 p2 ... p(n-1) pn [permutations] p1 p2 ... pn p(n-1) p1 p2 ... p(n-1) pn [permutations] p1 p2 ... pn p(n-1) example input: 12 2 1 1 3 3 3 4 16 3 4 5 9 2 1 1 2 1 1 3 5 1 5 91 7 2 1 1 5 100 7 3 5 1 2 1 1 output: 2 1 2 3 1 3 1 2 3 2 1 3 4 1 2 3 4 2 1 4 1 2 3 1 4 3 2 2 1 3 4 2 1 4 3 2 3 1 4 2 3 4 1 2 4 1 3 2 4 3 1 3 1 2 4 3 1 4 2 2 1 2 1 3 2 1 4 5 1 3 2 4 5 2 1 3 4 5 2 3 1 4 5 3 1 2 4 5 3 2 1 5 1 2 3 4 5 1 2 4 3 2 1 5 1 4 2 3 5 1 4 3 2 5 2 1 3 4 5 2 1 4 3 5 2 3 1 4 5 2 3 4 1 5 2 4 1 3 3 2 1 2 1
fashion show rates participants according to their level of hotness. two different fashion shows were organized, one for men and the other for women. a date for the third is yet to be decided ;) . now the results of both fashion shows are out. the participants of both the fashion shows have decided to date each other, but as usual they have difficuly in choosing their partners. the maximum match dating serive (mmds) comes to their rescue and matches them in such a way that that maximizes the hotness bonds for all couples. if a man has been rated at hotness level x and a women at hotness level y, the value of their hotness bond is x*y. both fashion shows contain n participants each. mmds has done its job and your job is to find the sum of hotness bonds for all the couples that mmds has proposed. input the first line of the input contains an integer t, the number of test cases. t test cases follow. each test case consists of 3 lines: the first line contains a single integer n (1 <= n <= 1000). the second line contains n integers separated by single spaces denoting the hotness levels of the men. the third line contains n integers separated by single spaces denoting the hotness levels of the women. all hotness ratings are on a scale of 0 to 10. output for each test case output a single line containing a single integer denoting the sum of the hotness bonds for all pairs that mmds has proposed. example input: 2 2 1 1 3 2 3 2 3 2 1 3 2 output: 5 15
acrush and jelly are playing a game ! let take a look at its rule: you are given a tree. two players take turns cutting edges on a tree. some nodes is on the "ground". when a player cuts an edge, all the edges that are no longer connected to the ground disappear. the player who can not take a move loses. acrush plays first. both of them are very good players. if you know state of the tree they are playing with, can you guess who will win? node 4 is on the ground. input input consists of multiple test-cases. the first line contains one integer t - number of cases (0 < t <= 20). for each case, the input format is following. the first line contains one integer n (1 <= n <= 100000). the next line n integers s[i] (1 or 0). if s[i] is 1, the i-th node is on the ground. if s[i] is 0, the i-th node is not on the ground. each line of the following n - 1 lines contains two integers u, v. they denote there is an edge between node u and node v (1 <= u,v <= n). there is no blank line after each case. output for each case, output who will win the game. if acrush wins, output 1; otherwise, output 0 (jelly wins). there is no blank line after each case. example input: 1 4 0 0 0 1 1 2 2 3 2 4 output: 1
game of pearls is to use the following 12 kinds of pearl designs each one and only one time to make the big pearl design.the pearl designs can be rotated and turned over arbitrarily. see the pictures below. the empty grids a sample big pearl design a sample big pearl design used characters instead of colors part a part b part c part d part e part f part g part h part i part j part k part l input ten test cases(given one after another,you have to process all!), each contains a big design, 'a'-'l' denote the filled grids, '.' denotes the empty grids,see the example. you can assume that the pearl designs used are completely put into the empty grids. output a big design which has no grids that haven't been filled and each pearl design is used one and only one time in it,or 'no solution'(without quotes) if there's no solution.if there are multiple solutions,output any. example input: . .. ... .... ..... .....c ...ccc. eeehh... e.hhh.... e......... [and 9 test cases more] output: b bk bkk bjkk jjjdd gjgddc gggccci eeehhiia elhhhiaaf elllliffff [and 9 test cases more]
and larry have devised a way of encrypting messages. they first decide secretly on the number of columns and write the message (letters only) down the columns, padding with extra random letters so as to make a rectangular array of letters. for example, if the message is “there’s no place like home on a snowy night” and there are five columns, mo would write down t o i o y h p k n n e l e a i r a h s g e c o n h s e m o t n l e w x note that mo includes only letters and writes them all in lower case. in this example, mo used the character ‘x’ to pad the message out to make a rectangle, although he could have used any letter. mo then sends the message to larry by writing the letters in each row, alternating left-to-right and right-to-left. so, the above would be encrypted as toioynnkpheleaigshareconhtomesnlewx your job is to recover for larry the original message (along with any extra padding letters) from the encrypted one. input there will be multiple input sets. input for each set will consist of two lines. the first line will contain an integer in the range 2...20 indicating the number of columns used. the next line is a string of up to 200 lower case letters. the last input set is followed by a line containing a single 0, indicating end of input. output each input set should generate one line of output, giving the original plaintext message, with no spaces. example input: 5 toioynnkpheleaigshareconhtomesnlewx 3 ttyohhieneesiaabss 0 output: theresnoplacelikehomeonasnowynightx thisistheeasyoneab
probably know those quizzes in sunday magazines: given the sequence 1, 2, 3, 4, 5, what is the next number? sometimes it is very easy to answer, sometimes it could be pretty hard. because these "sequence problems" are very popular, acm wants to implement them into the "free time" section of their new wap portal. acm programmers have noticed that some of the quizzes can be solved by describing the sequence by polynomials. for example, the sequence 1, 2, 3, 4, 5 can be easily understood as a trivial polynomial. the next number is 6. but even more complex sequences, like 1, 2, 4, 7, 11, can be described by a polynomial. in this case, 1/2.n2-1/2.n+1 can be used. note that even if the members of the sequence are integers, polynomial coefficients may be any real numbers. polynomial is an expression in the following form: p(n) = ad.nd+ad-1.nd-1+...+a1.n+a0 if ad <> 0, the number d is called a degree of the polynomial. note that constant function p(n) = c can be considered as polynomial of degree 0, and the zero function p(n) = 0 is usually defined to have degree -1. input there is a single positive integer t on the first line of input (equal to about 5000). it stands for the number of test cases to follow. each test case consists of two lines. first line of each test case contains two integer numbers s and c separated by a single space, 1 <= s < 100, 1 <= c < 100, (s+c) <= 100. the first number, s, stands for the length of the given sequence, the second number, c is the amount of numbers you are to find to complete the sequence. the second line of each test case contains s integer numbers x1, x2, ... xs separated by a space. these numbers form the given sequence. the sequence can always be described by a polynomial p(n) such that for every i, xi = p(i). among these polynomials, we can find the polynomial pmin with the lowest possible degree. this polynomial should be used for completing the sequence. output for every test case, your program must print a single line containing c integer numbers, separated by a space. these numbers are the values completing the sequence according to the polynomial of the lowest possible degree. in other words, you are to print values pmin(s+1), pmin(s+2), .... pmin(s+c). it is guaranteed that the results pmin(s+i) will be non-negative and will fit into the standard integer type. example sample input: 4 6 3 1 2 3 4 5 6 8 2 1 2 4 7 11 16 22 29 10 2 1 1 1 1 1 1 1 1 1 2 1 10 3 sample output: 7 8 9 37 46 11 56 3 3 3 3 3 3 3 3 3 3 warning: large input/output data, be careful with certain languages
are to write a program to perform some operations on a given sequence.these operations are listed below: --------------------------------------------------------------------------------------------- | name | input format | function | --------------------------------------------------------------------------------------------- | modify | make-same i t c| modify all the t numbers from the ith number(included) to | | | | number c. | --------------------------------------------------------------------------------------------- | insert | insert i t s | insert t numbers after the ith number.s is a sequence of t | | | | numbers which should be inserted one-to-one. if i=0, you | | | | should insert s in the first of the sequence. | --------------------------------------------------------------------------------------------- | delete | delete i t | delete t numbers after the ith number(included). | --------------------------------------------------------------------------------------------- | reverse | reverse i t | reverse t numbers after the ith number(included). | --------------------------------------------------------------------------------------------- | get sum | get-sum i t | output the sum of t numbers after the ith number(included).| --------------------------------------------------------------------------------------------- | get maximum | max-sum | output the maximum partial sum in the sequence now. | | partial sum | | | --------------------------------------------------------------------------------------------- see the example. input the very first line contains a single integer t(t<=4), the number of test cases. t blocks follow. for each test case: the first line contains two integers n and m(m<=20000), the number of numbers in the sequence in the beginning and the number of operations. the second line contains n integers separated by spaces, the sequence in the beginning. next m lines, each contains an operation listed above. you can assume that for each test case: no invalid operation is in the input. number of numbers in the sequence is no more than 500000 and not less than 1 at any time. all the numbers in the sequence is in range[-1000,1000] at any time. the total number of numbers inserted will be not more than 4,000,000.the input is no more than 20mb. output for each get sum and get maximum partial sum operation, you should write the answer to the output, one per line. example input: 1 9 8 2 -6 3 5 1 -5 -3 6 3 get-sum 5 4 max-sum insert 8 3 -5 7 2 delete 12 1 make-same 3 3 2 reverse 3 6 get-sum 5 4 max-sum output: -1 10 1 10 hints: after the 3rd op., the sequence is 2 -6 3 5 1 -5 -3 6 -5 7 2 3 after the 4th op., the sequence is 2 -6 3 5 1 -5 -3 6 -5 7 2 after the 5th op., the sequence is 2 -6 2 2 2 -5 -3 6 -5 7 2 after the 6th op., the sequence is 2 -6 6 -3 -5 2 2 2 -5 7 2 warning: enormous input/output data, be careful with certain languages
